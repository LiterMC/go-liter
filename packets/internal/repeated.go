
// Generated at 2023-09-05 22:06:22.506 -06:00

package internal

import (
	"io"
	. "github.com/kmcsr/go-liter"
	nbt "github.com/kmcsr/go-liter/nbt"
	data "github.com/kmcsr/go-liter/data"
)

func assert(cond bool, msg any){
	if !cond {
		panic(msg)
	}
}

// Protocol=763; ProtocolName=1.20; State=login; Bound=client; ID=0x0
// Protocol=762; ProtocolName=1.19.4; State=login; Bound=client; ID=0x0
// Protocol=761; ProtocolName=1.19.3; State=login; Bound=client; ID=0x0
// Protocol=760; ProtocolName=1.19.2; State=login; Bound=client; ID=0x0
// Protocol=759; ProtocolName=1.19; State=login; Bound=client; ID=0x0
// Protocol=758; ProtocolName=1.18.2; State=login; Bound=client; ID=0x0
// Protocol=757; ProtocolName=1.18.1; State=login; Bound=client; ID=0x0
// Protocol=756; ProtocolName=1.17.1; State=login; Bound=client; ID=0x0
// Protocol=755; ProtocolName=1.17; State=login; Bound=client; ID=0x0
// Protocol=754; ProtocolName=1.16.5; State=login; Bound=client; ID=0x0
// Protocol=753; ProtocolName=1.16.3; State=login; Bound=client; ID=0x0
// Protocol=578; ProtocolName=1.15.2; State=login; Bound=client; ID=0x0
// Protocol=498; ProtocolName=1.14.4; State=login; Bound=client; ID=0x0
// Protocol=404; ProtocolName=1.13.2; State=login; Bound=client; ID=0x0
// Protocol=340; ProtocolName=1.12.2; State=login; Bound=client; ID=0x0
// Protocol=338; ProtocolName=1.12.1; State=login; Bound=client; ID=0x0
// Protocol=335; ProtocolName=1.12; State=login; Bound=client; ID=0x0
// Protocol=316; ProtocolName=1.11.2; State=login; Bound=client; ID=0x0
// Protocol=315; ProtocolName=1.11; State=login; Bound=client; ID=0x0
// Protocol=210; ProtocolName=1.10.2; State=login; Bound=client; ID=0x0
// Protocol=110; ProtocolName=1.9.4; State=login; Bound=client; ID=0x0
// Protocol=47; ProtocolName=1.8.9; State=login; Bound=client; ID=0x0
type LoginDisconnect_763_0 struct {
	Reason Object // Chat
}

var _ Packet = (*LoginDisconnect_763_0)(nil)

func (p LoginDisconnect_763_0)Encode(b *PacketBuilder){
	b.JSON(p.Reason)
}

func (p *LoginDisconnect_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.Reason); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=login; Bound=client; ID=0x1
// Protocol=762; ProtocolName=1.19.4; State=login; Bound=client; ID=0x1
// Protocol=761; ProtocolName=1.19.3; State=login; Bound=client; ID=0x1
// Protocol=760; ProtocolName=1.19.2; State=login; Bound=client; ID=0x1
// Protocol=759; ProtocolName=1.19; State=login; Bound=client; ID=0x1
// Protocol=758; ProtocolName=1.18.2; State=login; Bound=client; ID=0x1
// Protocol=757; ProtocolName=1.18.1; State=login; Bound=client; ID=0x1
// Protocol=756; ProtocolName=1.17.1; State=login; Bound=client; ID=0x1
// Protocol=755; ProtocolName=1.17; State=login; Bound=client; ID=0x1
// Protocol=754; ProtocolName=1.16.5; State=login; Bound=client; ID=0x1
// Protocol=753; ProtocolName=1.16.3; State=login; Bound=client; ID=0x1
// Protocol=578; ProtocolName=1.15.2; State=login; Bound=client; ID=0x1
// Protocol=498; ProtocolName=1.14.4; State=login; Bound=client; ID=0x1
// Protocol=404; ProtocolName=1.13.2; State=login; Bound=client; ID=0x1
// Protocol=340; ProtocolName=1.12.2; State=login; Bound=client; ID=0x1
// Protocol=338; ProtocolName=1.12.1; State=login; Bound=client; ID=0x1
// Protocol=335; ProtocolName=1.12; State=login; Bound=client; ID=0x1
// Protocol=316; ProtocolName=1.11.2; State=login; Bound=client; ID=0x1
// Protocol=315; ProtocolName=1.11; State=login; Bound=client; ID=0x1
// Protocol=210; ProtocolName=1.10.2; State=login; Bound=client; ID=0x1
// Protocol=110; ProtocolName=1.9.4; State=login; Bound=client; ID=0x1
// Protocol=47; ProtocolName=1.8.9; State=login; Bound=client; ID=0x1
type LoginEncryptionRequest_763_0 struct {
	/* Appears to be empty */
	ServerID String // String (20)
	/* Length of Public Key */
	PublicKeyLength VarInt // VarInt
	PublicKey ByteArray // Byte Array
	/* Length of Verify Token. Always 4 for Notchian servers. */
	VerifyTokenLength VarInt // VarInt
	/* A sequence of random bytes generated by the server */
	VerifyToken ByteArray // Byte Array
}

var _ Packet = (*LoginEncryptionRequest_763_0)(nil)

func (p LoginEncryptionRequest_763_0)Encode(b *PacketBuilder){
	b.String(p.ServerID)
	p.PublicKeyLength = (VarInt)(len(p.PublicKey))
	b.VarInt(p.PublicKeyLength)
	b.ByteArray(p.PublicKey)
	p.VerifyTokenLength = (VarInt)(len(p.VerifyToken))
	b.VarInt(p.VerifyTokenLength)
	b.ByteArray(p.VerifyToken)
}

func (p *LoginEncryptionRequest_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ServerID, ok = r.String(); !ok {
		return io.EOF
	}
	if p.PublicKeyLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.PublicKey = make(ByteArray, p.PublicKeyLength)
	if ok = r.ByteArray(p.PublicKey); !ok {
		return io.EOF
	}
	if p.VerifyTokenLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.VerifyToken = make(ByteArray, p.VerifyTokenLength)
	if ok = r.ByteArray(p.VerifyToken); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=login; Bound=server; ID=0x1
// Protocol=762; ProtocolName=1.19.4; State=login; Bound=server; ID=0x1
// Protocol=761; ProtocolName=1.19.3; State=login; Bound=server; ID=0x1
// Protocol=755; ProtocolName=1.17; State=login; Bound=server; ID=0x1
// Protocol=753; ProtocolName=1.16.3; State=login; Bound=server; ID=0x1
// Protocol=578; ProtocolName=1.15.2; State=login; Bound=server; ID=0x1
// Protocol=498; ProtocolName=1.14.4; State=login; Bound=server; ID=0x1
// Protocol=340; ProtocolName=1.12.2; State=login; Bound=server; ID=0x1
// Protocol=47; ProtocolName=1.8.9; State=login; Bound=server; ID=0x1
type LoginEncryptionResponse_763_0 struct {
	/* Length of Shared Secret */
	SharedSecretLength VarInt // VarInt
	SharedSecret ByteArray // Byte Array
	/* Length of Verify Token */
	VerifyTokenLength VarInt // VarInt
	VerifyToken ByteArray // Byte Array
}

var _ Packet = (*LoginEncryptionResponse_763_0)(nil)

func (p LoginEncryptionResponse_763_0)Encode(b *PacketBuilder){
	p.SharedSecretLength = (VarInt)(len(p.SharedSecret))
	b.VarInt(p.SharedSecretLength)
	b.ByteArray(p.SharedSecret)
	p.VerifyTokenLength = (VarInt)(len(p.VerifyToken))
	b.VarInt(p.VerifyTokenLength)
	b.ByteArray(p.VerifyToken)
}

func (p *LoginEncryptionResponse_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SharedSecretLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.SharedSecret = make(ByteArray, p.SharedSecretLength)
	if ok = r.ByteArray(p.SharedSecret); !ok {
		return io.EOF
	}
	if p.VerifyTokenLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.VerifyToken = make(ByteArray, p.VerifyTokenLength)
	if ok = r.ByteArray(p.VerifyToken); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=login; Bound=server; ID=0x1
// Protocol=759; ProtocolName=1.19; State=login; Bound=server; ID=0x1
type LoginEncryptionResponse_760_1 struct {
	/* Length of Shared Secret. */
	SharedSecretLength VarInt // VarInt
	/* Shared Secret value, encrypted with the server's public key. */
	SharedSecret ByteArray // Byte Array
	/* Whether or not the Verify Token should be sent. If not, then the salt and signature will be sent. */
	HasVerifyToken Bool // Boolean
	/* Length of Verify Token. Optional and only sent if Has Verify Token is true. */
	OptionalVerifyTokenLength VarInt // VarInt
	/* Verify Token value, encrypted with the same public key as the shared secret. Optional and only sent if Has Verify Token is true. */
	OptionalVerifyToken ByteArray // Byte Array
	/* Cryptography, used for validating the message signature. Optional and only sent if Has Verify Token is false. */
	OptionalSalt Long // Long
	/* Array Length. Optional and only sent if Has Verify Token is false. */
	OptionalMessageSignatureLength VarInt // VarInt
	/* The bytes of the public key signature the client received from Mojang. Optional and only sent if Has Verify Token is false. */
	OptionalMessageSignature ByteArray // Byte Array
}

var _ Packet = (*LoginEncryptionResponse_760_1)(nil)

func (p LoginEncryptionResponse_760_1)Encode(b *PacketBuilder){
	p.SharedSecretLength = (VarInt)(len(p.SharedSecret))
	b.VarInt(p.SharedSecretLength)
	b.ByteArray(p.SharedSecret)
	b.Bool(p.HasVerifyToken)
	p.OptionalVerifyTokenLength = (VarInt)(len(p.OptionalVerifyToken))
	b.VarInt(p.OptionalVerifyTokenLength)
	b.ByteArray(p.OptionalVerifyToken)
	b.Long(p.OptionalSalt)
	p.OptionalMessageSignatureLength = (VarInt)(len(p.OptionalMessageSignature))
	b.VarInt(p.OptionalMessageSignatureLength)
	b.ByteArray(p.OptionalMessageSignature)
}

func (p *LoginEncryptionResponse_760_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SharedSecretLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.SharedSecret = make(ByteArray, p.SharedSecretLength)
	if ok = r.ByteArray(p.SharedSecret); !ok {
		return io.EOF
	}
	if p.HasVerifyToken, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.OptionalVerifyTokenLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.OptionalVerifyToken = make(ByteArray, p.OptionalVerifyTokenLength)
	if ok = r.ByteArray(p.OptionalVerifyToken); !ok {
		return io.EOF
	}
	if p.OptionalSalt, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.OptionalMessageSignatureLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.OptionalMessageSignature = make(ByteArray, p.OptionalMessageSignatureLength)
	if ok = r.ByteArray(p.OptionalMessageSignature); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=login; Bound=server; ID=0x1
// Protocol=757; ProtocolName=1.18.1; State=login; Bound=server; ID=0x1
// Protocol=756; ProtocolName=1.17.1; State=login; Bound=server; ID=0x1
// Protocol=754; ProtocolName=1.16.5; State=login; Bound=server; ID=0x1
// Protocol=404; ProtocolName=1.13.2; State=login; Bound=server; ID=0x1
// Protocol=338; ProtocolName=1.12.1; State=login; Bound=server; ID=0x1
// Protocol=335; ProtocolName=1.12; State=login; Bound=server; ID=0x1
// Protocol=316; ProtocolName=1.11.2; State=login; Bound=server; ID=0x1
// Protocol=315; ProtocolName=1.11; State=login; Bound=server; ID=0x1
// Protocol=210; ProtocolName=1.10.2; State=login; Bound=server; ID=0x1
// Protocol=110; ProtocolName=1.9.4; State=login; Bound=server; ID=0x1
type LoginEncryptionResponse_758_2 struct {
	/* Length of Shared Secret. */
	SharedSecretLength VarInt // VarInt
	/* Shared Secret value, encrypted with the server's public key. */
	SharedSecret ByteArray // Byte Array
	/* Length of Verify Token. */
	VerifyTokenLength VarInt // VarInt
	/* Verify Token value, encrypted with the same public key as the shared secret. */
	VerifyToken ByteArray // Byte Array
}

var _ Packet = (*LoginEncryptionResponse_758_2)(nil)

func (p LoginEncryptionResponse_758_2)Encode(b *PacketBuilder){
	p.SharedSecretLength = (VarInt)(len(p.SharedSecret))
	b.VarInt(p.SharedSecretLength)
	b.ByteArray(p.SharedSecret)
	p.VerifyTokenLength = (VarInt)(len(p.VerifyToken))
	b.VarInt(p.VerifyTokenLength)
	b.ByteArray(p.VerifyToken)
}

func (p *LoginEncryptionResponse_758_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SharedSecretLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.SharedSecret = make(ByteArray, p.SharedSecretLength)
	if ok = r.ByteArray(p.SharedSecret); !ok {
		return io.EOF
	}
	if p.VerifyTokenLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.VerifyToken = make(ByteArray, p.VerifyTokenLength)
	if ok = r.ByteArray(p.VerifyToken); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=login; Bound=client; ID=0x4
// Protocol=762; ProtocolName=1.19.4; State=login; Bound=client; ID=0x4
// Protocol=761; ProtocolName=1.19.3; State=login; Bound=client; ID=0x4
// Protocol=760; ProtocolName=1.19.2; State=login; Bound=client; ID=0x4
// Protocol=759; ProtocolName=1.19; State=login; Bound=client; ID=0x4
// Protocol=758; ProtocolName=1.18.2; State=login; Bound=client; ID=0x4
// Protocol=757; ProtocolName=1.18.1; State=login; Bound=client; ID=0x4
// Protocol=756; ProtocolName=1.17.1; State=login; Bound=client; ID=0x4
// Protocol=755; ProtocolName=1.17; State=login; Bound=client; ID=0x4
// Protocol=754; ProtocolName=1.16.5; State=login; Bound=client; ID=0x4
// Protocol=753; ProtocolName=1.16.3; State=login; Bound=client; ID=0x4
// Protocol=578; ProtocolName=1.15.2; State=login; Bound=client; ID=0x4
// Protocol=498; ProtocolName=1.14.4; State=login; Bound=client; ID=0x4
// Protocol=404; ProtocolName=1.13.2; State=login; Bound=client; ID=0x4
type LoginPluginRequest_763_0 struct {
	/* Generated by the server - should be unique to the connection. */
	MessageID VarInt // VarInt
	/* Name of the plugin channel used to send the data */
	Channel String // Identifier
	/* Any data, depending on the channel. The length of this array must be inferred from the packet length. */
	Data ByteArray // Byte Array
}

var _ Packet = (*LoginPluginRequest_763_0)(nil)

func (p LoginPluginRequest_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.MessageID)
	b.String(p.Channel)
	b.ByteArray(p.Data)
}

func (p *LoginPluginRequest_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.MessageID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Channel, ok = r.String(); !ok {
		return io.EOF
	}
	p.Data = r.ReadAll()
	return nil
}

// Protocol=763; ProtocolName=1.20; State=login; Bound=server; ID=0x2
// Protocol=762; ProtocolName=1.19.4; State=login; Bound=server; ID=0x2
// Protocol=761; ProtocolName=1.19.3; State=login; Bound=server; ID=0x2
// Protocol=760; ProtocolName=1.19.2; State=login; Bound=server; ID=0x2
// Protocol=759; ProtocolName=1.19; State=login; Bound=server; ID=0x2
// Protocol=758; ProtocolName=1.18.2; State=login; Bound=server; ID=0x2
// Protocol=757; ProtocolName=1.18.1; State=login; Bound=server; ID=0x2
// Protocol=756; ProtocolName=1.17.1; State=login; Bound=server; ID=0x2
// Protocol=755; ProtocolName=1.17; State=login; Bound=server; ID=0x2
// Protocol=754; ProtocolName=1.16.5; State=login; Bound=server; ID=0x2
// Protocol=753; ProtocolName=1.16.3; State=login; Bound=server; ID=0x2
// Protocol=578; ProtocolName=1.15.2; State=login; Bound=server; ID=0x2
// Protocol=498; ProtocolName=1.14.4; State=login; Bound=server; ID=0x2
// Protocol=404; ProtocolName=1.13.2; State=login; Bound=server; ID=0x2
type LoginPluginResponse_763_0 struct {
	/* Should match ID from server. */
	MessageID VarInt // VarInt
	/* true if the client understands the request, false otherwise. When false, no payload follows. */
	Successful Bool // Boolean
	/* Any data, depending on the channel. The length of this array must be inferred from the packet length. */
	Data ByteArray // Optional Byte Array
}

var _ Packet = (*LoginPluginResponse_763_0)(nil)

func (p LoginPluginResponse_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.MessageID)
	b.Bool(p.Successful)
	b.ByteArray(p.Data)
}

func (p *LoginPluginResponse_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.MessageID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Successful, ok = r.Bool(); !ok {
		return io.EOF
	}
	p.Data = r.ReadAll()
	return nil
}

// Protocol=763; ProtocolName=1.20; State=login; Bound=client; ID=0x3
// Protocol=762; ProtocolName=1.19.4; State=login; Bound=client; ID=0x3
// Protocol=761; ProtocolName=1.19.3; State=login; Bound=client; ID=0x3
// Protocol=760; ProtocolName=1.19.2; State=login; Bound=client; ID=0x3
// Protocol=759; ProtocolName=1.19; State=login; Bound=client; ID=0x3
// Protocol=758; ProtocolName=1.18.2; State=login; Bound=client; ID=0x3
// Protocol=757; ProtocolName=1.18.1; State=login; Bound=client; ID=0x3
// Protocol=756; ProtocolName=1.17.1; State=login; Bound=client; ID=0x3
// Protocol=755; ProtocolName=1.17; State=login; Bound=client; ID=0x3
// Protocol=754; ProtocolName=1.16.5; State=login; Bound=client; ID=0x3
// Protocol=753; ProtocolName=1.16.3; State=login; Bound=client; ID=0x3
// Protocol=578; ProtocolName=1.15.2; State=login; Bound=client; ID=0x3
// Protocol=498; ProtocolName=1.14.4; State=login; Bound=client; ID=0x3
// Protocol=404; ProtocolName=1.13.2; State=login; Bound=client; ID=0x3
// Protocol=340; ProtocolName=1.12.2; State=login; Bound=client; ID=0x3
// Protocol=338; ProtocolName=1.12.1; State=login; Bound=client; ID=0x3
// Protocol=335; ProtocolName=1.12; State=login; Bound=client; ID=0x3
// Protocol=316; ProtocolName=1.11.2; State=login; Bound=client; ID=0x3
// Protocol=315; ProtocolName=1.11; State=login; Bound=client; ID=0x3
// Protocol=210; ProtocolName=1.10.2; State=login; Bound=client; ID=0x3
// Protocol=110; ProtocolName=1.9.4; State=login; Bound=client; ID=0x3
// Protocol=47; ProtocolName=1.8.9; State=login; Bound=client; ID=0x3
type LoginSetCompression_763_0 struct {
	/* Maximum size of a packet before it is compressed */
	Threshold VarInt // VarInt
}

var _ Packet = (*LoginSetCompression_763_0)(nil)

func (p LoginSetCompression_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.Threshold)
}

func (p *LoginSetCompression_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Threshold, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=login; Bound=server; ID=0x0
// Protocol=762; ProtocolName=1.19.4; State=login; Bound=server; ID=0x0
// Protocol=761; ProtocolName=1.19.3; State=login; Bound=server; ID=0x0
type LoginStart_763_0 struct {
	/* Player's Username. */
	Name String // String (16)
	/* Whether or not the next field should be sent. */
	HasPlayerUUID Bool // Boolean
	/* The UUID of the player logging in. Only sent if Has Player UUID is true. */
	PlayerUUID Optional[UUID] // Optional UUID
}

var _ Packet = (*LoginStart_763_0)(nil)

func (p LoginStart_763_0)Encode(b *PacketBuilder){
	b.String(p.Name)
	p.HasPlayerUUID = p.PlayerUUID.Ok
	b.Bool(p.HasPlayerUUID)
	if p.PlayerUUID.Ok {
		b.UUID(p.PlayerUUID.V)
	}
}

func (p *LoginStart_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Name, ok = r.String(); !ok {
		return io.EOF
	}
	if p.HasPlayerUUID, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.PlayerUUID.Ok = p.HasPlayerUUID; p.PlayerUUID.Ok {
		if p.PlayerUUID.V, ok = r.UUID(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=login; Bound=server; ID=0x0
// Protocol=759; ProtocolName=1.19; State=login; Bound=server; ID=0x0
type LoginStart_760_1 struct {
	/* Player's Username. */
	Name String // String (16)
	/* Whether or not the next 5 fields should be sent. */
	HasSigData Bool // Boolean
	/* When the key data will expire. Optional. Only sent if Has Sig Data is true. */
	Timestamp Long // Long
	/* Length of Public Key. Optional. Only sent if Has Sig Data is true. */
	PublicKeyLength VarInt // VarInt
	/* The encoded bytes of the public key the client received from Mojang. Optional. Only sent if Has Sig Data is true. */
	PublicKey ByteArray // Byte Array
	/* Length of Signature. Optional. Only sent if Has Sig Data is true. */
	SignatureLength VarInt // VarInt
	/* The bytes of the public key signature the client received from Mojang. Optional. Only sent if Has Sig Data is true. */
	Signature ByteArray // Byte Array
	/* Whether or not the next field should be sent. */
	HasPlayerUUID Bool // Boolean
	/* The UUID of the player logging in. Optional. Only sent if Has Player UUID is true. */
	PlayerUUID UUID // UUID
}

var _ Packet = (*LoginStart_760_1)(nil)

func (p LoginStart_760_1)Encode(b *PacketBuilder){
	b.String(p.Name)
	b.Bool(p.HasSigData)
	b.Long(p.Timestamp)
	p.PublicKeyLength = (VarInt)(len(p.PublicKey))
	b.VarInt(p.PublicKeyLength)
	b.ByteArray(p.PublicKey)
	p.SignatureLength = (VarInt)(len(p.Signature))
	b.VarInt(p.SignatureLength)
	b.ByteArray(p.Signature)
	b.Bool(p.HasPlayerUUID)
	b.UUID(p.PlayerUUID)
}

func (p *LoginStart_760_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Name, ok = r.String(); !ok {
		return io.EOF
	}
	if p.HasSigData, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.Timestamp, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.PublicKeyLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.PublicKey = make(ByteArray, p.PublicKeyLength)
	if ok = r.ByteArray(p.PublicKey); !ok {
		return io.EOF
	}
	if p.SignatureLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Signature = make(ByteArray, p.SignatureLength)
	if ok = r.ByteArray(p.Signature); !ok {
		return io.EOF
	}
	if p.HasPlayerUUID, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.PlayerUUID, ok = r.UUID(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=login; Bound=server; ID=0x0
// Protocol=757; ProtocolName=1.18.1; State=login; Bound=server; ID=0x0
// Protocol=756; ProtocolName=1.17.1; State=login; Bound=server; ID=0x0
// Protocol=755; ProtocolName=1.17; State=login; Bound=server; ID=0x0
// Protocol=754; ProtocolName=1.16.5; State=login; Bound=server; ID=0x0
// Protocol=753; ProtocolName=1.16.3; State=login; Bound=server; ID=0x0
// Protocol=578; ProtocolName=1.15.2; State=login; Bound=server; ID=0x0
// Protocol=498; ProtocolName=1.14.4; State=login; Bound=server; ID=0x0
// Protocol=404; ProtocolName=1.13.2; State=login; Bound=server; ID=0x0
// Protocol=340; ProtocolName=1.12.2; State=login; Bound=server; ID=0x0
// Protocol=338; ProtocolName=1.12.1; State=login; Bound=server; ID=0x0
// Protocol=335; ProtocolName=1.12; State=login; Bound=server; ID=0x0
// Protocol=316; ProtocolName=1.11.2; State=login; Bound=server; ID=0x0
// Protocol=315; ProtocolName=1.11; State=login; Bound=server; ID=0x0
// Protocol=210; ProtocolName=1.10.2; State=login; Bound=server; ID=0x0
// Protocol=110; ProtocolName=1.9.4; State=login; Bound=server; ID=0x0
// Protocol=47; ProtocolName=1.8.9; State=login; Bound=server; ID=0x0
type LoginStart_758_2 struct {
	/* Player's Username */
	Name String // String (16)
}

var _ Packet = (*LoginStart_758_2)(nil)

func (p LoginStart_758_2)Encode(b *PacketBuilder){
	b.String(p.Name)
}

func (p *LoginStart_758_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Name, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=login; Bound=client; ID=0x2
// Protocol=762; ProtocolName=1.19.4; State=login; Bound=client; ID=0x2
// Protocol=761; ProtocolName=1.19.3; State=login; Bound=client; ID=0x2
// Protocol=760; ProtocolName=1.19.2; State=login; Bound=client; ID=0x2
// Protocol=759; ProtocolName=1.19; State=login; Bound=client; ID=0x2
type LoginSuccess_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name           | Field Name           | Field Type  | Field Type              | Notes                                      |
	 * |-----------|-------|----------|----------------------|----------------------|-------------|-------------------------|--------------------------------------------|
	 * | 0x02      | Login | Client   | UUID                 | UUID                 | UUID        | UUID                    |                                            |
	 * | 0x02      | Login | Client   | Username             | Username             | String (16) | String (16)             |                                            |
	 * | 0x02      | Login | Client   | Number Of Properties | Number Of Properties | VarInt      | VarInt                  | Number of elements in the following array. |
	 * | 0x02      | Login | Client   | Property             | Name                 | Array       | String (32767)          |                                            |
	 * | 0x02      | Login | Client   | Property             | Value                | Array       | String (32767)          |                                            |
	 * | 0x02      | Login | Client   | Property             | Is Signed            | Array       | Boolean                 |                                            |
	 * | 0x02      | Login | Client   | Property             | Signature            | Array       | Optional String (32767) | Only if Is Signed is true.                 |
	 * 
	 */
}

// Protocol=758; ProtocolName=1.18.2; State=login; Bound=client; ID=0x2
// Protocol=757; ProtocolName=1.18.1; State=login; Bound=client; ID=0x2
// Protocol=756; ProtocolName=1.17.1; State=login; Bound=client; ID=0x2
// Protocol=755; ProtocolName=1.17; State=login; Bound=client; ID=0x2
// Protocol=754; ProtocolName=1.16.5; State=login; Bound=client; ID=0x2
// Protocol=753; ProtocolName=1.16.3; State=login; Bound=client; ID=0x2
type LoginSuccess_758_1 struct {
	UUID UUID // UUID
	Username String // String (16)
}

var _ Packet = (*LoginSuccess_758_1)(nil)

func (p LoginSuccess_758_1)Encode(b *PacketBuilder){
	b.UUID(p.UUID)
	b.String(p.Username)
}

func (p *LoginSuccess_758_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.UUID, ok = r.UUID(); !ok {
		return io.EOF
	}
	if p.Username, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=578; ProtocolName=1.15.2; State=login; Bound=client; ID=0x2
// Protocol=498; ProtocolName=1.14.4; State=login; Bound=client; ID=0x2
// Protocol=404; ProtocolName=1.13.2; State=login; Bound=client; ID=0x2
// Protocol=340; ProtocolName=1.12.2; State=login; Bound=client; ID=0x2
// Protocol=338; ProtocolName=1.12.1; State=login; Bound=client; ID=0x2
// Protocol=335; ProtocolName=1.12; State=login; Bound=client; ID=0x2
// Protocol=316; ProtocolName=1.11.2; State=login; Bound=client; ID=0x2
// Protocol=315; ProtocolName=1.11; State=login; Bound=client; ID=0x2
// Protocol=210; ProtocolName=1.10.2; State=login; Bound=client; ID=0x2
// Protocol=110; ProtocolName=1.9.4; State=login; Bound=client; ID=0x2
// Protocol=47; ProtocolName=1.8.9; State=login; Bound=client; ID=0x2
type LoginSuccess_578_2 struct {
	/* Unlike in other packets, this field contains the UUID as a string with hyphens. */
	UUID String // String (36)
	Username String // String (16)
}

var _ Packet = (*LoginSuccess_578_2)(nil)

func (p LoginSuccess_578_2)Encode(b *PacketBuilder){
	b.String(p.UUID)
	b.String(p.Username)
}

func (p *LoginSuccess_578_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.UUID, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Username, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x6
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x6
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x5
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x5
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x5
type PlayAcknowledgeBlockChange_763_0 struct {
	/* Represents the sequence to acknowledge, this is used for properly syncing block changes to the client after interactions. */
	SequenceID VarInt // VarInt
}

var _ Packet = (*PlayAcknowledgeBlockChange_763_0)(nil)

func (p PlayAcknowledgeBlockChange_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.SequenceID)
}

func (p *PlayAcknowledgeBlockChange_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SequenceID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x8
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x8
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x8
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x8
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x7
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x7
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x8
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x5c
type PlayAcknowledgePlayerDigging_758_0 struct {
	/* Position where the digging was happening */
	Location Position // Position
	/* Block state ID of the block that should be at that position now. */
	Block VarInt // VarInt
	/* Same as Player Digging.  Only Started digging (0), Cancelled digging (1), and Finished digging (2) are used. */
	Status VarInt // VarInt enum
	/* True if the digging succeeded; false if the client should undo any changes it made locally.  (How does this work?) */
	Successful Bool // Boolean
}

var _ Packet = (*PlayAcknowledgePlayerDigging_758_0)(nil)

func (p PlayAcknowledgePlayerDigging_758_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.VarInt(p.Block)
	b.VarInt(p.Status)
	b.Bool(p.Successful)
}

func (p *PlayAcknowledgePlayerDigging_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Block, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Status, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Successful, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x41
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x41
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x41
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x41
type PlayActionBar_758_0 struct {
	/* Displays a message above the hotbar (the same as position 2 in Chat Message (clientbound). */
	ActionBarText Object // Chat
}

var _ Packet = (*PlayActionBar_758_0)(nil)

func (p PlayActionBar_758_0)Encode(b *PacketBuilder){
	b.JSON(p.ActionBarText)
}

func (p *PlayActionBar_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.ActionBarText); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x22
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x22
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x22
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x22
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x22
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x22
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x20
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x20
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x1e
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x19
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x19
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x19
type PlayAdvancementTab_758_0 struct {
	/* 0: Opened tab, 1: Closed screen */
	Action VarInt // VarInt enum
	/* Only present if action is Opened tab */
	TabID Optional[String] // Optional identifier
}

var _ Packet = (*PlayAdvancementTab_758_0)(nil)

func (p PlayAdvancementTab_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.Action)
	if p.Action == 0 {
		b.String(p.TabID.Assert())
	}
}

func (p *PlayAdvancementTab_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Action, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.TabID.Ok = p.Action == 0; p.TabID.Ok {
		if p.TabID.V, ok = r.String(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x63
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x63
type PlayAdvancements_758_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name    | Field Type          | Field Type           | Notes                                                       |
	 * |-----------|-------|----------|---------------------|---------------|---------------------|----------------------|-------------------------------------------------------------|
	 * | 0x63      | Play  | Client   | Reset/Clear         | Reset/Clear   | Boolean             | Boolean              | Whether to reset/clear the current advancements.            |
	 * | 0x63      | Play  | Client   | Mapping size        | Mapping size  | VarInt              | VarInt               | Size of the following array.                                |
	 * | 0x63      | Play  | Client   | Advancement mapping | Key           | Array               | Identifier           | The identifier of the advancement.                          |
	 * | 0x63      | Play  | Client   | Advancement mapping | Value         | Array               | Advancement          | See below                                                   |
	 * | 0x63      | Play  | Client   | List size           | List size     | VarInt              | VarInt               | Size of the following array.                                |
	 * | 0x63      | Play  | Client   | Identifiers         | Identifiers   | Array of Identifier | Array of Identifier  | The identifiers of the advancements that should be removed. |
	 * | 0x63      | Play  | Client   | Progress size       | Progress size | VarInt              | VarInt               | Size of the following array.                                |
	 * | 0x63      | Play  | Client   | Progress mapping    | Key           | Array               | Identifier           | The identifier of the advancement.                          |
	 * | 0x63      | Play  | Client   | Progress mapping    | Value         | Array               | Advancement progress | See below.                                                  |
	 * 
	 */
}

// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x62
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x62
type PlayAdvancements_756_1 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name    | Field Type          | Field Type           | Notes                                                       |
	 * |-----------|-------|----------|---------------------|---------------|---------------------|----------------------|-------------------------------------------------------------|
	 * | 0x62      | Play  | Client   | Reset/Clear         | Reset/Clear   | Boolean             | Boolean              | Whether to reset/clear the current advancements.            |
	 * | 0x62      | Play  | Client   | Mapping size        | Mapping size  | VarInt              | VarInt               | Size of the following array.                                |
	 * | 0x62      | Play  | Client   | Advancement mapping | Key           | Array               | Identifier           | The identifier of the advancement.                          |
	 * | 0x62      | Play  | Client   | Advancement mapping | Value         | Array               | Advancement          | See below                                                   |
	 * | 0x62      | Play  | Client   | List size           | List size     | VarInt              | VarInt               | Size of the following array.                                |
	 * | 0x62      | Play  | Client   | Identifiers         | Identifiers   | Array of Identifier | Array of Identifier  | The identifiers of the advancements that should be removed. |
	 * | 0x62      | Play  | Client   | Progress size       | Progress size | VarInt              | VarInt               | Size of the following array.                                |
	 * | 0x62      | Play  | Client   | Progress mapping    | Key           | Array               | Identifier           | The identifier of the advancement.                          |
	 * | 0x62      | Play  | Client   | Progress mapping    | Value         | Array               | Advancement progress | See below.                                                  |
	 * 
	 */
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x57
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x57
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x57
type PlayAdvancements_754_2 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name    | Field Type          | Field Type           | Notes                                                      |
	 * |-----------|-------|----------|---------------------|---------------|---------------------|----------------------|------------------------------------------------------------|
	 * | 0x57      | Play  | Client   | Reset/Clear         | Reset/Clear   | Boolean             | Boolean              | Whether to reset/clear the current advancements            |
	 * | 0x57      | Play  | Client   | Mapping size        | Mapping size  | VarInt              | VarInt               | Size of the following array                                |
	 * | 0x57      | Play  | Client   | Advancement mapping | Key           | Array               | Identifier           | The identifier of the advancement                          |
	 * | 0x57      | Play  | Client   | Advancement mapping | Value         | Array               | Advancement          | See below                                                  |
	 * | 0x57      | Play  | Client   | List size           | List size     | VarInt              | VarInt               | Size of the following array                                |
	 * | 0x57      | Play  | Client   | Identifiers         | Identifiers   | Array of Identifier | Array of Identifier  | The identifiers of the advancements that should be removed |
	 * | 0x57      | Play  | Client   | Progress size       | Progress size | VarInt              | VarInt               | Size of the following array                                |
	 * | 0x57      | Play  | Client   | Progress mapping    | Key           | Array               | Identifier           | The identifier of the advancement                          |
	 * | 0x57      | Play  | Client   | Progress mapping    | Value         | Array               | Advancement progress | See below                                                  |
	 * 
	 */
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x4d
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x4d
type PlayAdvancements_340_5 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name    | Field Type          | Field Type           | Notes                                                      |
	 * |-----------|-------|----------|---------------------|---------------|---------------------|----------------------|------------------------------------------------------------|
	 * | 0x4D      | Play  | Client   | Reset/Clear         | Reset/Clear   | Boolean             | Boolean              | Whether to reset/clear the current advancements            |
	 * | 0x4D      | Play  | Client   | Mapping size        | Mapping size  | VarInt              | VarInt               | Size of the following array                                |
	 * | 0x4D      | Play  | Client   | Advancement mapping | Key           | Array               | Identifier           | The identifier of the advancement                          |
	 * | 0x4D      | Play  | Client   | Advancement mapping | Value         | Array               | Advancement          | See below                                                  |
	 * | 0x4D      | Play  | Client   | List size           | List size     | VarInt              | VarInt               | Size of the following array                                |
	 * | 0x4D      | Play  | Client   | Identifiers         | Identifiers   | Array of Identifier | Array of Identifier  | The identifiers of the advancements that should be removed |
	 * | 0x4D      | Play  | Client   | Progress size       | Progress size | VarInt              | VarInt               | Size of the following array                                |
	 * | 0x4D      | Play  | Client   | Progress mapping    | Key           | Array               | Identifier           | The identifier of the advancement                          |
	 * | 0x4D      | Play  | Client   | Progress mapping    | Value         | Array               | Advancement progress | See below                                                  |
	 * 
	 */
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x2c
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x2c
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x2c
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x2c
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x2c
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x2c
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x2a
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x2a
type PlayAnimation_758_0 struct {
	/* Hand used for the animation. 0: main hand, 1: off hand. */
	Hand VarInt // VarInt Enum
}

var _ Packet = (*PlayAnimation_758_0)(nil)

func (p PlayAnimation_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.Hand)
}

func (p *PlayAnimation_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Hand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x6
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x6
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x6
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x6
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x6
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x6
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x6
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x6
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0xb
type PlayAnimation_404_1 struct {
	/* Player ID */
	EntityID VarInt // VarInt
	/* Animation ID (see below) */
	Animation UByte // Unsigned Byte
}

var _ Packet = (*PlayAnimation_404_1)(nil)

func (p PlayAnimation_404_1)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UByte(p.Animation)
}

func (p *PlayAnimation_404_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Animation, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x27
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x1d
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x1d
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x1d
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x1a
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x1a
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x1a
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x1a
type PlayAnimationServer_404_0 struct {
	/* Hand used for the animation. 0: main hand, 1: off hand. */
	Hand VarInt // VarInt Enum
}

var _ Packet = (*PlayAnimationServer_404_0)(nil)

func (p PlayAnimationServer_404_0)Encode(b *PacketBuilder){
	b.VarInt(p.Hand)
}

func (p *PlayAnimationServer_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Hand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x4e
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x4e
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x4e
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x4e
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x45
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x45
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x45
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x44
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x40
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x3d
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x3d
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x3c
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x3a
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x3a
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x3a
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x3a
type PlayAttachEntity_758_0 struct {
	/* Attached entity's EID */
	AttachedEntityID Int // Int
	/* ID of the entity holding the lead. Set to -1 to detach. */
	HoldingEntityID Int // Int
}

var _ Packet = (*PlayAttachEntity_758_0)(nil)

func (p PlayAttachEntity_758_0)Encode(b *PacketBuilder){
	b.Int(p.AttachedEntityID)
	b.Int(p.HoldingEntityID)
}

func (p *PlayAttachEntity_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.AttachedEntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.HoldingEntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x5
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x5
type PlayAwardStatistics_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name   | Field Type | Field Type | Notes                                      |
	 * |-----------|-------|----------|------------|--------------|------------|------------|--------------------------------------------|
	 * | 0x05      | Play  | Client   | Count      | Count        | VarInt     | VarInt     | Number of elements in the following array. |
	 * | 0x05      | Play  | Client   | Statistic  | Category ID  | Array      | VarInt     | See below.                                 |
	 * | 0x05      | Play  | Client   | Statistic  | Statistic ID | Array      | VarInt     | See below.                                 |
	 * | 0x05      | Play  | Client   | Statistic  | Value        | Array      | VarInt     | The amount to set it to.                   |
	 * 
	 */
}

// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x4
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x4
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x4
type PlayAwardStatistics_761_1 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name   | Field Type | Field Type | Notes                                      |
	 * |-----------|-------|----------|------------|--------------|------------|------------|--------------------------------------------|
	 * | 0x04      | Play  | Client   | Count      | Count        | VarInt     | VarInt     | Number of elements in the following array. |
	 * | 0x04      | Play  | Client   | Statistic  | Category ID  | Array      | VarInt     | See below.                                 |
	 * | 0x04      | Play  | Client   | Statistic  | Statistic ID | Array      | VarInt     | See below.                                 |
	 * | 0x04      | Play  | Client   | Statistic  | Value        | Array      | VarInt     | The amount to set it to.                   |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x9
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x9
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x8
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x8
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x8
type PlayBlockAction_763_0 struct {
	/* Block coordinates. */
	Location Position // Position
	/* Varies depending on block — see Block Actions. */
	ActionID UByte // Unsigned Byte
	/* Varies depending on block — see Block Actions. */
	ActionParameter UByte // Unsigned Byte
	/* The block type ID for the block.  This must match the block at the given coordinates. */
	BlockType VarInt // VarInt
}

var _ Packet = (*PlayBlockAction_763_0)(nil)

func (p PlayBlockAction_763_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.UByte(p.ActionID)
	b.UByte(p.ActionParameter)
	b.VarInt(p.BlockType)
}

func (p *PlayBlockAction_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.ActionID, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.ActionParameter, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.BlockType, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0xb
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0xb
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0xb
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0xb
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0xa
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0xa
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0xb
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0xa
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0xa
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0xa
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0xa
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0xa
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0xa
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0xa
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0xa
type PlayBlockAction_758_1 struct {
	/* Block coordinates */
	Location Position // Position
	/* Varies depending on block — see Block Actions */
	ActionID UByte // Unsigned Byte
	/* Varies depending on block — see Block Actions */
	ActionParam UByte // Unsigned Byte
	/* The block type ID for the block, not including metadata/damage value.  This must match the block at the given coordinates. */
	BlockType VarInt // VarInt
}

var _ Packet = (*PlayBlockAction_758_1)(nil)

func (p PlayBlockAction_758_1)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.UByte(p.ActionID)
	b.UByte(p.ActionParam)
	b.VarInt(p.BlockType)
}

func (p *PlayBlockAction_758_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.ActionID, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.ActionParam, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.BlockType, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0xa
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x24
type PlayBlockAction_110_2 struct {
	/* Block coordinates */
	Location Position // Position
	/* Varies depending on block — see Block Actions */
	Byte1 UByte // Unsigned Byte
	/* Varies depending on block — see Block Actions */
	Byte2 UByte // Unsigned Byte
	/* The block type ID for the block, not including metadata/damage value */
	BlockType VarInt // VarInt
}

var _ Packet = (*PlayBlockAction_110_2)(nil)

func (p PlayBlockAction_110_2)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.UByte(p.Byte1)
	b.UByte(p.Byte2)
	b.VarInt(p.BlockType)
}

func (p *PlayBlockAction_110_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Byte1, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Byte2, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.BlockType, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x9
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x9
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x9
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x9
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x8
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x8
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x9
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x8
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x8
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x8
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x8
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x8
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x8
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x8
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x8
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x8
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x25
type PlayBlockBreakAnimation_758_0 struct {
	/* Entity ID of the entity breaking the block */
	EntityID VarInt // VarInt
	/* Block Position */
	Location Position // Position
	/* 0–9 to set it, any other value to remove it */
	DestroyStage Byte // Byte
}

var _ Packet = (*PlayBlockBreakAnimation_758_0)(nil)

func (p PlayBlockBreakAnimation_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	p.Location.Encode(b)
	b.Byte(p.DestroyStage)
}

func (p *PlayBlockBreakAnimation_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.DestroyStage, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0xc
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0xc
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0xc
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0xc
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0xb
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0xb
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0xc
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0xb
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0xb
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0xb
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0xb
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0xb
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0xb
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0xb
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0xb
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0xb
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x23
type PlayBlockChange_758_0 struct {
	/* Block Coordinates */
	Location Position // Position
	/* The new block state ID for the block as given in the global palette (When reading data: type = id >> 4, meta = id & 15, when writing data: id = type << 4 | (meta & 15)) */
	BlockID VarInt // VarInt
}

var _ Packet = (*PlayBlockChange_758_0)(nil)

func (p PlayBlockChange_758_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.VarInt(p.BlockID)
}

func (p *PlayBlockChange_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.BlockID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x8
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x8
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x7
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x7
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x7
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0xa
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0xa
type PlayBlockEntityData_763_0 struct {
	Location Position // Position
	/* The type of the block entity */
	Type VarInt // VarInt
	/* Data to set.  May be a TAG_END (0), in which case the block entity at the given location is removed (though this is not required since the client will remove the block entity automatically on chunk unload or block removal). */
	NBTData nbt.NBT // NBT Tag
}

var _ Packet = (*PlayBlockEntityData_763_0)(nil)

func (p PlayBlockEntityData_763_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.VarInt(p.Type)
	nbt.WriteNBT(b, p.NBTData)
}

func (p *PlayBlockEntityData_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Type, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.NBTData, err = nbt.ReadNBT(r); err != nil {
		return err
	}
	return nil
}

// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0xa
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0xa
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x9
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x9
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0xa
type PlayBlockEntityData_756_1 struct {
	Location Position // Position
	/* The type of update to perform, see below */
	Action UByte // Unsigned Byte
	/* Data to set.  May be a TAG_END (0), in which case the block entity at the given location is removed (though this is not required since the client will remove the block entity automatically on chunk unload or block removal) */
	NBTData nbt.NBT // NBT Tag
}

var _ Packet = (*PlayBlockEntityData_756_1)(nil)

func (p PlayBlockEntityData_756_1)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.UByte(p.Action)
	nbt.WriteNBT(b, p.NBTData)
}

func (p *PlayBlockEntityData_756_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Action, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.NBTData, err = nbt.ReadNBT(r); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0xa
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0xa
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x9
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x9
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x9
type PlayBlockUpdate_763_0 struct {
	/* Block Coordinates. */
	Location Position // Position
	/* The new block state ID for the block as given in the global palette. See that section for more information. */
	BlockID VarInt // VarInt
}

var _ Packet = (*PlayBlockUpdate_763_0)(nil)

func (p PlayBlockUpdate_763_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.VarInt(p.BlockID)
}

func (p *PlayBlockUpdate_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.BlockID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0xb
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0xb
type PlayBossBar_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name       | Field Name | Field Type    | Notes                                                                                                                                     |
	 * |-----------|-------|----------|------------------|------------|---------------|-------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x0B      | Play  | Client   | UUID             | UUID       | UUID          | Unique ID for this bar.                                                                                                                   |
	 * | 0x0B      | Play  | Client   | Action           | Action     | VarInt Enum   | Determines the layout of the remaining packet.                                                                                            |
	 * | 0x0B      | Play  | Client   | Action           | Field Name |               |                                                                                                                                           |
	 * | 0x0B      | Play  | Client   | 0: add           | Title      | Chat          |                                                                                                                                           |
	 * | 0x0B      | Play  | Client   | 0: add           | Health     | Float         | From 0 to 1. Values greater than 1 do not crash a Notchian client, and start rendering part of a second health bar at around 1.5.         |
	 * | 0x0B      | Play  | Client   | 0: add           | Color      | VarInt Enum   | Color ID (see below).                                                                                                                     |
	 * | 0x0B      | Play  | Client   | 0: add           | Division   | VarInt Enum   | Type of division (see below).                                                                                                             |
	 * | 0x0B      | Play  | Client   | 0: add           | Flags      | Unsigned Byte | Bit mask. 0x1: should darken sky, 0x2: is dragon bar (used to play end music), 0x04: create fog (previously was also controlled by 0x02). |
	 * | 0x0B      | Play  | Client   | 1: remove        | no fields  | no fields     | Removes this boss bar.                                                                                                                    |
	 * | 0x0B      | Play  | Client   | 2: update health | Health     | Float         | as above                                                                                                                                  |
	 * | 0x0B      | Play  | Client   | 3: update title  | Title      | Chat          |                                                                                                                                           |
	 * | 0x0B      | Play  | Client   | 4: update style  | Color      | VarInt Enum   | Color ID (see below).                                                                                                                     |
	 * | 0x0B      | Play  | Client   | 4: update style  | Dividers   | VarInt Enum   | as above                                                                                                                                  |
	 * | 0x0B      | Play  | Client   | 5: update flags  | Flags      | Unsigned Byte | as above                                                                                                                                  |
	 * 
	 */
}

// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0xa
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0xa
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0xa
type PlayBossBar_761_1 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name       | Field Name | Field Type    | Notes                                                                                                                                     |
	 * |-----------|-------|----------|------------------|------------|---------------|-------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x0A      | Play  | Client   | UUID             | UUID       | UUID          | Unique ID for this bar.                                                                                                                   |
	 * | 0x0A      | Play  | Client   | Action           | Action     | VarInt Enum   | Determines the layout of the remaining packet.                                                                                            |
	 * | 0x0A      | Play  | Client   | Action           | Field Name |               |                                                                                                                                           |
	 * | 0x0A      | Play  | Client   | 0: add           | Title      | Chat          |                                                                                                                                           |
	 * | 0x0A      | Play  | Client   | 0: add           | Health     | Float         | From 0 to 1. Values greater than 1 do not crash a Notchian client, and start rendering part of a second health bar at around 1.5.         |
	 * | 0x0A      | Play  | Client   | 0: add           | Color      | VarInt Enum   | Color ID (see below).                                                                                                                     |
	 * | 0x0A      | Play  | Client   | 0: add           | Division   | VarInt Enum   | Type of division (see below).                                                                                                             |
	 * | 0x0A      | Play  | Client   | 0: add           | Flags      | Unsigned Byte | Bit mask. 0x1: should darken sky, 0x2: is dragon bar (used to play end music), 0x04: create fog (previously was also controlled by 0x02). |
	 * | 0x0A      | Play  | Client   | 1: remove        | no fields  | no fields     | Removes this boss bar.                                                                                                                    |
	 * | 0x0A      | Play  | Client   | 2: update health | Health     | Float         | as above                                                                                                                                  |
	 * | 0x0A      | Play  | Client   | 3: update title  | Title      | Chat          |                                                                                                                                           |
	 * | 0x0A      | Play  | Client   | 4: update style  | Color      | VarInt Enum   | Color ID (see below).                                                                                                                     |
	 * | 0x0A      | Play  | Client   | 4: update style  | Dividers   | VarInt Enum   | as above                                                                                                                                  |
	 * | 0x0A      | Play  | Client   | 5: update flags  | Flags      | Unsigned Byte | as above                                                                                                                                  |
	 * 
	 */
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0xd
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0xd
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0xd
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0xd
type PlayBossBar_758_2 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name       | Field Name | Field Type    | Notes                                                                                                                                     |
	 * |-----------|-------|----------|------------------|------------|---------------|-------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x0D      | Play  | Client   | UUID             | UUID       | UUID          | Unique ID for this bar.                                                                                                                   |
	 * | 0x0D      | Play  | Client   | Action           | Action     | VarInt Enum   | Determines the layout of the remaining packet.                                                                                            |
	 * | 0x0D      | Play  | Client   | Action           | Field Name |               |                                                                                                                                           |
	 * | 0x0D      | Play  | Client   | 0: add           | Title      | Chat          |                                                                                                                                           |
	 * | 0x0D      | Play  | Client   | 0: add           | Health     | Float         | From 0 to 1. Values greater than 1 do not crash a Notchian client, and start rendering part of a second health bar at around 1.5.         |
	 * | 0x0D      | Play  | Client   | 0: add           | Color      | VarInt Enum   | Color ID (see below).                                                                                                                     |
	 * | 0x0D      | Play  | Client   | 0: add           | Division   | VarInt Enum   | Type of division (see below).                                                                                                             |
	 * | 0x0D      | Play  | Client   | 0: add           | Flags      | Unsigned Byte | Bit mask. 0x1: should darken sky, 0x2: is dragon bar (used to play end music), 0x04: create fog (previously was also controlled by 0x02). |
	 * | 0x0D      | Play  | Client   | 1: remove        | no fields  | no fields     | Removes this boss bar.                                                                                                                    |
	 * | 0x0D      | Play  | Client   | 2: update health | Health     | Float         | as above                                                                                                                                  |
	 * | 0x0D      | Play  | Client   | 3: update title  | Title      | Chat          |                                                                                                                                           |
	 * | 0x0D      | Play  | Client   | 4: update style  | Color      | VarInt Enum   | Color ID (see below).                                                                                                                     |
	 * | 0x0D      | Play  | Client   | 4: update style  | Dividers   | VarInt Enum   | as above                                                                                                                                  |
	 * | 0x0D      | Play  | Client   | 5: update flags  | Flags      | Unsigned Byte | as above                                                                                                                                  |
	 * 
	 */
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0xc
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0xc
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0xc
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0xc
type PlayBossBar_754_3 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name       | Field Name | Field Type    | Notes                                                                                                                             |
	 * |-----------|-------|----------|------------------|------------|---------------|-----------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x0C      | Play  | Client   | UUID             | UUID       | UUID          | Unique ID for this bar                                                                                                            |
	 * | 0x0C      | Play  | Client   | Action           | Action     | VarInt Enum   | Determines the layout of the remaining packet                                                                                     |
	 * | 0x0C      | Play  | Client   | Action           | Field Name |               |                                                                                                                                   |
	 * | 0x0C      | Play  | Client   | 0: add           | Title      | Chat          |                                                                                                                                   |
	 * | 0x0C      | Play  | Client   | 0: add           | Health     | Float         | From 0 to 1. Values greater than 1 do not crash a Notchian client, and start rendering part of a second health bar at around 1.5. |
	 * | 0x0C      | Play  | Client   | 0: add           | Color      | VarInt Enum   | Color ID (see below)                                                                                                              |
	 * | 0x0C      | Play  | Client   | 0: add           | Division   | VarInt Enum   | Type of division (see below)                                                                                                      |
	 * | 0x0C      | Play  | Client   | 0: add           | Flags      | Unsigned Byte | Bit mask. 0x1: should darken sky, 0x2: is dragon bar (used to play end music)                                                     |
	 * | 0x0C      | Play  | Client   | 1: remove        | no fields  | no fields     | Removes this boss bar                                                                                                             |
	 * | 0x0C      | Play  | Client   | 2: update health | Health     | Float         | as above                                                                                                                          |
	 * | 0x0C      | Play  | Client   | 3: update title  | Title      | Chat          |                                                                                                                                   |
	 * | 0x0C      | Play  | Client   | 4: update style  | Color      | VarInt Enum   | Color ID (see below)                                                                                                              |
	 * | 0x0C      | Play  | Client   | 4: update style  | Dividers   | VarInt Enum   | as above                                                                                                                          |
	 * | 0x0C      | Play  | Client   | 5: update flags  | Flags      | Unsigned Byte | as above                                                                                                                          |
	 * 
	 */
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0xc
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0xc
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0xc
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0xc
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0xc
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0xc
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0xc
type PlayBossBar_404_5 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name       | Field Name | Field Type    | Notes                                                                                                                                    |
	 * |-----------|-------|----------|------------------|------------|---------------|------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x0C      | Play  | Client   | UUID             | UUID       | UUID          | Unique ID for this bar                                                                                                                   |
	 * | 0x0C      | Play  | Client   | Action           | Action     | VarInt Enum   | Determines the layout of the remaining packet                                                                                            |
	 * | 0x0C      | Play  | Client   | Action           | Field Name |               |                                                                                                                                          |
	 * | 0x0C      | Play  | Client   | 0: add           | Title      | Chat          |                                                                                                                                          |
	 * | 0x0C      | Play  | Client   | 0: add           | Health     | Float         | From 0 to 1. Values greater than 1 do not crash a Notchian client, and start rendering part of a second health bar at around 1.5.        |
	 * | 0x0C      | Play  | Client   | 0: add           | Color      | VarInt Enum   | Color ID (see below)                                                                                                                     |
	 * | 0x0C      | Play  | Client   | 0: add           | Division   | VarInt Enum   | Type of division (see below)                                                                                                             |
	 * | 0x0C      | Play  | Client   | 0: add           | Flags      | Unsigned Byte | Bit mask. 0x1: should darken sky, 0x2: is dragon bar (used to play end music), 0x04: create fog (previously was also controlled by 0x02) |
	 * | 0x0C      | Play  | Client   | 1: remove        | no fields  | no fields     | Removes this boss bar                                                                                                                    |
	 * | 0x0C      | Play  | Client   | 2: update health | Health     | Float         | as above                                                                                                                                 |
	 * | 0x0C      | Play  | Client   | 3: update title  | Title      | Chat          |                                                                                                                                          |
	 * | 0x0C      | Play  | Client   | 4: update style  | Color      | VarInt Enum   | Color ID (see below)                                                                                                                     |
	 * | 0x0C      | Play  | Client   | 4: update style  | Dividers   | VarInt Enum   | as above                                                                                                                                 |
	 * | 0x0C      | Play  | Client   | 5: update flags  | Flags      | Unsigned Byte | as above                                                                                                                                 |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x0
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x0
type PlayBundleDelimiter_763_0 struct {
}

var _ Packet = (*PlayBundleDelimiter_763_0)(nil)

func (p PlayBundleDelimiter_763_0)Encode(b *PacketBuilder){
}

func (p *PlayBundleDelimiter_763_0)DecodeFrom(r *PacketReader)(error){ return nil }

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x47
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x47
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x47
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x47
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x3e
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x3e
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x3f
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x3e
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x3c
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x39
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x39
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x38
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x36
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x36
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x36
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x36
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x43
type PlayCamera_758_0 struct {
	/* ID of the entity to set the client's camera to */
	CameraID VarInt // VarInt
}

var _ Packet = (*PlayCamera_758_0)(nil)

func (p PlayCamera_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.CameraID)
}

func (p *PlayCamera_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.CameraID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0xc
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0xc
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0xb
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0xb
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0xb
type PlayChangeDifficulty_763_0 struct {
	/* 0: peaceful, 1: easy, 2: normal, 3: hard. */
	Difficulty UByte // Unsigned Byte
	DifficultyLocked Bool // Boolean
}

var _ Packet = (*PlayChangeDifficulty_763_0)(nil)

func (p PlayChangeDifficulty_763_0)Encode(b *PacketBuilder){
	b.UByte(p.Difficulty)
	b.Bool(p.DifficultyLocked)
}

func (p *PlayChangeDifficulty_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Difficulty, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.DifficultyLocked, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x2
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x2
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x2
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x2
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x2
type PlayChangeDifficultyServer_763_0 struct {
	/* 0: peaceful, 1: easy, 2: normal, 3: hard . */
	NewDifficulty Byte // Byte
}

var _ Packet = (*PlayChangeDifficultyServer_763_0)(nil)

func (p PlayChangeDifficultyServer_763_0)Encode(b *PacketBuilder){
	b.Byte(p.NewDifficulty)
}

func (p *PlayChangeDifficultyServer_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.NewDifficulty, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x1e
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x1e
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x1e
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x1e
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x1d
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x1d
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x1f
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x1e
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x20
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x1e
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x1e
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x1e
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x1e
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x1e
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x1e
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x1e
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x2b
type PlayChangeGameState_758_0 struct {
	/* See below */
	Reason UByte // Unsigned Byte
	/* Depends on Reason */
	Value Float // Float
}

var _ Packet = (*PlayChangeGameState_758_0)(nil)

func (p PlayChangeGameState_758_0)Encode(b *PacketBuilder){
	b.UByte(p.Reason)
	b.Float(p.Value)
}

func (p *PlayChangeGameState_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Reason, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Value, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x21
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x21
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x21
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x21
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x20
type PlayChangeRecipeBookSettings_763_0 struct {
	/* 0: crafting, 1: furnace, 2: blast furnace, 3: smoker. */
	BookID VarInt // VarInt Enum
	BookOpen Bool // Boolean
	FilterActive Bool // Boolean
}

var _ Packet = (*PlayChangeRecipeBookSettings_763_0)(nil)

func (p PlayChangeRecipeBookSettings_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.BookID)
	b.Bool(p.BookOpen)
	b.Bool(p.FilterActive)
}

func (p *PlayChangeRecipeBookSettings_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.BookID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.BookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.FilterActive, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x4
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x4
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x4
type PlayChatCommand_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name                   | Field Name    | Field Type   | Field Type   | Notes                                                               |
	 * |-----------|-------|----------|------------------------------|---------------|--------------|--------------|---------------------------------------------------------------------|
	 * | 0x04      | Play  | Server   | Command                      | Command       | String (256) | String (256) | The command typed by the client.                                    |
	 * | 0x04      | Play  | Server   | Timestamp                    | Timestamp     | Long         | Long         | The timestamp that the command was executed.                        |
	 * | 0x04      | Play  | Server   | Salt                         | Salt          | Long         | Long         | The salt for the following argument signatures.                     |
	 * | 0x04      | Play  | Server   | Array length                 | Array length  | VarInt       | VarInt       | Number of entries in the following array                            |
	 * | 0x04      | Play  | Server   | Array of argument signatures | Argument name | Array        | String       | The name of the argument that is signed by the following signature. |
	 * | 0x04      | Play  | Server   | Array of argument signatures | Signature     | Array        | Byte Array   | The signature that verifies the argument. Always 256 bytes.         |
	 * | 0x04      | Play  | Server   | Message Count                | Message Count | VarInt       | VarInt       |                                                                     |
	 * | 0x04      | Play  | Server   | Acknowledged                 | Acknowledged  | BitSet (20)  | BitSet (20)  |                                                                     |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x5
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x5
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x5
type PlayChatMessage_763_0 struct {
	Message String // String (256 chars)
	Timestamp Long // Long
	/* The salt used to verify the signature hash. */
	Salt Long // Long
	/* Whether the next field is present. */
	HasSignature Bool // Boolean
	/* The signature used to verify the chat message's authentication. When present, always 256 bytes. */
	Signature Optional[ByteArray] // Optional Byte Array
	MessageCount VarInt // VarInt
	Acknowledged BitSet // BitSet (20)
}

var _ Packet = (*PlayChatMessage_763_0)(nil)

func (p PlayChatMessage_763_0)Encode(b *PacketBuilder){
	b.String(p.Message)
	b.Long(p.Timestamp)
	b.Long(p.Salt)
	p.HasSignature = p.Signature.Ok
	b.Bool(p.HasSignature)
	if p.Signature.Ok {
		assert(len(p.Signature.V) == 256, "len(PlayChatMessage.Signature) != 256")
		b.ByteArray(p.Signature.V)
	}
	b.VarInt(p.MessageCount)
	p.Acknowledged.Encode(b)
}

func (p *PlayChatMessage_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Message, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Timestamp, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.Salt, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.HasSignature, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.Signature.Ok = p.HasSignature; p.Signature.Ok {
		p.Signature.V = make(ByteArray, 256)
		r.ByteArray(p.Signature.V)
	}
	if p.MessageCount, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = p.Acknowledged.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0xf
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0xf
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0xf
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0xf
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0xe
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0xe
type PlayChatMessage_758_3 struct {
	/* Limited to 32767 bytes */
	JSONData Object // Chat
	/* 0: chat (chat box), 1: system message (chat box), 2: game info (above hotbar). */
	Position Byte // Byte
	/* Used by the Notchian client for the disableChat launch option. Setting both longs to 0 will always display the message regardless of the setting. */
	Sender UUID // UUID
}

var _ Packet = (*PlayChatMessage_758_3)(nil)

func (p PlayChatMessage_758_3)Encode(b *PacketBuilder){
	b.JSON(p.JSONData)
	b.Byte(p.Position)
	b.UUID(p.Sender)
}

func (p *PlayChatMessage_758_3)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.JSONData); err != nil {
		return err
	}
	if p.Position, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Sender, ok = r.UUID(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0xf
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0xe
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0xe
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0xf
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0xf
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0xf
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0xf
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0xf
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0xf
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0xf
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x2
type PlayChatMessage_578_4 struct {
	/* Limited to 32767 bytes */
	JSONData Object // Chat
	/* 0: chat (chat box), 1: system message (chat box), 2: game info (above hotbar). */
	Position Byte // Byte
}

var _ Packet = (*PlayChatMessage_578_4)(nil)

func (p PlayChatMessage_578_4)Encode(b *PacketBuilder){
	b.JSON(p.JSONData)
	b.Byte(p.Position)
}

func (p *PlayChatMessage_578_4)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.JSONData); err != nil {
		return err
	}
	if p.Position, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x3
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x3
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x3
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x3
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x3
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x3
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x3
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x3
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x2
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x2
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x2
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x3
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x2
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x2
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x2
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x2
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x1
type PlayChatMessageServer_758_0 struct {
	/* The client sends the raw input, not a Chat component */
	Message String // String (256)
}

var _ Packet = (*PlayChatMessageServer_758_0)(nil)

func (p PlayChatMessageServer_758_0)Encode(b *PacketBuilder){
	b.String(p.Message)
}

func (p *PlayChatMessageServer_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Message, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0xc
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0xc
type PlayChatPreview_760_0 struct {
	QueryID Int // Integer
	ComponentIsPresent Bool // Boolean
	MessageToPreview Object // Component
}

var _ Packet = (*PlayChatPreview_760_0)(nil)

func (p PlayChatPreview_760_0)Encode(b *PacketBuilder){
	b.Int(p.QueryID)
	b.Bool(p.ComponentIsPresent)
	b.JSON(p.MessageToPreview)
}

func (p *PlayChatPreview_760_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.QueryID, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.ComponentIsPresent, ok = r.Bool(); !ok {
		return io.EOF
	}
	if err = r.JSON(&p.MessageToPreview); err != nil {
		return err
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x6
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x5
type PlayChatPreviewServer_760_0 struct {
	Query Int // Integer
	Message String // String (256)
}

var _ Packet = (*PlayChatPreviewServer_760_0)(nil)

func (p PlayChatPreviewServer_760_0)Encode(b *PacketBuilder){
	b.Int(p.Query)
	b.String(p.Message)
}

func (p *PlayChatPreviewServer_760_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Query, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.Message, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x16
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x16
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x14
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x15
type PlayChatSuggestions_763_0 struct {
	/* 0: Add, 1: Remove, 2: Set */
	Action VarInt // VarInt Enum
	/* Number of elements in the following array. */
	Count VarInt // VarInt
	Entries []String // Array of String
}

var _ Packet = (*PlayChatSuggestions_763_0)(nil)

func (p PlayChatSuggestions_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.Action)
	p.Count = (VarInt)(len(p.Entries))
	b.VarInt(p.Count)
	for _, v := range p.Entries {
		b.String(v)
	}
}

func (p *PlayChatSuggestions_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Action, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Count, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Entries = make([]String, p.Count)
	for i, _ := range p.Entries {
		if p.Entries[i], ok = r.String(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0xd
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0xd
type PlayChunkBiomes_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name       | Field Name       | Field Type | Field Type | Notes                                                                |
	 * |-----------|-------|----------|------------------|------------------|------------|------------|----------------------------------------------------------------------|
	 * | 0x0D      | Play  | Client   |                  |                  |            |            |                                                                      |
	 * | 0x0D      | Play  | Client   | Number of chunks | Number of chunks | VarInt     | VarInt     | Number of elements in the following array                            |
	 * | 0x0D      | Play  | Client   | Chunk biome data | Chunk X          | Array      | Int        | Chunk coordinate (block coordinate divided by 16, rounded down)      |
	 * | 0x0D      | Play  | Client   | Chunk biome data | Chunk Z          | Array      | Int        | Chunk coordinate (block coordinate divided by 16, rounded down)      |
	 * | 0x0D      | Play  | Client   | Chunk biome data | Size             | Array      | VarInt     | Size of Data in bytes                                                |
	 * | 0x0D      | Play  | Client   | Chunk biome data | Data             | Array      | Byte array | Chunk data structure, with sections containing only the Biomes field |
	 * 
	 */
}

// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x22
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x22
type PlayChunkData_756_0 struct {
	/* Chunk coordinate (block coordinate divided by 16, rounded down) */
	ChunkX Int // Int
	/* Chunk coordinate (block coordinate divided by 16, rounded down) */
	ChunkZ Int // Int
	/* Length of the following array */
	BitMaskLength VarInt // VarInt
	/* BitSet with bits (world height in blocks / 16) set to 1 for every 16×16×16 chunk section whose data is included in Data. The least significant bit represents the chunk section at the bottom of the chunk column (from the lowest y to 15 blocks above). */
	PrimaryBitMask []Long // Array of Long
	/* Compound containing one long array named MOTION_BLOCKING, which is a heightmap for the highest solid block at each position in the chunk (as a compacted long array with 256 entries at 9 bits per entry totaling 36 longs). The Notchian server also adds a WORLD_SURFACE long array, the purpose of which is unknown, but it's not required for the chunk to be accepted. */
	Heightmaps nbt.NBT // NBT
	/* Size of the following array; should always be 1024. */
	BiomesLength VarInt // VarInt
	/* 1024 biome IDs, ordered by x then z then y, in 4×4×4 blocks.  See Chunk Format § Biomes. */
	Biomes []VarInt // Array of VarInt
	/* Size of Data in bytes */
	Size VarInt // VarInt
	/* See data structure in Chunk Format */
	Data ByteArray // Byte array
	/* Number of elements in the following array */
	NumberOfBlockEntities VarInt // VarInt
	/* All block entities in the chunk.  Use the x, y, and z tags in the NBT to determine their positions. */
	BlockEntities []nbt.NBT // Array of NBT Tag
}

var _ Packet = (*PlayChunkData_756_0)(nil)

func (p PlayChunkData_756_0)Encode(b *PacketBuilder){
	b.Int(p.ChunkX)
	b.Int(p.ChunkZ)
	p.BitMaskLength = (VarInt)(len(p.PrimaryBitMask))
	b.VarInt(p.BitMaskLength)
	for _, v := range p.PrimaryBitMask {
		b.Long(v)
	}
	nbt.WriteNBT(b, p.Heightmaps)
	p.BiomesLength = (VarInt)(len(p.Biomes))
	b.VarInt(p.BiomesLength)
	for _, v := range p.Biomes {
		b.VarInt(v)
	}
	p.Size = (VarInt)(len(p.Data))
	b.VarInt(p.Size)
	b.ByteArray(p.Data)
	p.NumberOfBlockEntities = (VarInt)(len(p.BlockEntities))
	b.VarInt(p.NumberOfBlockEntities)
	for _, v := range p.BlockEntities {
		nbt.WriteNBT(b, v)
	}
}

func (p *PlayChunkData_756_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ChunkX, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.ChunkZ, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.BitMaskLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.PrimaryBitMask = make([]Long, p.BitMaskLength)
	for i, _ := range p.PrimaryBitMask {
		if p.PrimaryBitMask[i], ok = r.Long(); !ok {
			return io.EOF
		}
	}
	if p.Heightmaps, err = nbt.ReadNBT(r); err != nil {
		return err
	}
	if p.BiomesLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Biomes = make([]VarInt, p.BiomesLength)
	for i, _ := range p.Biomes {
		if p.Biomes[i], ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.Size, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Data = make(ByteArray, p.Size)
	if ok = r.ByteArray(p.Data); !ok {
		return io.EOF
	}
	if p.NumberOfBlockEntities, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.BlockEntities = make([]nbt.NBT, p.NumberOfBlockEntities)
	for i, _ := range p.BlockEntities {
		if p.BlockEntities[i], err = nbt.ReadNBT(r); err != nil {
			return err
		}
	}
	return nil
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x20
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x20
type PlayChunkData_754_1 struct {
	/* Chunk coordinate (block coordinate divided by 16, rounded down) */
	ChunkX Int // Int
	/* Chunk coordinate (block coordinate divided by 16, rounded down) */
	ChunkZ Int // Int
	/* See Chunk Format */
	FullChunk Bool // Boolean
	/* Bitmask with bits set to 1 for every 16×16×16 chunk section whose data is included in Data. The least significant bit represents the chunk section at the bottom of the chunk column (from y=0 to y=15). */
	PrimaryBitMask VarInt // VarInt
	/* Compound containing one long array named MOTION_BLOCKING, which is a heightmap for the highest solid block at each position in the chunk (as a compacted long array with 256 entries at 9 bits per entry totaling 36 longs). The Notchian server also adds a WORLD_SURFACE long array, the purpose of which is unknown, but it's not required for the chunk to be accepted. */
	Heightmaps nbt.NBT // NBT
	/* Size of the following array.  Not present if full chunk is false. */
	BiomesLength Optional[VarInt] // Optional VarInt
	/* 1024 biome IDs, ordered by x then z then y, in 4×4×4 blocks.Possibly something else.  Not present if full chunk is false. */
	Biomes Optional[[]VarInt] // Optional array of VarInt
	/* Size of Data in bytes */
	Size VarInt // VarInt
	/* See data structure in Chunk Format */
	Data ByteArray // Byte array
	/* Number of elements in the following array */
	NumberOfBlockEntities VarInt // VarInt
	/* All block entities in the chunk.  Use the x, y, and z tags in the NBT to determine their positions. */
	BlockEntities []nbt.NBT // Array of NBT Tag
}

var _ Packet = (*PlayChunkData_754_1)(nil)

func (p PlayChunkData_754_1)Encode(b *PacketBuilder){
	b.Int(p.ChunkX)
	b.Int(p.ChunkZ)
	b.Bool(p.FullChunk)
	b.VarInt(p.PrimaryBitMask)
	nbt.WriteNBT(b, p.Heightmaps)
	if p.FullChunk {
		p.BiomesLength.Set((VarInt)(len(p.Biomes.Assert())))
		b.VarInt(p.BiomesLength.V)
		for _, v := range p.Biomes.V {
			b.VarInt(v)
		}
	}
	p.Size = (VarInt)(len(p.Data))
	b.VarInt(p.Size)
	b.ByteArray(p.Data)
	p.NumberOfBlockEntities = (VarInt)(len(p.BlockEntities))
	b.VarInt(p.NumberOfBlockEntities)
	for _, v := range p.BlockEntities {
		nbt.WriteNBT(b, v)
	}
}

func (p *PlayChunkData_754_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ChunkX, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.ChunkZ, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.FullChunk, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.PrimaryBitMask, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Heightmaps, err = nbt.ReadNBT(r); err != nil {
		return err
	}
	if p.BiomesLength.Ok = p.FullChunk; p.BiomesLength.Ok {
		if p.BiomesLength.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
		p.Biomes.Set(make([]VarInt, p.BiomesLength.V))
		for i, _ := range p.Biomes.V {
			if p.Biomes.V[i], ok = r.VarInt(); !ok {
				return io.EOF
			}
		}
	}
	if p.Size, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Data = make(ByteArray, p.Size)
	if ok = r.ByteArray(p.Data); !ok {
		return io.EOF
	}
	if p.NumberOfBlockEntities, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.BlockEntities = make([]nbt.NBT, p.NumberOfBlockEntities)
	for i, _ := range p.BlockEntities {
		if p.BlockEntities[i], err = nbt.ReadNBT(r); err != nil {
			return err
		}
	}
	return nil
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x20
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x20
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x20
type PlayChunkData_340_5 struct {
	/* Chunk coordinate (block coordinate divided by 16, rounded down) */
	ChunkX Int // Int
	/* Chunk coordinate (block coordinate divided by 16, rounded down) */
	ChunkZ Int // Int
	/* See Chunk Format */
	GroundUpContinuous Bool // Boolean
	/* Bitmask with bits set to 1 for every 16×16×16 chunk section whose data is included in Data. The least significant bit represents the chunk section at the bottom of the chunk column (from y=0 to y=15). */
	PrimaryBitMask VarInt // VarInt
	/* Size of Data in bytes */
	Size VarInt // VarInt
	/* See data structure in Chunk Format */
	Data ByteArray // Byte array
	/* Number of elements in the following array */
	NumberOfBlockEntities VarInt // VarInt
	/* All block entities in the chunk.  Use the x, y, and z tags in the NBT to determine their positions. */
	BlockEntities []nbt.NBT // Array of NBT Tag
}

var _ Packet = (*PlayChunkData_340_5)(nil)

func (p PlayChunkData_340_5)Encode(b *PacketBuilder){
	b.Int(p.ChunkX)
	b.Int(p.ChunkZ)
	b.Bool(p.GroundUpContinuous)
	b.VarInt(p.PrimaryBitMask)
	p.Size = (VarInt)(len(p.Data))
	b.VarInt(p.Size)
	b.ByteArray(p.Data)
	p.NumberOfBlockEntities = (VarInt)(len(p.BlockEntities))
	b.VarInt(p.NumberOfBlockEntities)
	for _, v := range p.BlockEntities {
		nbt.WriteNBT(b, v)
	}
}

func (p *PlayChunkData_340_5)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ChunkX, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.ChunkZ, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.GroundUpContinuous, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.PrimaryBitMask, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Size, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Data = make(ByteArray, p.Size)
	if ok = r.ByteArray(p.Data); !ok {
		return io.EOF
	}
	if p.NumberOfBlockEntities, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.BlockEntities = make([]nbt.NBT, p.NumberOfBlockEntities)
	for i, _ := range p.BlockEntities {
		if p.BlockEntities[i], err = nbt.ReadNBT(r); err != nil {
			return err
		}
	}
	return nil
}

// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x20
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x20
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x20
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x20
type PlayChunkData_316_6 struct {
	/* Block coordinate divided by 16, rounded down */
	ChunkX Int // Int
	/* Block coordinate divided by 16, rounded down */
	ChunkZ Int // Int
	/* This is true if the packet represents all chunk sections in this vertical chunk column, where the Primary Bit Mask specifies exactly which chunk sections are included, and which are air. */
	GroundUpContinuous Bool // Boolean
	/* Bitmask with bits set to 1 for every 16×16×16 chunk section whose data is included in Data. The least significant bit represents the chunk section at the bottom of the chunk column (from y=0 to y=15). */
	PrimaryBitMask VarInt // VarInt
	/* Size of Data in bytes, plus size of Biomes in bytes if present */
	Size VarInt // VarInt
	/* The length of the array is equal to the number of bits set in Primary Bit Mask. Chunks are sent bottom-to-top, i.e. the first chunk, if sent, extends from Y=0 to Y=15. */
	Data []*ChunkSection // Array of Chunk Section
	/* Only if Ground-Up Continuous: biome array, byte per XZ coordinate, 256 bytes total. */
	Biomes Optional[ByteArray] // Optional Byte Array
	/* Length of the following array */
	NumberOfBlockEntities VarInt // VarInt
	/* All block entities in the chunk.  Use the x, y, and z tags in the NBT to determine their positions. */
	BlockEntities []nbt.NBT // Array of NBT Tag
}

var _ Packet = (*PlayChunkData_316_6)(nil)

func (p PlayChunkData_316_6)Encode(b *PacketBuilder){
	b.Int(p.ChunkX)
	b.Int(p.ChunkZ)
	b.Bool(p.GroundUpContinuous)
	b.VarInt(p.PrimaryBitMask)
	b2 := NewPacket(b.Protocol(), 0)
	for _, v := range p.Data {
		v.Encode(b2)
	}
	if p.GroundUpContinuous {
		assert(len(p.Biomes.Assert()) == 256, "len(PlayChunkData.Biomes) != 256")
		b2.ByteArray(p.Biomes.V)
	}
	p.Size = (VarInt)(b2.Len())
	b.VarInt(p.Size)
	b.ByteArray(b2.Data())
	p.NumberOfBlockEntities = (VarInt)(len(p.BlockEntities))
	b.VarInt(p.NumberOfBlockEntities)
	for _, v := range p.BlockEntities {
		nbt.WriteNBT(b, v)
	}
}

func (p *PlayChunkData_316_6)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ChunkX, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.ChunkZ, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.GroundUpContinuous, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.PrimaryBitMask, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Size, ok = r.VarInt(); !ok {
		return io.EOF
	}
	buf := make([]byte, p.Size)
	if ok = r.ByteArray(buf); !ok {
		return io.EOF
	}
	r2 := ReadPacketFromBytes(r.Protocol(), buf)
	p.Data = make([]*ChunkSection, p.Size)
	for i, _ := range p.Data {
		p.Data[i] = new(ChunkSection)
		if err = p.Data[i].DecodeFrom(r2); err != nil {
			return err
		}
	}
	if p.Biomes.Ok = p.GroundUpContinuous; p.Biomes.Ok {
		p.Biomes.V = make(ByteArray, 256)
		if ok = r2.ByteArray(p.Biomes.V); !ok {
			return io.EOF
		}
	}
	if p.NumberOfBlockEntities, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.BlockEntities = make([]nbt.NBT, p.NumberOfBlockEntities)
	for i, _ := range p.BlockEntities {
		if p.BlockEntities[i], err = nbt.ReadNBT(r); err != nil {
			return err
		}
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x22
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x22
type PlayChunkDataAndUpdateLight_758_5 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name               | Field Name               | Field Type | Field Type          | Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
	 * |-----------|-------|----------|--------------------------|--------------------------|------------|---------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x22      | Play  | Client   | Chunk X                  | Chunk X                  | Int        | Int                 | Chunk coordinate (block coordinate divided by 16, rounded down)                                                                                                                                                                                                                                                                                                                                                                                                 |
	 * | 0x22      | Play  | Client   | Chunk Z                  | Chunk Z                  | Int        | Int                 | Chunk coordinate (block coordinate divided by 16, rounded down)                                                                                                                                                                                                                                                                                                                                                                                                 |
	 * | 0x22      | Play  | Client   | Heightmaps               | Heightmaps               | NBT        | NBT                 | Compound containing one long array named MOTION_BLOCKING, which is a heightmap for the highest solid block at each position in the chunk (as a compacted long array with 256 entries, with the number of bits per entry varying depending on the world's height, defined by the formula ceil(log2(height + 1))). The Notchian server also adds a WORLD_SURFACE long array, the purpose of which is unknown, but it's not required for the chunk to be accepted. |
	 * | 0x22      | Play  | Client   | Size                     | Size                     | VarInt     | VarInt              | Size of Data in bytes                                                                                                                                                                                                                                                                                                                                                                                                                                           |
	 * | 0x22      | Play  | Client   | Data                     | Data                     | Byte array | Byte array          | See data structure in Chunk Format                                                                                                                                                                                                                                                                                                                                                                                                                              |
	 * | 0x22      | Play  | Client   | Number of block entities | Number of block entities | VarInt     | VarInt              | Number of elements in the following array                                                                                                                                                                                                                                                                                                                                                                                                                       |
	 * | 0x22      | Play  | Client   | Block Entity             | Packed XZ                | Array      | Byte                | The packed section coordinates, calculated from ((blockX & 15) << 4) | (blockZ & 15)                                                                                                                                                                                                                                                                                                                                                                            |
	 * | 0x22      | Play  | Client   | Block Entity             | Y                        | Array      | Short               | The height relative to the world                                                                                                                                                                                                                                                                                                                                                                                                                                |
	 * | 0x22      | Play  | Client   | Block Entity             | Type                     | Array      | VarInt              | The type of block entity                                                                                                                                                                                                                                                                                                                                                                                                                                        |
	 * | 0x22      | Play  | Client   | Block Entity             | Data                     | Array      | NBT                 | The block entity's data, without the X, Y, and Z values                                                                                                                                                                                                                                                                                                                                                                                                         |
	 * | 0x22      | Play  | Client   | Trust Edges              | Trust Edges              | Boolean    | Boolean             | If edges should be trusted for light updates.                                                                                                                                                                                                                                                                                                                                                                                                                   |
	 * | 0x22      | Play  | Client   | Sky Light Mask           | Sky Light Mask           | BitSet     | BitSet              | BitSet containing bits for each section in the world + 2.  Each set bit indicates that the corresponding 16×16×16 chunk section has data in the Sky Light array below.  The least significant bit is for blocks 16 blocks to 1 block below the min world height (one section below the world), while the most significant bit covers blocks 1 to 16 blocks above the max world height (one section above the world).                                          |
	 * | 0x22      | Play  | Client   | Block Light Mask         | Block Light Mask         | BitSet     | BitSet              | BitSet containing bits for each section in the world + 2.  Each set bit indicates that the corresponding 16×16×16 chunk section has data in the Block Light array below.  The order of bits is the same as in Sky Light Mask.                                                                                                                                                                                                                                 |
	 * | 0x22      | Play  | Client   | Empty Sky Light Mask     | Empty Sky Light Mask     | BitSet     | BitSet              | BitSet containing bits for each section in the world + 2.  Each set bit indicates that the corresponding 16×16×16 chunk section has all zeros for its Sky Light data.  The order of bits is the same as in Sky Light Mask.                                                                                                                                                                                                                                    |
	 * | 0x22      | Play  | Client   | Empty Block Light Mask   | Empty Block Light Mask   | BitSet     | BitSet              | BitSet containing bits for each section in the world + 2.  Each set bit indicates that the corresponding 16×16×16 chunk section has all zeros for its Block Light data.  The order of bits is the same as in Sky Light Mask.                                                                                                                                                                                                                                  |
	 * | 0x22      | Play  | Client   | Sky Light array count    | Sky Light array count    | VarInt     | VarInt              | Number of entries in the following array; should match the number of bits set in Sky Light Mask                                                                                                                                                                                                                                                                                                                                                                 |
	 * | 0x22      | Play  | Client   | Sky Light arrays         | Length                   | Array      | VarInt              | Length of the following array in bytes (always 2048)                                                                                                                                                                                                                                                                                                                                                                                                            |
	 * | 0x22      | Play  | Client   | Sky Light arrays         | Sky Light array          | Array      | Array of 2048 bytes | There is 1 array for each bit set to true in the sky light mask, starting with the lowest value.  Half a byte per light value. Indexed ((y<<8) | (z<<4) | x) / 2  If there's a remainder, masked 0xF0 else 0x0F.                                                                                                                                                                                                                                                |
	 * | 0x22      | Play  | Client   | Block Light array count  | Block Light array count  | VarInt     | VarInt              | Number of entries in the following array; should match the number of bits set in Block Light Mask                                                                                                                                                                                                                                                                                                                                                               |
	 * | 0x22      | Play  | Client   | Block Light arrays       | Length                   | Array      | VarInt              | Length of the following array in bytes (always 2048)                                                                                                                                                                                                                                                                                                                                                                                                            |
	 * | 0x22      | Play  | Client   | Block Light arrays       | Block Light array        | Array      | Array of 2048 bytes | There is 1 array for each bit set to true in the block light mask, starting with the lowest value.  Half a byte per light value. Indexed ((y<<8) | (z<<4) | x) / 2  If there's a remainder, masked 0xF0 else 0x0F.                                                                                                                                                                                                                                              |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0xe
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0xe
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0xc
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0xd
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0xd
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x10
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x10
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x10
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x10
type PlayClearTitles_763_0 struct {
	Reset Bool // Boolean
}

var _ Packet = (*PlayClearTitles_763_0)(nil)

func (p PlayClearTitles_763_0)Encode(b *PacketBuilder){
	b.Bool(p.Reset)
}

func (p *PlayClearTitles_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Reset, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0xb
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0xb
type PlayClickContainer_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name          | Field Type    | Field Type    | Notes                                                                                                    |
	 * |-----------|-------|----------|---------------------|---------------------|---------------|---------------|----------------------------------------------------------------------------------------------------------|
	 * | 0x0B      | Play  | Server   | Window ID           | Window ID           | Unsigned Byte | Unsigned Byte | The ID of the window which was clicked. 0 for player inventory.                                          |
	 * | 0x0B      | Play  | Server   | State ID            | State ID            | VarInt        | VarInt        | The last recieved State ID from either a Set Container Slot or a Set Container Content packet            |
	 * | 0x0B      | Play  | Server   | Slot                | Slot                | Short         | Short         | The clicked slot number, see below.                                                                      |
	 * | 0x0B      | Play  | Server   | Button              | Button              | Byte          | Byte          | The button used in the click, see below.                                                                 |
	 * | 0x0B      | Play  | Server   | Mode                | Mode                | VarInt Enum   | VarInt Enum   | Inventory operation mode, see below.                                                                     |
	 * | 0x0B      | Play  | Server   | Length of the array | Length of the array | VarInt        | VarInt        |                                                                                                          |
	 * | 0x0B      | Play  | Server   | Array of slots      | Slot number         | Array         | Short         |                                                                                                          |
	 * | 0x0B      | Play  | Server   | Array of slots      | Slot data           | Array         | Slot          | New data for this slot                                                                                   |
	 * | 0x0B      | Play  | Server   | Carried item        | Carried item        | Slot          | Slot          | Item carried by the cursor. Has to be empty (item ID = -1) for drop mode, otherwise nothing will happen. |
	 * 
	 */
}

// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0xa
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0xa
type PlayClickContainer_761_1 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name          | Field Type    | Field Type    | Notes                                                                                                    |
	 * |-----------|-------|----------|---------------------|---------------------|---------------|---------------|----------------------------------------------------------------------------------------------------------|
	 * | 0x0A      | Play  | Server   | Window ID           | Window ID           | Unsigned Byte | Unsigned Byte | The ID of the window which was clicked. 0 for player inventory.                                          |
	 * | 0x0A      | Play  | Server   | State ID            | State ID            | VarInt        | VarInt        | The last recieved State ID from either a Set Container Slot or a Set Container Content packet            |
	 * | 0x0A      | Play  | Server   | Slot                | Slot                | Short         | Short         | The clicked slot number, see below.                                                                      |
	 * | 0x0A      | Play  | Server   | Button              | Button              | Byte          | Byte          | The button used in the click, see below.                                                                 |
	 * | 0x0A      | Play  | Server   | Mode                | Mode                | VarInt Enum   | VarInt Enum   | Inventory operation mode, see below.                                                                     |
	 * | 0x0A      | Play  | Server   | Length of the array | Length of the array | VarInt        | VarInt        |                                                                                                          |
	 * | 0x0A      | Play  | Server   | Array of slots      | Slot number         | Array         | Short         |                                                                                                          |
	 * | 0x0A      | Play  | Server   | Array of slots      | Slot data           | Array         | Slot          | New data for this slot                                                                                   |
	 * | 0x0A      | Play  | Server   | Carried item        | Carried item        | Slot          | Slot          | Item carried by the cursor. Has to be empty (item ID = -1) for drop mode, otherwise nothing will happen. |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0xa
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0xa
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x9
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0xa
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x9
type PlayClickContainerButton_763_0 struct {
	/* The ID of the window sent by Open Screen. */
	WindowID Byte // Byte
	/* Meaning depends on window type; see below. */
	ButtonID Byte // Byte
}

var _ Packet = (*PlayClickContainerButton_763_0)(nil)

func (p PlayClickContainerButton_763_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.Byte(p.ButtonID)
}

func (p *PlayClickContainerButton_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ButtonID, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x9
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x9
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x9
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x9
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x8
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x7
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x7
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x8
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x7
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x7
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x7
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x7
type PlayClickWindow_754_4 struct {
	/* The ID of the window which was clicked. 0 for player inventory. */
	WindowID UByte // Unsigned Byte
	/* The clicked slot number, see below */
	Slot Short // Short
	/* The button used in the click, see below */
	Button Byte // Byte
	/* A unique number for the action, implemented by Notchian as a counter, starting at 1 (different counter for every window ID). Used by the server to send back a Confirm Transaction (clientbound). */
	ActionNumber Short // Short
	/* Inventory operation mode, see below */
	Mode VarInt // VarInt Enum
	/* The clicked slot. Has to be empty (item ID = -1) for drop mode. */
	ClickedItem *data.Slot // Slot
}

var _ Packet = (*PlayClickWindow_754_4)(nil)

func (p PlayClickWindow_754_4)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
	b.Short(p.Slot)
	b.Byte(p.Button)
	b.Short(p.ActionNumber)
	b.VarInt(p.Mode)
	p.ClickedItem.Encode(b)
}

func (p *PlayClickWindow_754_4)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Slot, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.Button, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ActionNumber, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.Mode, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.ClickedItem = new(data.Slot)
	if err = p.ClickedItem.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x7
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x7
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x7
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x7
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x8
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x8
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x8
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x8
type PlayClickWindowButton_758_0 struct {
	/* The ID of the window sent by Open Window */
	WindowID Byte // Byte
	/* Meaning depends on window type; see below */
	ButtonID Byte // Byte
}

var _ Packet = (*PlayClickWindowButton_758_0)(nil)

func (p PlayClickWindowButton_758_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.Byte(p.ButtonID)
}

func (p *PlayClickWindowButton_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ButtonID, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x7
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x7
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x6
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x7
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x6
type PlayClientCommand_763_0 struct {
	/* See below */
	ActionID VarInt // VarInt Enum
}

var _ Packet = (*PlayClientCommand_763_0)(nil)

func (p PlayClientCommand_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.ActionID)
}

func (p *PlayClientCommand_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ActionID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x8
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x8
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x7
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x8
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x7
type PlayClientInformation_763_0 struct {
	/* e.g. en_GB. */
	Locale String // String (16)
	/* Client-side render distance, in chunks. */
	ViewDistance Byte // Byte
	/* 0: enabled, 1: commands only, 2: hidden.  See processing chat for more information. */
	ChatMode VarInt // VarInt Enum
	/* “Colors” multiplayer setting. Can the chat be colored? */
	ChatColors Bool // Boolean
	/* Bit mask, see below. */
	DisplayedSkinParts UByte // Unsigned Byte
	/* 0: Left, 1: Right. */
	MainHand VarInt // VarInt Enum
	/* Enables filtering of text on signs and written book titles. Currently always false (i.e. the filtering is disabled) */
	EnableTextFiltering Bool // Boolean
	/* Servers usually list online players, this option should let you not show up in that list. */
	AllowServerListings Bool // Boolean
}

var _ Packet = (*PlayClientInformation_763_0)(nil)

func (p PlayClientInformation_763_0)Encode(b *PacketBuilder){
	b.String(p.Locale)
	b.Byte(p.ViewDistance)
	b.VarInt(p.ChatMode)
	b.Bool(p.ChatColors)
	b.UByte(p.DisplayedSkinParts)
	b.VarInt(p.MainHand)
	b.Bool(p.EnableTextFiltering)
	b.Bool(p.AllowServerListings)
}

func (p *PlayClientInformation_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Locale, ok = r.String(); !ok {
		return io.EOF
	}
	if p.ViewDistance, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ChatMode, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ChatColors, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.DisplayedSkinParts, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.MainHand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EnableTextFiltering, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.AllowServerListings, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x5
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x5
type PlayClientSettings_758_0 struct {
	/* e.g. en_GB. */
	Locale String // String (16)
	/* Client-side render distance, in chunks. */
	ViewDistance Byte // Byte
	/* 0: enabled, 1: commands only, 2: hidden.  See processing chat for more information. */
	ChatMode VarInt // VarInt Enum
	/* “Colors” multiplayer setting. Can the chat be colored? */
	ChatColors Bool // Boolean
	/* Bit mask, see below. */
	DisplayedSkinParts UByte // Unsigned Byte
	/* 0: Left, 1: Right. */
	MainHand VarInt // VarInt Enum
	/* Enables filtering of text on signs and written book titles. Currently always false (i.e. the filtering is disabled) */
	EnableTextFiltering Bool // Boolean
	/* Servers usually list online players, this option should let you not show up in that list. */
	AllowServerListings Bool // Boolean
}

var _ Packet = (*PlayClientSettings_758_0)(nil)

func (p PlayClientSettings_758_0)Encode(b *PacketBuilder){
	b.String(p.Locale)
	b.Byte(p.ViewDistance)
	b.VarInt(p.ChatMode)
	b.Bool(p.ChatColors)
	b.UByte(p.DisplayedSkinParts)
	b.VarInt(p.MainHand)
	b.Bool(p.EnableTextFiltering)
	b.Bool(p.AllowServerListings)
}

func (p *PlayClientSettings_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Locale, ok = r.String(); !ok {
		return io.EOF
	}
	if p.ViewDistance, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ChatMode, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ChatColors, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.DisplayedSkinParts, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.MainHand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EnableTextFiltering, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.AllowServerListings, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x5
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x5
type PlayClientSettings_756_1 struct {
	/* e.g. en_GB. */
	Locale String // String (16)
	/* Client-side render distance, in chunks. */
	ViewDistance Byte // Byte
	/* 0: enabled, 1: commands only, 2: hidden.  See processing chat for more information. */
	ChatMode VarInt // VarInt Enum
	/* “Colors” multiplayer setting. */
	ChatColors Bool // Boolean
	/* Bit mask, see below. */
	DisplayedSkinParts UByte // Unsigned Byte
	/* 0: Left, 1: Right. */
	MainHand VarInt // VarInt Enum
	/* Disables filtering of text on signs and written book titles. Currently always true (i.e. the filtering is disabled) */
	DisableTextFiltering Bool // Boolean
}

var _ Packet = (*PlayClientSettings_756_1)(nil)

func (p PlayClientSettings_756_1)Encode(b *PacketBuilder){
	b.String(p.Locale)
	b.Byte(p.ViewDistance)
	b.VarInt(p.ChatMode)
	b.Bool(p.ChatColors)
	b.UByte(p.DisplayedSkinParts)
	b.VarInt(p.MainHand)
	b.Bool(p.DisableTextFiltering)
}

func (p *PlayClientSettings_756_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Locale, ok = r.String(); !ok {
		return io.EOF
	}
	if p.ViewDistance, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ChatMode, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ChatColors, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.DisplayedSkinParts, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.MainHand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.DisableTextFiltering, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x5
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x5
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x5
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x5
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x4
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x4
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x4
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x5
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x4
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x4
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x4
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x4
type PlayClientSettings_754_2 struct {
	/* e.g. en_GB */
	Locale String // String (16)
	/* Client-side render distance, in chunks */
	ViewDistance Byte // Byte
	/* 0: enabled, 1: commands only, 2: hidden.  See processing chat for more information. */
	ChatMode VarInt // VarInt Enum
	/* “Colors” multiplayer setting */
	ChatColors Bool // Boolean
	/* Bit mask, see below */
	DisplayedSkinParts UByte // Unsigned Byte
	/* 0: Left, 1: Right */
	MainHand VarInt // VarInt Enum
}

var _ Packet = (*PlayClientSettings_754_2)(nil)

func (p PlayClientSettings_754_2)Encode(b *PacketBuilder){
	b.String(p.Locale)
	b.Byte(p.ViewDistance)
	b.VarInt(p.ChatMode)
	b.Bool(p.ChatColors)
	b.UByte(p.DisplayedSkinParts)
	b.VarInt(p.MainHand)
}

func (p *PlayClientSettings_754_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Locale, ok = r.String(); !ok {
		return io.EOF
	}
	if p.ViewDistance, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ChatMode, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ChatColors, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.DisplayedSkinParts, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.MainHand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x4
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x4
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x4
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x4
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x4
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x4
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x4
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x4
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x3
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x3
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x3
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x4
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x3
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x3
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x3
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x3
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x16
type PlayClientStatus_758_0 struct {
	/* See below */
	ActionID VarInt // VarInt Enum
}

var _ Packet = (*PlayClientStatus_758_0)(nil)

func (p PlayClientStatus_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.ActionID)
}

func (p *PlayClientStatus_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ActionID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x11
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x11
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0xf
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x10
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x10
type PlayCloseContainer_763_0 struct {
	/* This is the ID of the window that was closed. 0 for inventory. */
	WindowID UByte // Unsigned Byte
}

var _ Packet = (*PlayCloseContainer_763_0)(nil)

func (p PlayCloseContainer_763_0)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
}

func (p *PlayCloseContainer_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0xc
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0xc
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0xb
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0xc
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0xb
type PlayCloseContainerServer_763_0 struct {
	/* This is the ID of the window that was closed. 0 for player inventory. */
	WindowID UByte // Unsigned Byte
}

var _ Packet = (*PlayCloseContainerServer_763_0)(nil)

func (p PlayCloseContainerServer_763_0)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
}

func (p *PlayCloseContainerServer_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x13
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x13
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x13
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x13
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x12
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x12
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x14
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x13
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x13
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x12
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x12
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x12
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x12
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x12
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x12
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x12
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x2e
type PlayCloseWindow_758_0 struct {
	/* This is the ID of the window that was closed. 0 for inventory. */
	WindowID UByte // Unsigned Byte
}

var _ Packet = (*PlayCloseWindow_758_0)(nil)

func (p PlayCloseWindow_758_0)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
}

func (p *PlayCloseWindow_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x9
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x9
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x9
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x9
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0xa
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0xa
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0xa
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0xa
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x9
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x8
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x8
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x9
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x8
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x8
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x8
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x8
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0xd
type PlayCloseWindowServer_758_0 struct {
	/* This is the ID of the window that was closed. 0 for player inventory. */
	WindowID UByte // Unsigned Byte
}

var _ Packet = (*PlayCloseWindowServer_758_0)(nil)

func (p PlayCloseWindowServer_758_0)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
}

func (p *PlayCloseWindowServer_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x61
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x61
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x60
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x60
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x55
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x55
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x56
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x55
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x4f
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x4b
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x4b
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x4a
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x48
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x48
type PlayCollectItem_758_0 struct {
	CollectedEntityID VarInt // VarInt
	CollectorEntityID VarInt // VarInt
	/* Seems to be 1 for XP orbs, otherwise the number of items in the stack. */
	PickupItemCount VarInt // VarInt
}

var _ Packet = (*PlayCollectItem_758_0)(nil)

func (p PlayCollectItem_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.CollectedEntityID)
	b.VarInt(p.CollectorEntityID)
	b.VarInt(p.PickupItemCount)
}

func (p *PlayCollectItem_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.CollectedEntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.CollectorEntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.PickupItemCount, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x48
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x48
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0xd
type PlayCollectItem_210_1 struct {
	CollectedEntityID VarInt // VarInt
	CollectorEntityID VarInt // VarInt
}

var _ Packet = (*PlayCollectItem_210_1)(nil)

func (p PlayCollectItem_210_1)Encode(b *PacketBuilder){
	b.VarInt(p.CollectedEntityID)
	b.VarInt(p.CollectorEntityID)
}

func (p *PlayCollectItem_210_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.CollectedEntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.CollectorEntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x38
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x34
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x36
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x33
type PlayCombatDeath_762_1 struct {
	/* Entity ID of the player that died (should match the client's entity ID). */
	PlayerID VarInt // VarInt
	/* The killer entity's ID, or -1 if there is no obvious killer. */
	EntityID Int // Int
	/* The death message. */
	Message Object // Chat
}

var _ Packet = (*PlayCombatDeath_762_1)(nil)

func (p PlayCombatDeath_762_1)Encode(b *PacketBuilder){
	b.VarInt(p.PlayerID)
	b.Int(p.EntityID)
	b.JSON(p.Message)
}

func (p *PlayCombatDeath_762_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.PlayerID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	if err = r.JSON(&p.Message); err != nil {
		return err
	}
	return nil
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x31
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x31
type PlayCombatEvent_754_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name      | Field Name | Field Type  | Notes                                                                                          |
	 * |-----------|-------|----------|-----------------|------------|-------------|------------------------------------------------------------------------------------------------|
	 * | 0x31      | Play  | Client   | Event           | Event      | VarInt Enum | Determines the layout of the remaining packet                                                  |
	 * | 0x31      | Play  | Client   | Event           | Field Name |             |                                                                                                |
	 * | 0x31      | Play  | Client   | 0: enter combat | no fields  | no fields   |                                                                                                |
	 * | 0x31      | Play  | Client   | 1: end combat   | Duration   | VarInt      | Length of the combat in ticks.                                                                 |
	 * | 0x31      | Play  | Client   | 1: end combat   | Entity ID  | Int         | ID of the primary opponent of the ended combat, or -1 if there is no obvious primary opponent. |
	 * | 0x31      | Play  | Client   | 2: entity dead  | Player ID  | VarInt      | Entity ID of the player that died (should match the client's entity ID).                       |
	 * | 0x31      | Play  | Client   | 2: entity dead  | Entity ID  | Int         | The killing entity's ID, or -1 if there is no obvious killer.                                  |
	 * | 0x31      | Play  | Client   | 2: entity dead  | Message    | Chat        | The death message                                                                              |
	 * 
	 */
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x2d
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x2d
type PlayCombatEvent_340_4 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name      | Field Name | Field Type  | Notes                                         |
	 * |-----------|-------|----------|-----------------|------------|-------------|-----------------------------------------------|
	 * | 0x2D      | Play  | Client   | Event           | Event      | VarInt Enum | Determines the layout of the remaining packet |
	 * | 0x2D      | Play  | Client   | Event           | Field Name |             |                                               |
	 * | 0x2D      | Play  | Client   | 0: enter combat | no fields  | no fields   |                                               |
	 * | 0x2D      | Play  | Client   | 1: end combat   | Duration   | VarInt      |                                               |
	 * | 0x2D      | Play  | Client   | 1: end combat   | Entity ID  | Int         |                                               |
	 * | 0x2D      | Play  | Client   | 2: entity dead  | Player ID  | VarInt      |                                               |
	 * | 0x2D      | Play  | Client   | 2: entity dead  | Entity ID  | Int         |                                               |
	 * | 0x2D      | Play  | Client   | 2: entity dead  | Message    | Chat        |                                               |
	 * 
	 */
}

// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x2c
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x2c
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x2c
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x2c
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x2c
type PlayCombatEvent_335_5 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name      | Field Name | Field Type  | Notes                                         |
	 * |-----------|-------|----------|-----------------|------------|-------------|-----------------------------------------------|
	 * | 0x2C      | Play  | Client   | Event           | Event      | VarInt Enum | Determines the layout of the remaining packet |
	 * | 0x2C      | Play  | Client   | Event           | Field Name |             |                                               |
	 * | 0x2C      | Play  | Client   | 0: enter combat | no fields  | no fields   |                                               |
	 * | 0x2C      | Play  | Client   | 1: end combat   | Duration   | VarInt      |                                               |
	 * | 0x2C      | Play  | Client   | 1: end combat   | Entity ID  | Int         |                                               |
	 * | 0x2C      | Play  | Client   | 2: entity dead  | Player ID  | VarInt      |                                               |
	 * | 0x2C      | Play  | Client   | 2: entity dead  | Entity ID  | Int         |                                               |
	 * | 0x2C      | Play  | Client   | 2: entity dead  | Message    | Chat        |                                               |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x9
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x9
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x8
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x9
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x8
type PlayCommandSuggestionsRequest_763_0 struct {
	/* The id of the transaction that the server will send back to the client in the response of this packet. Client generates this and increments it each time it sends another tab completion that doesn't get a response. */
	TransactionId VarInt // VarInt
	/* All text behind the cursor without the / (e.g. to the left of the cursor in left-to-right languages like English). */
	Text String // String (32500)
}

var _ Packet = (*PlayCommandSuggestionsRequest_763_0)(nil)

func (p PlayCommandSuggestionsRequest_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.TransactionId)
	b.String(p.Text)
}

func (p *PlayCommandSuggestionsRequest_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TransactionId, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Text, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0xf
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0xf
type PlayCommandSuggestionsResponse_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name  | Field Type | Field Type     | Notes                                                                                                                                                                                                  |
	 * |-----------|-------|----------|------------|-------------|------------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x0F      | Play  | Client   |            |             |            |                |                                                                                                                                                                                                        |
	 * | 0x0F      | Play  | Client   | ID         | ID          | VarInt     | VarInt         | Transaction ID.                                                                                                                                                                                        |
	 * | 0x0F      | Play  | Client   | Start      | Start       | VarInt     | VarInt         | Start of the text to replace.                                                                                                                                                                          |
	 * | 0x0F      | Play  | Client   | Length     | Length      | VarInt     | VarInt         | Length of the text to replace.                                                                                                                                                                         |
	 * | 0x0F      | Play  | Client   | Count      | Count       | VarInt     | VarInt         | Number of elements in the following array.                                                                                                                                                             |
	 * | 0x0F      | Play  | Client   | Matches    | Match       | Array      | String (32767) | One eligible value to insert, note that each command is sent separately instead of in a single string, hence the need for Count.  Note that for instance this doesn't include a leading / on commands. |
	 * | 0x0F      | Play  | Client   | Matches    | Has tooltip | Array      | Boolean        | True if the following is present.                                                                                                                                                                      |
	 * | 0x0F      | Play  | Client   | Matches    | Tooltip     | Array      | Optional Chat  | Tooltip to display; only present if previous boolean is true.                                                                                                                                          |
	 * 
	 */
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0xe
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0xe
type PlayCommandSuggestionsResponse_760_2 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name  | Field Type | Field Type     | Notes                                                                                                                                                                                                  |
	 * |-----------|-------|----------|------------|-------------|------------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x0E      | Play  | Client   |            |             |            |                |                                                                                                                                                                                                        |
	 * | 0x0E      | Play  | Client   | ID         | ID          | VarInt     | VarInt         | Transaction ID.                                                                                                                                                                                        |
	 * | 0x0E      | Play  | Client   | Start      | Start       | VarInt     | VarInt         | Start of the text to replace.                                                                                                                                                                          |
	 * | 0x0E      | Play  | Client   | Length     | Length      | VarInt     | VarInt         | Length of the text to replace.                                                                                                                                                                         |
	 * | 0x0E      | Play  | Client   | Count      | Count       | VarInt     | VarInt         | Number of elements in the following array.                                                                                                                                                             |
	 * | 0x0E      | Play  | Client   | Matches    | Match       | Array      | String (32767) | One eligible value to insert, note that each command is sent separately instead of in a single string, hence the need for Count.  Note that for instance this doesn't include a leading / on commands. |
	 * | 0x0E      | Play  | Client   | Matches    | Has tooltip | Array      | Boolean        | True if the following is present.                                                                                                                                                                      |
	 * | 0x0E      | Play  | Client   | Matches    | Tooltip     | Array      | Optional Chat  | Tooltip to display; only present if previous boolean is true.                                                                                                                                          |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x10
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x10
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0xe
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0xf
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0xf
type PlayCommands_763_0 struct {
	/* Number of elements in the following array. */
	Count VarInt // VarInt
	/* An array of nodes. */
	Nodes []*CommandNode // Array of Node
	/* Index of the root node in the previous array. */
	RootIndex VarInt // VarInt
}

var _ Packet = (*PlayCommands_763_0)(nil)

func (p PlayCommands_763_0)Encode(b *PacketBuilder){
	p.Count = (VarInt)(len(p.Nodes))
	b.VarInt(p.Count)
	for _, v := range p.Nodes {
		v.Encode(b)
	}
	b.VarInt(p.RootIndex)
}

func (p *PlayCommands_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Count, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Nodes = make([]*CommandNode, p.Count)
	for i, _ := range p.Nodes {
		p.Nodes[i] = new(CommandNode)
		if err = p.Nodes[i].DecodeFrom(r); err != nil {
			return err
		}
	}
	if p.RootIndex, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x0
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x0
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x0
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x0
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x0
type PlayConfirmTeleportation_763_0 struct {
	/* The ID given by the Synchronize Player Position packet. */
	TeleportID VarInt // VarInt
}

var _ Packet = (*PlayConfirmTeleportation_763_0)(nil)

func (p PlayConfirmTeleportation_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.TeleportID)
}

func (p *PlayConfirmTeleportation_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TeleportID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x12
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x11
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x11
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x11
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x11
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x11
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x11
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x11
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x32
type PlayConfirmTransaction_404_0 struct {
	/* The ID of the window that the action occurred in */
	WindowID Byte // Byte
	/* Every action that is to be accepted has a unique number. This number is an incrementing integer (starting at 0) with separate counts for each window ID. */
	ActionNumber Short // Short
	/* Whether the action was accepted */
	Accepted Bool // Boolean
}

var _ Packet = (*PlayConfirmTransaction_404_0)(nil)

func (p PlayConfirmTransaction_404_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.Short(p.ActionNumber)
	b.Bool(p.Accepted)
}

func (p *PlayConfirmTransaction_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ActionNumber, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.Accepted, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x6
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x5
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x5
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x6
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x5
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x5
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x5
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x5
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0xf
type PlayConfirmTransactionServer_404_0 struct {
	/* The ID of the window that the action occurred in */
	WindowID Byte // Byte
	/* Every action that is to be accepted has a unique number. This number is an incrementing integer (starting at 1) with separate counts for each window ID. */
	ActionNumber Short // Short
	/* Whether the action was accepted */
	Accepted Bool // Boolean
}

var _ Packet = (*PlayConfirmTransactionServer_404_0)(nil)

func (p PlayConfirmTransactionServer_404_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.Short(p.ActionNumber)
	b.Bool(p.Accepted)
}

func (p *PlayConfirmTransactionServer_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ActionNumber, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.Accepted, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x18
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x18
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x18
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x18
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x19
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x19
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x18
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x18
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x16
type PlayCraftRecipeRequest_758_0 struct {
	WindowID Byte // Byte
	/* A recipe ID */
	Recipe String // Identifier
	/* Affects the amount of items processed; true if shift is down when clicked */
	MakeAll Bool // Boolean
}

var _ Packet = (*PlayCraftRecipeRequest_758_0)(nil)

func (p PlayCraftRecipeRequest_758_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.String(p.Recipe)
	b.Bool(p.MakeAll)
}

func (p *PlayCraftRecipeRequest_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Recipe, ok = r.String(); !ok {
		return io.EOF
	}
	if p.MakeAll, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x12
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x12
type PlayCraftRecipeRequest_340_1 struct {
	WindowID Byte // Byte
	/* A recipe ID */
	Recipe VarInt // VarInt
	/* Affects the amount of items processed; true if shift is down when clicked */
	MakeAll Bool // Boolean
}

var _ Packet = (*PlayCraftRecipeRequest_340_1)(nil)

func (p PlayCraftRecipeRequest_340_1)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.VarInt(p.Recipe)
	b.Bool(p.MakeAll)
}

func (p *PlayCraftRecipeRequest_340_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Recipe, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.MakeAll, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x31
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x31
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x31
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x31
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x2f
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x2f
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x31
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x30
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x2d
type PlayCraftRecipeResponse_758_0 struct {
	WindowID Byte // Byte
	/* A recipe ID */
	Recipe String // Identifier
}

var _ Packet = (*PlayCraftRecipeResponse_758_0)(nil)

func (p PlayCraftRecipeResponse_758_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.String(p.Recipe)
}

func (p *PlayCraftRecipeResponse_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Recipe, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x2b
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x2b
type PlayCraftRecipeResponse_340_1 struct {
	WindowID Byte // Byte
	/* A recipe ID */
	Recipe VarInt // VarInt
}

var _ Packet = (*PlayCraftRecipeResponse_340_1)(nil)

func (p PlayCraftRecipeResponse_340_1)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.VarInt(p.Recipe)
}

func (p *PlayCraftRecipeResponse_340_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Recipe, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x17
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x17
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x17
type PlayCraftingBookData_340_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name              | Field Name         | Field Type | Notes                                                               |
	 * |-----------|-------|----------|-------------------------|--------------------|------------|---------------------------------------------------------------------|
	 * | 0x17      | Play  | Server   | Type                    | Type               | VarInt     | Determines the format of the rest of the packet                     |
	 * | 0x17      | Play  | Server   | Type                    | Field Name         |            |                                                                     |
	 * | 0x17      | Play  | Server   | 0: Displayed Recipe     | Recipe ID          | Int        | The internal id of the displayed recipe.                            |
	 * | 0x17      | Play  | Server   | 1: Crafting Book Status | Crafting Book Open | Boolean    | Whether the player has the crafting book currently opened/active.   |
	 * | 0x17      | Play  | Server   | 1: Crafting Book Status | Crafting Filter    | Boolean    | Whether the player has the crafting filter option currently active. |
	 * 
	 */
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x28
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x28
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x28
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x28
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x28
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x29
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x26
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x26
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x24
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x1b
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x1b
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x1b
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x18
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x18
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x18
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x18
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x10
type PlayCreativeInventoryAction_758_0 struct {
	/* Inventory slot */
	Slot Short // Short
	ClickedItem *data.Slot // Slot
}

var _ Packet = (*PlayCreativeInventoryAction_758_0)(nil)

func (p PlayCreativeInventoryAction_758_0)Encode(b *PacketBuilder){
	b.Short(p.Slot)
	p.ClickedItem.Encode(b)
}

func (p *PlayCreativeInventoryAction_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Slot, ok = r.Short(); !ok {
		return io.EOF
	}
	p.ClickedItem = new(data.Slot)
	if err = p.ClickedItem.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x17
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x16
type PlayCustomSoundEffect_760_0 struct {
	/* All sound effect names can be seen here. */
	SoundName String // Identifier
	/* The category that this sound will be played from (current categories). */
	SoundCategory VarInt // VarInt Enum
	/* Effect X multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part). */
	EffectPositionX Int // Int
	/* Effect Y multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part). */
	EffectPositionY Int // Int
	/* Effect Z multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part). */
	EffectPositionZ Int // Int
	/* 1 is 100%, can be more. */
	Volume Float // Float
	/* Float between 0.5 and 2.0 by Notchian clients. */
	Pitch Float // Float
	/* Seed used to pick sound variant. */
	Seed Long // long
}

var _ Packet = (*PlayCustomSoundEffect_760_0)(nil)

func (p PlayCustomSoundEffect_760_0)Encode(b *PacketBuilder){
	b.String(p.SoundName)
	b.VarInt(p.SoundCategory)
	b.Int(p.EffectPositionX)
	b.Int(p.EffectPositionY)
	b.Int(p.EffectPositionZ)
	b.Float(p.Volume)
	b.Float(p.Pitch)
	b.Long(p.Seed)
}

func (p *PlayCustomSoundEffect_760_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SoundName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.SoundCategory, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EffectPositionX, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.EffectPositionY, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.EffectPositionZ, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.Volume, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Seed, ok = r.Long(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x18
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x18
type PlayDamageEvent_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name          | Field Type      | Field Type      | Notes                                                                                                                                                                                                                                                                                                                                                                          |
	 * |-----------|-------|----------|---------------------|---------------------|-----------------|-----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x18      | Play  | Client   |                     |                     |                 |                 |                                                                                                                                                                                                                                                                                                                                                                                |
	 * | 0x18      | Play  | Client   | Entity ID           | Entity ID           | VarInt          | VarInt          | The ID of the entity taking damage                                                                                                                                                                                                                                                                                                                                             |
	 * | 0x18      | Play  | Client   | Source Type ID      | Source Type ID      | VarInt          | VarInt          | The ID of the type of damage taken                                                                                                                                                                                                                                                                                                                                             |
	 * | 0x18      | Play  | Client   | Source Cause ID     | Source Cause ID     | VarInt          | VarInt          | The ID + 1 of the entity responsible for the damage, if present. If not present, the value is 0                                                                                                                                                                                                                                                                                |
	 * | 0x18      | Play  | Client   | Source Direct ID    | Source Direct ID    | VarInt          | VarInt          | The ID + 1 of the entity that directly dealt the damage, if present. If not present, the value is 0. If this field is present:
	 * and damage was dealt indirectly, such as by the use of a projectile, this field will contain the ID of such projectile;
	 * and damage was dealt dirctly, such as by manually attacking, this field will contain the same value as Source Cause ID. |
	 * | 0x18      | Play  | Client   | Has Source Position | Has Source Position | Boolean         | Boolean         | Indicates the presence of the three following fields.
	 * The Notchian server sends the Source Position when the damage was dealt by the /damage command and a position was specified                                                                                                                                                                                              |
	 * | 0x18      | Play  | Client   | Source Position X   | Source Position X   | Optional Double | Optional Double | Only present if Has Source Position is true                                                                                                                                                                                                                                                                                                                                    |
	 * | 0x18      | Play  | Client   | Source Position Y   | Source Position Y   | Optional Double | Optional Double | Only present if Has Source Position is true                                                                                                                                                                                                                                                                                                                                    |
	 * | 0x18      | Play  | Client   | Source Position Z   | Source Position Z   | Optional Double | Optional Double | Only present if Has Source Position is true                                                                                                                                                                                                                                                                                                                                    |
	 * 
	 */
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x35
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x35
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x35
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x35
type PlayDeathCombatEvent_758_0 struct {
	/* Entity ID of the player that died (should match the client's entity ID). */
	PlayerID VarInt // VarInt
	/* The killing entity's ID, or -1 if there is no obvious killer. */
	EntityID Int // Int
	/* The death message. */
	Message Object // Chat
}

var _ Packet = (*PlayDeathCombatEvent_758_0)(nil)

func (p PlayDeathCombatEvent_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.PlayerID)
	b.Int(p.EntityID)
	b.JSON(p.Message)
}

func (p *PlayDeathCombatEvent_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.PlayerID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	if err = r.JSON(&p.Message); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x12
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x12
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x12
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x12
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x10
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x10
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x12
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x11
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x11
type PlayDeclareCommands_758_0 struct {
	/* Number of elements in the following array */
	Count VarInt // VarInt
	/* An array of nodes */
	Nodes []*CommandNode // Array of Node
	/* Index of the root node in the previous array */
	RootIndex VarInt // VarInt
}

var _ Packet = (*PlayDeclareCommands_758_0)(nil)

func (p PlayDeclareCommands_758_0)Encode(b *PacketBuilder){
	p.Count = (VarInt)(len(p.Nodes))
	b.VarInt(p.Count)
	for _, v := range p.Nodes {
		v.Encode(b)
	}
	b.VarInt(p.RootIndex)
}

func (p *PlayDeclareCommands_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Count, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Nodes = make([]*CommandNode, p.Count)
	for i, _ := range p.Nodes {
		p.Nodes[i] = new(CommandNode)
		if err = p.Nodes[i].DecodeFrom(r); err != nil {
			return err
		}
	}
	if p.RootIndex, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x66
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x66
type PlayDeclareRecipes_758_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name  | Field Name  | Field Type | Field Type       | Notes                                                                   |
	 * |-----------|-------|----------|-------------|-------------|------------|------------------|-------------------------------------------------------------------------|
	 * | 0x66      | Play  | Client   | Num Recipes | Num Recipes | VarInt     | VarInt           | Number of elements in the following array.                              |
	 * | 0x66      | Play  | Client   | Recipe      | Type        | Array      | Identifier       | The recipe type, see below.                                             |
	 * | 0x66      | Play  | Client   | Recipe      | Recipe ID   | Array      | Identifier       |                                                                         |
	 * | 0x66      | Play  | Client   | Recipe      | Data        | Array      | Optional, varies | Additional data for the recipe.  For some types, there will be no data. |
	 * 
	 */
}

// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x65
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x65
type PlayDeclareRecipes_756_1 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name  | Field Name  | Field Type | Field Type       | Notes                                                                   |
	 * |-----------|-------|----------|-------------|-------------|------------|------------------|-------------------------------------------------------------------------|
	 * | 0x65      | Play  | Client   | Num Recipes | Num Recipes | VarInt     | VarInt           | Number of elements in the following array.                              |
	 * | 0x65      | Play  | Client   | Recipe      | Type        | Array      | Identifier       | The recipe type, see below.                                             |
	 * | 0x65      | Play  | Client   | Recipe      | Recipe ID   | Array      | Identifier       |                                                                         |
	 * | 0x65      | Play  | Client   | Recipe      | Data        | Array      | Optional, varies | Additional data for the recipe.  For some types, there will be no data. |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x19
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x19
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x16
type PlayDeleteMessage_763_0 struct {
	/* Length of Signature. */
	SignatureLength VarInt // VarInt
	/* Bytes of the signature. */
	Signature ByteArray // Byte Array
}

var _ Packet = (*PlayDeleteMessage_763_0)(nil)

func (p PlayDeleteMessage_763_0)Encode(b *PacketBuilder){
	p.SignatureLength = (VarInt)(len(p.Signature))
	b.VarInt(p.SignatureLength)
	b.ByteArray(p.Signature)
}

func (p *PlayDeleteMessage_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SignatureLength, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Signature = make(ByteArray, p.SignatureLength)
	if ok = r.ByteArray(p.Signature); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x3a
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x3a
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x3a
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x36
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x36
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x38
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x37
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x35
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x32
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x32
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x31
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x30
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x30
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x30
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x30
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x13
type PlayDestroyEntities_758_0 struct {
	/* Number of elements in the following array */
	Count VarInt // VarInt
	/* The list of entities of destroy */
	EntityIDs []VarInt // Array of VarInt
}

var _ Packet = (*PlayDestroyEntities_758_0)(nil)

func (p PlayDestroyEntities_758_0)Encode(b *PacketBuilder){
	p.Count = (VarInt)(len(p.EntityIDs))
	b.VarInt(p.Count)
	for _, v := range p.EntityIDs {
		b.VarInt(v)
	}
}

func (p *PlayDestroyEntities_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Count, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.EntityIDs = make([]VarInt, p.Count)
	for i, _ := range p.EntityIDs {
		if p.EntityIDs[i], ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x1a
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x1a
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x17
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x19
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x17
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x1a
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x1a
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x1a
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x1a
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x19
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x19
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x1b
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x1a
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x1b
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x1a
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x1a
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x1a
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x1a
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x1a
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x1a
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x1a
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x40
type PlayDisconnect_763_0 struct {
	/* Displayed to the client when the connection terminates. */
	Reason Object // Chat
}

var _ Packet = (*PlayDisconnect_763_0)(nil)

func (p PlayDisconnect_763_0)Encode(b *PacketBuilder){
	b.JSON(p.Reason)
}

func (p *PlayDisconnect_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.Reason); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x1b
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x1b
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x18
type PlayDisguisedChatMessage_763_0 struct {
	Message Object // Chat
	/* The chat message type. */
	ChatType VarInt // VarInt
	/* The name associated with the chat type. Usually the message sender's display name. */
	ChatTypeName Object // Chat
	/* True if target name is present. */
	HasTargetName Bool // Boolean
	/* The target name associated with the chat type. Usually the message target's display name. Only present if previous boolean is true. */
	TargetName Object // Chat
}

var _ Packet = (*PlayDisguisedChatMessage_763_0)(nil)

func (p PlayDisguisedChatMessage_763_0)Encode(b *PacketBuilder){
	b.JSON(p.Message)
	b.VarInt(p.ChatType)
	b.JSON(p.ChatTypeName)
	b.Bool(p.HasTargetName)
	b.JSON(p.TargetName)
}

func (p *PlayDisguisedChatMessage_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.Message); err != nil {
		return err
	}
	if p.ChatType, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = r.JSON(&p.ChatTypeName); err != nil {
		return err
	}
	if p.HasTargetName, ok = r.Bool(); !ok {
		return io.EOF
	}
	if err = r.JSON(&p.TargetName); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x51
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x51
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x4d
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x4f
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x4c
type PlayDisplayObjective_763_0 struct {
	/* The position of the scoreboard. 0: list, 1: sidebar, 2: below name, 3 - 18: team specific sidebar, indexed as 3 + team color. */
	Position Byte // Byte
	/* The unique name for the scoreboard to be displayed. */
	ScoreName String // String (16)
}

var _ Packet = (*PlayDisplayObjective_763_0)(nil)

func (p PlayDisplayObjective_763_0)Encode(b *PacketBuilder){
	b.Byte(p.Position)
	b.String(p.ScoreName)
}

func (p *PlayDisplayObjective_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Position, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ScoreName, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x4c
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x4c
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x4c
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x4c
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x43
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x43
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x43
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x42
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x3e
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x3b
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x3b
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x3a
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x38
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x38
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x38
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x38
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x3d
type PlayDisplayScoreboard_758_0 struct {
	/* The position of the scoreboard. 0: list, 1: sidebar, 2: below name, 3 - 18: team specific sidebar, indexed as 3 + team color. */
	Position Byte // Byte
	/* The unique name for the scoreboard to be displayed. */
	ScoreName String // String (16)
}

var _ Packet = (*PlayDisplayScoreboard_758_0)(nil)

func (p PlayDisplayScoreboard_758_0)Encode(b *PacketBuilder){
	b.Byte(p.Position)
	b.String(p.ScoreName)
}

func (p *PlayDisplayScoreboard_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Position, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ScoreName, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0xe
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0xe
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0xd
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0xe
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0xd
type PlayEditBook_763_0 struct {
	/* The hotbar slot where the written book is located */
	Slot VarInt // VarInt
	/* Number of elements in the following array */
	Count VarInt // VarInt
	/* Text from each page. */
	Entries [][]String // Array of Strings (8192 chars)
	/* If true, the next field is present. */
	HasTitle Bool // Boolean
	/* Title of book. */
	Title Optional[String] // Optional String (128 chars)
}

var _ Packet = (*PlayEditBook_763_0)(nil)

func (p PlayEditBook_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.Slot)
	p.Count = (VarInt)(len(p.Entries))
	b.VarInt(p.Count)
	for _, v := range p.Entries {
		b.VarInt((VarInt)(len(v)))
		for _, e := range v {
			b.String(e)
		}
	}
	p.HasTitle = p.Title.Ok
	b.Bool(p.HasTitle)
	if p.Title.Ok {
		b.String(p.Title.V)
	}
}

func (p *PlayEditBook_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Slot, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Count, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Entries = make([][]String, p.Count)
	for i, _ := range p.Entries {
		var v VarInt
		if v, ok = r.VarInt(); !ok {
			return io.EOF
		}
		l := make([]String, v)
		p.Entries[i] = l
		for j, _ := range l {
			if l[j], ok = r.String(); !ok {
				return io.EOF
			}
		}
	}
	if p.HasTitle, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.Title.Ok = p.HasTitle; p.Title.Ok {
		if p.Title.V, ok = r.String(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0xb
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0xc
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0xc
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0xc
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0xc
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0xb
type PlayEditBook_755_4 struct {
	NewBook *data.Slot // Slot
	/* True if the player is signing the book; false if the player is saving a draft. */
	IsSigning Bool // Boolean
	/* 0: Main hand, 1: Off hand */
	Hand VarInt // VarInt enum
}

var _ Packet = (*PlayEditBook_755_4)(nil)

func (p PlayEditBook_755_4)Encode(b *PacketBuilder){
	p.NewBook.Encode(b)
	b.Bool(p.IsSigning)
	b.VarInt(p.Hand)
}

func (p *PlayEditBook_755_4)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	p.NewBook = new(data.Slot)
	if err = p.NewBook.DecodeFrom(r); err != nil {
		return err
	}
	if p.IsSigning, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.Hand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x23
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x23
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x23
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x23
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x21
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x21
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x23
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x22
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x23
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x21
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x21
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x21
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x21
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x21
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x21
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x21
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x28
type PlayEffect_758_0 struct {
	/* The ID of the effect, see below */
	EffectID Int // Int
	/* The location of the effect */
	Location Position // Position
	/* Extra data for certain effects, see below */
	Data Int // Int
	/* See above */
	DisableRelativeVolume Bool // Boolean
}

var _ Packet = (*PlayEffect_758_0)(nil)

func (p PlayEffect_758_0)Encode(b *PacketBuilder){
	b.Int(p.EffectID)
	p.Location.Encode(b)
	b.Int(p.Data)
	b.Bool(p.DisableRelativeVolume)
}

func (p *PlayEffect_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EffectID, ok = r.Int(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Data, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.DisableRelativeVolume, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x7
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x6
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x6
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x7
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x6
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x6
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x6
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x6
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x11
type PlayEnchantItem_404_0 struct {
	/* The ID of the enchantment table window sent by Open Window */
	WindowID Byte // Byte
	/* The position of the enchantment on the enchantment table window, starting with 0 as the topmost one */
	Enchantment Byte // Byte
}

var _ Packet = (*PlayEnchantItem_404_0)(nil)

func (p PlayEnchantItem_404_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.Byte(p.Enchantment)
}

func (p *PlayEnchantItem_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Enchantment, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x36
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x32
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x34
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x31
type PlayEndCombat_762_1 struct {
	/* Length of the combat in ticks. */
	Duration VarInt // VarInt
	/* ID of the primary opponent of the ended combat, or -1 if there is no obvious primary opponent. */
	EntityID Int // Int
}

var _ Packet = (*PlayEndCombat_762_1)(nil)

func (p PlayEndCombat_762_1)Encode(b *PacketBuilder){
	b.VarInt(p.Duration)
	b.Int(p.EntityID)
}

func (p *PlayEndCombat_762_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Duration, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x33
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x33
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x33
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x33
type PlayEndCombatEvent_758_0 struct {
	/* Length of the combat in ticks. */
	Duration VarInt // VarInt
	/* ID of the primary opponent of the ended combat, or -1 if there is no obvious primary opponent. */
	EntityID Int // Int
}

var _ Packet = (*PlayEndCombatEvent_758_0)(nil)

func (p PlayEndCombatEvent_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.Duration)
	b.Int(p.EntityID)
}

func (p *PlayEndCombatEvent_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Duration, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x37
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x37
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x33
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x35
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x32
type PlayEnterCombat_763_0 struct {
}

var _ Packet = (*PlayEnterCombat_763_0)(nil)

func (p PlayEnterCombat_763_0)Encode(b *PacketBuilder){
}

func (p *PlayEnterCombat_763_0)DecodeFrom(r *PacketReader)(error){ return nil }

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x34
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x34
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x34
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x34
type PlayEnterCombatEvent_758_0 struct {
}

var _ Packet = (*PlayEnterCombatEvent_758_0)(nil)

func (p PlayEnterCombatEvent_758_0)Encode(b *PacketBuilder){
}

func (p *PlayEnterCombatEvent_758_0)DecodeFrom(r *PacketReader)(error){ return nil }

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x27
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x25
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x25
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x25
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x28
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x28
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x28
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x28
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x14
type PlayEntity_404_0 struct {
	EntityID VarInt // VarInt
}

var _ Packet = (*PlayEntity_404_0)(nil)

func (p PlayEntity_404_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
}

func (p *PlayEntity_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x1b
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x1b
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x1b
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x1b
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x1c
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x1c
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x1b
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x1b
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x19
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x15
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x15
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x15
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x14
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x14
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x14
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x14
type PlayEntityAction_758_0 struct {
	/* Player ID */
	EntityID VarInt // VarInt
	/* The ID of the action, see below */
	ActionID VarInt // VarInt Enum
	/* Only used by the “start jump with horse” action, in which case it ranges from 0 to 100. In all other cases it is 0. */
	JumpBoost VarInt // VarInt
}

var _ Packet = (*PlayEntityAction_758_0)(nil)

func (p PlayEntityAction_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.VarInt(p.ActionID)
	b.VarInt(p.JumpBoost)
}

func (p *PlayEntityAction_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ActionID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.JumpBoost, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x4
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x4
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x3
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x3
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x3
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x6
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x6
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x6
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x6
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x5
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x5
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x6
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x6
type PlayEntityAnimation_763_0 struct {
	/* Player ID */
	EntityID VarInt // VarInt
	/* Animation ID (see below) */
	Animation UByte // Unsigned Byte
}

var _ Packet = (*PlayEntityAnimation_763_0)(nil)

func (p PlayEntityAnimation_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UByte(p.Animation)
}

func (p *PlayEntityAnimation_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Animation, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x6c
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x6c
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x68
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x69
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x66
type PlayEntityEffect_763_0 struct {
	EntityID VarInt // VarInt
	/* See this table. */
	EffectID VarInt // VarInt
	/* Notchian client displays effect level as Amplifier + 1. */
	Amplifier Byte // Byte
	/* Duration in ticks. */
	Duration VarInt // VarInt
	/* Bit field, see below. */
	Flags Byte // Byte
	/* Used in DARKNESS effect */
	HasFactorData Bool // Boolean
	/* See below */
	FactorCodec nbt.NBT // NBT Tag
}

var _ Packet = (*PlayEntityEffect_763_0)(nil)

func (p PlayEntityEffect_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.VarInt(p.EffectID)
	b.Byte(p.Amplifier)
	b.VarInt(p.Duration)
	b.Byte(p.Flags)
	b.Bool(p.HasFactorData)
	nbt.WriteNBT(b, p.FactorCodec)
}

func (p *PlayEntityEffect_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EffectID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Amplifier, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Duration, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.HasFactorData, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.FactorCodec, err = nbt.ReadNBT(r); err != nil {
		return err
	}
	return nil
}

// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x65
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x64
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x64
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x59
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x59
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x5a
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x59
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x53
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x4f
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x4f
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x4e
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x4b
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x4b
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x4b
type PlayEntityEffect_757_2 struct {
	EntityID VarInt // VarInt
	/* See this table */
	EffectID Byte // Byte
	/* Notchian client displays effect level as Amplifier + 1 */
	Amplifier Byte // Byte
	/* Seconds */
	Duration VarInt // VarInt
	/* Bit field, see below. */
	Flags Byte // Byte
}

var _ Packet = (*PlayEntityEffect_757_2)(nil)

func (p PlayEntityEffect_757_2)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Byte(p.EffectID)
	b.Byte(p.Amplifier)
	b.VarInt(p.Duration)
	b.Byte(p.Flags)
}

func (p *PlayEntityEffect_757_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EffectID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Amplifier, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Duration, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x4b
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x1d
type PlayEntityEffect_110_3 struct {
	EntityID VarInt // VarInt
	/* See this table */
	EffectID Byte // Byte
	/* Notchian client displays effect level as Amplifier + 1 */
	Amplifier Byte // Byte
	/* Seconds */
	Duration VarInt // VarInt
	HideParticles Bool // Boolean
}

var _ Packet = (*PlayEntityEffect_110_3)(nil)

func (p PlayEntityEffect_110_3)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Byte(p.EffectID)
	b.Byte(p.Amplifier)
	b.VarInt(p.Duration)
	b.Bool(p.HideParticles)
}

func (p *PlayEntityEffect_110_3)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EffectID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Amplifier, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Duration, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.HideParticles, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x50
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x50
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x50
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x50
type PlayEntityEquipment_758_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name | Field Type | Field Type | Notes                                                                                                                                                                                                                          |
	 * |-----------|-------|----------|------------|------------|------------|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x50      | Play  | Client   | Entity ID  | Entity ID  | VarInt     | VarInt     | Entity's EID.                                                                                                                                                                                                                  |
	 * | 0x50      | Play  | Client   | Equipment  | Slot       | Array      | Byte Enum  | Equipment slot. 0: main hand, 1: off hand, 2–5: armor slot (2: boots, 3: leggings, 4: chestplate, 5: helmet).  Also has the top bit set if another entry follows, and otherwise unset if this is the last item in the array. |
	 * | 0x50      | Play  | Client   | Equipment  | Item       | Array      | Slot       |                                                                                                                                                                                                                                |
	 * 
	 */
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x47
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x47
type PlayEntityEquipment_754_1 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name | Field Type | Field Type | Notes                                                                                                                                                                                                                          |
	 * |-----------|-------|----------|------------|------------|------------|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x47      | Play  | Client   | Entity ID  | Entity ID  | VarInt     | VarInt     | Entity's EID                                                                                                                                                                                                                   |
	 * | 0x47      | Play  | Client   | Equipment  | Slot       | Array      | Byte Enum  | Equipment slot. 0: main hand, 1: off hand, 2–5: armor slot (2: boots, 3: leggings, 4: chestplate, 5: helmet).  Also has the top bit set if another entry follows, and otherwise unset if this is the last item in the array. |
	 * | 0x47      | Play  | Client   | Equipment  | Item       | Array      | Slot       |                                                                                                                                                                                                                                |
	 * 
	 */
}

// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x47
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x46
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x42
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x3f
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x3f
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x3e
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x3c
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x3c
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x3c
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x3c
type PlayEntityEquipment_578_2 struct {
	/* Entity's EID */
	EntityID VarInt // VarInt
	/* Equipment slot. 0: main hand, 1: off hand, 2–5: armor slot (2: boots, 3: leggings, 4: chestplate, 5: helmet) */
	Slot VarInt // VarInt Enum
	Item *data.Slot // Slot
}

var _ Packet = (*PlayEntityEquipment_578_2)(nil)

func (p PlayEntityEquipment_578_2)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.VarInt(p.Slot)
	p.Item.Encode(b)
}

func (p *PlayEntityEquipment_578_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Slot, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Item = new(data.Slot)
	if err = p.Item.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x1c
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x1c
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x19
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x1a
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x18
type PlayEntityEvent_763_0 struct {
	EntityID Int // Int
	/* See Entity statuses for a list of which statuses are valid for each type of entity. */
	EntityStatus Byte // Byte Enum
}

var _ Packet = (*PlayEntityEvent_763_0)(nil)

func (p PlayEntityEvent_763_0)Encode(b *PacketBuilder){
	b.Int(p.EntityID)
	b.Byte(p.EntityStatus)
}

func (p *PlayEntityEvent_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.EntityStatus, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x3e
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x3e
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x3e
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x3e
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x3a
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x3a
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x3c
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x3b
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x39
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x36
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x36
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x35
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x34
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x34
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x34
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x34
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x19
type PlayEntityHeadLook_758_0 struct {
	EntityID VarInt // VarInt
	/* New angle, not a delta */
	HeadYaw Angle // Angle
}

var _ Packet = (*PlayEntityHeadLook_758_0)(nil)

func (p PlayEntityHeadLook_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UByte(p.HeadYaw)
}

func (p *PlayEntityHeadLook_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.HeadYaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x2a
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x28
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x28
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x28
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x27
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x27
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x27
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x27
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x16
type PlayEntityLook_404_0 struct {
	EntityID VarInt // VarInt
	/* New angle, not a delta */
	Yaw Angle // Angle
	/* New angle, not a delta */
	Pitch Angle // Angle
	OnGround Bool // Boolean
}

var _ Packet = (*PlayEntityLook_404_0)(nil)

func (p PlayEntityLook_404_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlayEntityLook_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x29
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x27
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x27
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x27
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x26
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x26
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x26
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x26
type PlayEntityLookAndRelativeMove_404_0 struct {
	EntityID VarInt // VarInt
	/* Change in X position as (currentX * 32 - prevX * 32) * 128 */
	DeltaX Short // Short
	/* Change in Y position as (currentY * 32 - prevY * 32) * 128 */
	DeltaY Short // Short
	/* Change in Z position as (currentZ * 32 - prevZ * 32) * 128 */
	DeltaZ Short // Short
	/* New angle, not a delta */
	Yaw Angle // Angle
	/* New angle, not a delta */
	Pitch Angle // Angle
	OnGround Bool // Boolean
}

var _ Packet = (*PlayEntityLookAndRelativeMove_404_0)(nil)

func (p PlayEntityLookAndRelativeMove_404_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Short(p.DeltaX)
	b.Short(p.DeltaY)
	b.Short(p.DeltaZ)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlayEntityLookAndRelativeMove_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.DeltaX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.DeltaY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.DeltaZ, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x4d
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x4d
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x4d
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x4d
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x44
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x44
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x44
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x43
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x3f
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x3c
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x3c
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x3b
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x39
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x39
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x39
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x39
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x1c
type PlayEntityMetadata_758_0 struct {
	EntityID VarInt // VarInt
	Metadata *data.EntityMetadata // Entity Metadata
}

var _ Packet = (*PlayEntityMetadata_758_0)(nil)

func (p PlayEntityMetadata_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	p.Metadata.Encode(b)
}

func (p *PlayEntityMetadata_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Metadata = new(data.EntityMetadata)
	if err = p.Metadata.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x2a
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x2a
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x2c
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x2b
type PlayEntityMovement_754_0 struct {
	EntityID VarInt // VarInt
}

var _ Packet = (*PlayEntityMovement_754_0)(nil)

func (p PlayEntityMovement_754_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
}

func (p *PlayEntityMovement_754_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x29
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x29
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x29
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x29
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x27
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x27
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x29
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x28
type PlayEntityPosition_758_0 struct {
	EntityID VarInt // VarInt
	/* Change in X position as (currentX * 32 - prevX * 32) * 128 */
	DeltaX Short // Short
	/* Change in Y position as (currentY * 32 - prevY * 32) * 128 */
	DeltaY Short // Short
	/* Change in Z position as (currentZ * 32 - prevZ * 32) * 128 */
	DeltaZ Short // Short
	OnGround Bool // Boolean
}

var _ Packet = (*PlayEntityPosition_758_0)(nil)

func (p PlayEntityPosition_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Short(p.DeltaX)
	b.Short(p.DeltaY)
	b.Short(p.DeltaZ)
	b.Bool(p.OnGround)
}

func (p *PlayEntityPosition_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.DeltaX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.DeltaY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.DeltaZ, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x2a
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x2a
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x2a
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x2a
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x28
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x28
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x2a
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x29
type PlayEntityPositionAndRotation_758_0 struct {
	EntityID VarInt // VarInt
	/* Change in X position as (currentX * 32 - prevX * 32) * 128 */
	DeltaX Short // Short
	/* Change in Y position as (currentY * 32 - prevY * 32) * 128 */
	DeltaY Short // Short
	/* Change in Z position as (currentZ * 32 - prevZ * 32) * 128 */
	DeltaZ Short // Short
	/* New angle, not a delta */
	Yaw Angle // Angle
	/* New angle, not a delta */
	Pitch Angle // Angle
	OnGround Bool // Boolean
}

var _ Packet = (*PlayEntityPositionAndRotation_758_0)(nil)

func (p PlayEntityPositionAndRotation_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Short(p.DeltaX)
	b.Short(p.DeltaY)
	b.Short(p.DeltaZ)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlayEntityPositionAndRotation_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.DeltaX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.DeltaY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.DeltaZ, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x64
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x64
type PlayEntityProperties_758_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name           | Field Name           | Field Type | Field Type             | Notes                                                 |
	 * |-----------|-------|----------|----------------------|----------------------|------------|------------------------|-------------------------------------------------------|
	 * | 0x64      | Play  | Client   | Entity ID            | Entity ID            | VarInt     | VarInt                 |                                                       |
	 * | 0x64      | Play  | Client   | Number Of Properties | Number Of Properties | VarInt     | VarInt                 | Number of elements in the following array.            |
	 * | 0x64      | Play  | Client   | Property             | Key                  | Array      | Identifier             | See below.                                            |
	 * | 0x64      | Play  | Client   | Property             | Value                | Array      | Double                 | See below.                                            |
	 * | 0x64      | Play  | Client   | Property             | Number Of Modifiers  | Array      | VarInt                 | Number of elements in the following array.            |
	 * | 0x64      | Play  | Client   | Property             | Modifiers            | Array      | Array of Modifier Data | See Attribute#Modifiers. Modifier Data defined below. |
	 * 
	 */
}

// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x63
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x63
type PlayEntityProperties_756_1 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name           | Field Name           | Field Type | Field Type             | Notes                                                 |
	 * |-----------|-------|----------|----------------------|----------------------|------------|------------------------|-------------------------------------------------------|
	 * | 0x63      | Play  | Client   | Entity ID            | Entity ID            | VarInt     | VarInt                 |                                                       |
	 * | 0x63      | Play  | Client   | Number Of Properties | Number Of Properties | VarInt     | VarInt                 | Number of elements in the following array.            |
	 * | 0x63      | Play  | Client   | Property             | Key                  | Array      | Identifier             | See below.                                            |
	 * | 0x63      | Play  | Client   | Property             | Value                | Array      | Double                 | See below.                                            |
	 * | 0x63      | Play  | Client   | Property             | Number Of Modifiers  | Array      | VarInt                 | Number of elements in the following array.            |
	 * | 0x63      | Play  | Client   | Property             | Modifiers            | Array      | Array of Modifier Data | See Attribute#Modifiers. Modifier Data defined below. |
	 * 
	 */
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x58
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x58
type PlayEntityProperties_754_2 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name           | Field Name           | Field Type | Field Type             | Notes                                                 |
	 * |-----------|-------|----------|----------------------|----------------------|------------|------------------------|-------------------------------------------------------|
	 * | 0x58      | Play  | Client   | Entity ID            | Entity ID            | VarInt     | VarInt                 |                                                       |
	 * | 0x58      | Play  | Client   | Number Of Properties | Number Of Properties | Int        | Int                    | Number of elements in the following array             |
	 * | 0x58      | Play  | Client   | Property             | Key                  | Array      | Identifier             | See below                                             |
	 * | 0x58      | Play  | Client   | Property             | Value                | Array      | Double                 | See below                                             |
	 * | 0x58      | Play  | Client   | Property             | Number Of Modifiers  | Array      | VarInt                 | Number of elements in the following array             |
	 * | 0x58      | Play  | Client   | Property             | Modifiers            | Array      | Array of Modifier Data | See Attribute#Modifiers. Modifier Data defined below. |
	 * 
	 */
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x4e
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x4e
type PlayEntityProperties_340_6 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name           | Field Name           | Field Type | Field Type             | Notes                                                 |
	 * |-----------|-------|----------|----------------------|----------------------|------------|------------------------|-------------------------------------------------------|
	 * | 0x4E      | Play  | Client   | Entity ID            | Entity ID            | VarInt     | VarInt                 |                                                       |
	 * | 0x4E      | Play  | Client   | Number Of Properties | Number Of Properties | Int        | Int                    | Number of elements in the following array             |
	 * | 0x4E      | Play  | Client   | Property             | Key                  | Array      | String (64)            | See below                                             |
	 * | 0x4E      | Play  | Client   | Property             | Value                | Array      | Double                 | See below                                             |
	 * | 0x4E      | Play  | Client   | Property             | Number Of Modifiers  | Array      | VarInt                 | Number of elements in the following array             |
	 * | 0x4E      | Play  | Client   | Property             | Modifiers            | Array      | Array of Modifier Data | See Attribute#Modifiers. Modifier Data defined below. |
	 * 
	 */
}

// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x4a
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x4a
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x4a
type PlayEntityProperties_315_9 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name           | Field Name           | Field Type | Field Type             | Notes                                                 |
	 * |-----------|-------|----------|----------------------|----------------------|------------|------------------------|-------------------------------------------------------|
	 * | 0x4A      | Play  | Client   | Entity ID            | Entity ID            | VarInt     | VarInt                 |                                                       |
	 * | 0x4A      | Play  | Client   | Number Of Properties | Number Of Properties | Int        | Int                    | Number of elements in the following array             |
	 * | 0x4A      | Play  | Client   | Property             | Key                  | Array      | String                 | See below                                             |
	 * | 0x4A      | Play  | Client   | Property             | Value                | Array      | Double                 | See below                                             |
	 * | 0x4A      | Play  | Client   | Property             | Number Of Modifiers  | Array      | VarInt                 | Number of elements in the following array             |
	 * | 0x4A      | Play  | Client   | Property             | Modifiers            | Array      | Array of Modifier Data | See Attribute#Modifiers. Modifier Data defined below. |
	 * 
	 */
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x28
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x26
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x26
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x26
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x25
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x25
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x25
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x25
type PlayEntityRelativeMove_404_0 struct {
	EntityID VarInt // VarInt
	/* Change in X position as (currentX * 32 - prevX * 32) * 128 */
	DeltaX Short // Short
	/* Change in Y position as (currentY * 32 - prevY * 32) * 128 */
	DeltaY Short // Short
	/* Change in Z position as (currentZ * 32 - prevZ * 32) * 128 */
	DeltaZ Short // Short
	OnGround Bool // Boolean
}

var _ Packet = (*PlayEntityRelativeMove_404_0)(nil)

func (p PlayEntityRelativeMove_404_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Short(p.DeltaX)
	b.Short(p.DeltaY)
	b.Short(p.DeltaZ)
	b.Bool(p.OnGround)
}

func (p *PlayEntityRelativeMove_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.DeltaX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.DeltaY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.DeltaZ, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x2b
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x2b
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x2b
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x2b
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x29
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x29
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x2b
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x2a
type PlayEntityRotation_758_0 struct {
	EntityID VarInt // VarInt
	/* New angle, not a delta */
	Yaw Angle // Angle
	/* New angle, not a delta */
	Pitch Angle // Angle
	OnGround Bool // Boolean
}

var _ Packet = (*PlayEntityRotation_758_0)(nil)

func (p PlayEntityRotation_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlayEntityRotation_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x61
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x61
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x5d
type PlayEntitySoundEffect_763_0 struct {
	/* Represents the Sound ID + 1. If the value is 0, the packet contains a sound specified by Identifier. */
	SoundID VarInt // VarInt
	/* Only present if Sound ID is 0 */
	SoundName Optional[String] // Optional Identifier
	/* Only present if Sound ID is 0. */
	HasFixedRange Optional[Bool] // Optional Boolean
	/* The fixed range of the sound. Only present if previous boolean is true and Sound ID is 0. */
	Range Optional[Float] // Optional Float
	/* The category that this sound will be played from (current categories). */
	SoundCategory VarInt // VarInt Enum
	EntityID VarInt // VarInt
	/* 1.0 is 100%, capped between 0.0 and 1.0 by Notchian clients. */
	Volume Float // Float
	/* Float between 0.5 and 2.0 by Notchian clients. */
	Pitch Float // Float
	/* Seed used to pick sound variant. */
	Seed Long // Long
}

var _ Packet = (*PlayEntitySoundEffect_763_0)(nil)

func (p PlayEntitySoundEffect_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.SoundID)
	if p.SoundID == 0 {
		b.String(p.SoundName.Assert())
		p.HasFixedRange.Set(p.Range.Ok)
		b.Bool(p.HasFixedRange.V)
		if p.Range.Ok {
			b.Float(p.Range.V)
		}
	}
	b.VarInt(p.SoundCategory)
	b.VarInt(p.EntityID)
	b.Float(p.Volume)
	b.Float(p.Pitch)
	b.Long(p.Seed)
}

func (p *PlayEntitySoundEffect_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SoundID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.SoundName.Ok = p.SoundID == 0; p.SoundName.Ok {
		if p.SoundName.V, ok = r.String(); !ok {
			return io.EOF
		}
	}
	if p.HasFixedRange.Ok = p.SoundID == 0; p.HasFixedRange.Ok {
		if p.HasFixedRange.V, ok = r.Bool(); !ok {
			return io.EOF
		}
	}
	if p.Range.Ok = p.SoundID == 0 && p.HasFixedRange.V; p.Range.Ok {
		if p.Range.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.SoundCategory, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Volume, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Seed, ok = r.Long(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x5f
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x5c
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x5c
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x5c
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x5b
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x5b
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x50
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x50
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x51
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x50
type PlayEntitySoundEffect_760_1 struct {
	/* ID of hardcoded sound event (events as of 1.14.4) */
	SoundID VarInt // VarInt
	/* The category that this sound will be played from (current categories) */
	SoundCategory VarInt // VarInt Enum
	EntityID VarInt // VarInt
	/* 1.0 is 100%, capped between 0.0 and 1.0 by Notchian clients */
	Volume Float // Float
	/* Float between 0.5 and 2.0 by Notchian clients */
	Pitch Float // Float
}

var _ Packet = (*PlayEntitySoundEffect_760_1)(nil)

func (p PlayEntitySoundEffect_760_1)Encode(b *PacketBuilder){
	b.VarInt(p.SoundID)
	b.VarInt(p.SoundCategory)
	b.VarInt(p.EntityID)
	b.Float(p.Volume)
	b.Float(p.Pitch)
}

func (p *PlayEntitySoundEffect_760_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SoundID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.SoundCategory, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Volume, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x1b
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x1b
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x1b
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x1b
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x1a
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x1a
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x1c
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x1b
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x1c
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x1b
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x1b
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x1b
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x1b
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x1b
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x1b
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x1b
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x1a
type PlayEntityStatus_758_0 struct {
	EntityID Int // Int
	/* See below */
	EntityStatus Byte // Byte Enum
}

var _ Packet = (*PlayEntityStatus_758_0)(nil)

func (p PlayEntityStatus_758_0)Encode(b *PacketBuilder){
	b.Int(p.EntityID)
	b.Byte(p.EntityStatus)
}

func (p *PlayEntityStatus_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.EntityStatus, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x62
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x62
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x61
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x61
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x56
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x56
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x57
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x56
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x50
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x4c
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x4c
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x4b
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x49
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x49
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x49
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x49
type PlayEntityTeleport_758_0 struct {
	EntityID VarInt // VarInt
	X Double // Double
	Y Double // Double
	Z Double // Double
	/* New angle, not a delta */
	Yaw Angle // Angle
	/* New angle, not a delta */
	Pitch Angle // Angle
	OnGround Bool // Boolean
}

var _ Packet = (*PlayEntityTeleport_758_0)(nil)

func (p PlayEntityTeleport_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlayEntityTeleport_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x4f
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x4f
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x4f
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x4f
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x46
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x46
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x46
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x45
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x41
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x3e
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x3e
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x3d
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x3b
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x3b
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x3b
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x3b
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x12
type PlayEntityVelocity_758_0 struct {
	EntityID VarInt // VarInt
	/* Velocity on the X axis */
	VelocityX Short // Short
	/* Velocity on the Y axis */
	VelocityY Short // Short
	/* Velocity on the Z axis */
	VelocityZ Short // Short
}

var _ Packet = (*PlayEntityVelocity_758_0)(nil)

func (p PlayEntityVelocity_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Short(p.VelocityX)
	b.Short(p.VelocityY)
	b.Short(p.VelocityZ)
}

func (p *PlayEntityVelocity_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.VelocityX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityZ, ok = r.Short(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x1d
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x1d
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x1a
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x19
type PlayExplosion_763_0 struct {
	X Double // Double
	Y Double // Double
	Z Double // Double
	/* A strength greater than or equal to 2.0 spawns a minecraft:explosion_emitter particle, while a lesser strength spawns a minecraft:explosion particle. */
	Strength Float // Float
	/* Number of elements in the following array. */
	RecordCount VarInt // VarInt
	/* Each record is 3 signed bytes long; the 3 bytes are the XYZ (respectively) signed offsets of affected blocks. */
	Records [][3]Byte // Array of (Byte, Byte, Byte)
	/* X velocity of the player being pushed by the explosion. */
	PlayerMotionX Float // Float
	/* Y velocity of the player being pushed by the explosion. */
	PlayerMotionY Float // Float
	/* Z velocity of the player being pushed by the explosion. */
	PlayerMotionZ Float // Float
}

var _ Packet = (*PlayExplosion_763_0)(nil)

func (p PlayExplosion_763_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.Float(p.Strength)
	p.RecordCount = (VarInt)(len(p.Records))
	b.VarInt(p.RecordCount)
	for _, v := range p.Records {
		b.Byte(v[0]).Byte(v[1]).Byte(v[2])
	}
	b.Float(p.PlayerMotionX)
	b.Float(p.PlayerMotionY)
	b.Float(p.PlayerMotionZ)
}

func (p *PlayExplosion_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Strength, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.RecordCount, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Records = make([][3]Byte, p.RecordCount)
	for i, _ := range p.Records {
		if p.Records[i][0], ok = r.Byte(); !ok {
			return io.EOF
		}
		if p.Records[i][1], ok = r.Byte(); !ok {
			return io.EOF
		}
		if p.Records[i][2], ok = r.Byte(); !ok {
			return io.EOF
		}
	}
	if p.PlayerMotionX, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.PlayerMotionY, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.PlayerMotionZ, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x1b
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x1c
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x1c
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x1c
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x1c
type PlayExplosion_760_1 struct {
	X Float // Float
	Y Float // Float
	Z Float // Float
	/* A strength greater than or equal to 2.0 spawns a minecraft:explosion_emitter particle, while a lesser strength spawns a minecraft:explosion particle. */
	Strength Float // Float
	/* Number of elements in the following array. */
	RecordCount VarInt // VarInt
	/* Each record is 3 signed bytes long; the 3 bytes are the XYZ (respectively) signed offsets of affected blocks. */
	Records [][3]Byte // Array of (Byte, Byte, Byte)
	/* X velocity of the player being pushed by the explosion. */
	PlayerMotionX Float // Float
	/* Y velocity of the player being pushed by the explosion. */
	PlayerMotionY Float // Float
	/* Z velocity of the player being pushed by the explosion. */
	PlayerMotionZ Float // Float
}

var _ Packet = (*PlayExplosion_760_1)(nil)

func (p PlayExplosion_760_1)Encode(b *PacketBuilder){
	b.Float(p.X)
	b.Float(p.Y)
	b.Float(p.Z)
	b.Float(p.Strength)
	p.RecordCount = (VarInt)(len(p.Records))
	b.VarInt(p.RecordCount)
	for _, v := range p.Records {
		b.Byte(v[0]).Byte(v[1]).Byte(v[2])
	}
	b.Float(p.PlayerMotionX)
	b.Float(p.PlayerMotionY)
	b.Float(p.PlayerMotionZ)
}

func (p *PlayExplosion_760_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Strength, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.RecordCount, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Records = make([][3]Byte, p.RecordCount)
	for i, _ := range p.Records {
		if p.Records[i][0], ok = r.Byte(); !ok {
			return io.EOF
		}
		if p.Records[i][1], ok = r.Byte(); !ok {
			return io.EOF
		}
		if p.Records[i][2], ok = r.Byte(); !ok {
			return io.EOF
		}
	}
	if p.PlayerMotionX, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.PlayerMotionY, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.PlayerMotionZ, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x1b
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x1b
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x1d
type PlayExplosion_754_2 struct {
	X Float // Float
	Y Float // Float
	Z Float // Float
	/* A strength greater than or equal to 2.0 spawns a minecraft:explosion_emitter particle, while a lesser strength spawns a minecraft:explosion particle. */
	Strength Float // Float
	/* Number of elements in the following array */
	RecordCount Int // Int
	/* Each record is 3 signed bytes long; the 3 bytes are the XYZ (respectively) signed offsets of affected blocks. */
	Records [][3]Byte // Array of (Byte, Byte, Byte)
	/* X velocity of the player being pushed by the explosion */
	PlayerMotionX Float // Float
	/* Y velocity of the player being pushed by the explosion */
	PlayerMotionY Float // Float
	/* Z velocity of the player being pushed by the explosion */
	PlayerMotionZ Float // Float
}

var _ Packet = (*PlayExplosion_754_2)(nil)

func (p PlayExplosion_754_2)Encode(b *PacketBuilder){
	b.Float(p.X)
	b.Float(p.Y)
	b.Float(p.Z)
	b.Float(p.Strength)
	p.RecordCount = (Int)(len(p.Records))
	b.Int(p.RecordCount)
	for _, v := range p.Records {
		b.Byte(v[0]).Byte(v[1]).Byte(v[2])
	}
	b.Float(p.PlayerMotionX)
	b.Float(p.PlayerMotionY)
	b.Float(p.PlayerMotionZ)
}

func (p *PlayExplosion_754_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Strength, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.RecordCount, ok = r.Int(); !ok {
		return io.EOF
	}
	p.Records = make([][3]Byte, p.RecordCount)
	for i, _ := range p.Records {
		if p.Records[i][0], ok = r.Byte(); !ok {
			return io.EOF
		}
		if p.Records[i][1], ok = r.Byte(); !ok {
			return io.EOF
		}
		if p.Records[i][2], ok = r.Byte(); !ok {
			return io.EOF
		}
	}
	if p.PlayerMotionX, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.PlayerMotionY, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.PlayerMotionZ, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x1c
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x1e
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x1c
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x1c
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x1c
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x1c
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x1c
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x1c
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x1c
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x27
type PlayExplosion_498_3 struct {
	X Float // Float
	Y Float // Float
	Z Float // Float
	/* Currently unused in the client */
	Radius Float // Float
	/* Number of elements in the following array */
	RecordCount Int // Int
	/* Each record is 3 signed bytes long, each bytes are the XYZ (respectively) offsets of affected blocks. */
	Records [][3]Byte // Array of (Byte, Byte, Byte)
	/* X velocity of the player being pushed by the explosion */
	PlayerMotionX Float // Float
	/* Y velocity of the player being pushed by the explosion */
	PlayerMotionY Float // Float
	/* Z velocity of the player being pushed by the explosion */
	PlayerMotionZ Float // Float
}

var _ Packet = (*PlayExplosion_498_3)(nil)

func (p PlayExplosion_498_3)Encode(b *PacketBuilder){
	b.Float(p.X)
	b.Float(p.Y)
	b.Float(p.Z)
	b.Float(p.Radius)
	p.RecordCount = (Int)(len(p.Records))
	b.Int(p.RecordCount)
	for _, v := range p.Records {
		b.Byte(v[0]).Byte(v[1]).Byte(v[2])
	}
	b.Float(p.PlayerMotionX)
	b.Float(p.PlayerMotionY)
	b.Float(p.PlayerMotionZ)
}

func (p *PlayExplosion_498_3)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Radius, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.RecordCount, ok = r.Int(); !ok {
		return io.EOF
	}
	p.Records = make([][3]Byte, p.RecordCount)
	for i, _ := range p.Records {
		if p.Records[i][0], ok = r.Byte(); !ok {
			return io.EOF
		}
		if p.Records[i][1], ok = r.Byte(); !ok {
			return io.EOF
		}
		if p.Records[i][2], ok = r.Byte(); !ok {
			return io.EOF
		}
	}
	if p.PlayerMotionX, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.PlayerMotionY, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.PlayerMotionZ, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x37
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x37
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x37
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x33
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x33
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x35
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x34
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x31
type PlayFacePlayer_757_0 struct {
	/* Values are feet=0, eyes=1.  If set to eyes, aims using the head position; otherwise aims using the feet position. */
	FeetOrEyes VarInt // VarInt enum
	/* x coordinate of the point to face towards */
	TargetX Double // Double
	/* y coordinate of the point to face towards */
	TargetY Double // Double
	/* z coordinate of the point to face towards */
	TargetZ Double // Double
	/* If true, additional information about an entity is provided. */
	IsEntity Bool // Boolean
	/* Only if is entity is true — the entity to face towards */
	EntityID Optional[VarInt] // Optional VarInt
	/* Whether to look at the entity's eyes or feet.  Same values and meanings as before, just for the entity's head/feet. */
	EntityFeetOrEyes Optional[VarInt] // Optional VarInt enum
}

var _ Packet = (*PlayFacePlayer_757_0)(nil)

func (p PlayFacePlayer_757_0)Encode(b *PacketBuilder){
	b.VarInt(p.FeetOrEyes)
	b.Double(p.TargetX)
	b.Double(p.TargetY)
	b.Double(p.TargetZ)
	b.Bool(p.IsEntity)
	if p.IsEntity {
		b.VarInt(p.EntityID.Assert())
		b.VarInt(p.EntityFeetOrEyes.Assert())
	}
}

func (p *PlayFacePlayer_757_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.FeetOrEyes, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.TargetX, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.TargetY, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.TargetZ, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.IsEntity, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.EntityID.Ok = p.IsEntity; p.EntityID.Ok {
		if p.EntityID.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.EntityFeetOrEyes.Ok = p.IsEntity; p.EntityFeetOrEyes.Ok {
		if p.EntityFeetOrEyes.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x6b
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x6b
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x67
type PlayFeatureFlags_763_0 struct {
	/* Number of features that appear in the array below. */
	TotalFeatures VarInt // VarInt
	FeatureFlags []String // Identifier Array
}

var _ Packet = (*PlayFeatureFlags_763_0)(nil)

func (p PlayFeatureFlags_763_0)Encode(b *PacketBuilder){
	p.TotalFeatures = (VarInt)(len(p.FeatureFlags))
	b.VarInt(p.TotalFeatures)
	for _, v := range p.FeatureFlags {
		b.String(v)
	}
}

func (p *PlayFeatureFlags_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TotalFeatures, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.FeatureFlags = make([]String, p.TotalFeatures)
	for i, _ := range p.FeatureFlags {
		if p.FeatureFlags[i], ok = r.String(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x1f
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x1f
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x1c
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x1d
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x1b
type PlayGameEvent_763_0 struct {
	/* See below. */
	Event UByte // Unsigned Byte
	/* Depends on Event. */
	Value Float // Float
}

var _ Packet = (*PlayGameEvent_763_0)(nil)

func (p PlayGameEvent_763_0)Encode(b *PacketBuilder){
	b.UByte(p.Event)
	b.Float(p.Value)
}

func (p *PlayGameEvent_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Event, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Value, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0xe
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0xe
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0xe
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0xe
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0xf
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0xf
type PlayGenerateStructure_758_0 struct {
	/* Block entity location */
	Location Position // Position
	/* Value of the levels slider/max depth to generate */
	Levels VarInt // VarInt
	KeepJigsaws Bool // Boolean
}

var _ Packet = (*PlayGenerateStructure_758_0)(nil)

func (p PlayGenerateStructure_758_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.VarInt(p.Levels)
	b.Bool(p.KeepJigsaws)
}

func (p *PlayGenerateStructure_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Levels, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.KeepJigsaws, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x48
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x48
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x48
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x48
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x3f
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x3f
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x40
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x3f
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x3d
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x3a
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x3a
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x39
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x37
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x37
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x37
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x37
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x9
type PlayHeldItemChange_758_0 struct {
	/* The slot which the player has selected (0–8) */
	Slot Byte // Byte
}

var _ Packet = (*PlayHeldItemChange_758_0)(nil)

func (p PlayHeldItemChange_758_0)Encode(b *PacketBuilder){
	b.Byte(p.Slot)
}

func (p *PlayHeldItemChange_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Slot, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x25
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x25
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x25
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x25
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x25
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x25
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x23
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x23
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x21
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x1a
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x1a
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x1a
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x17
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x17
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x17
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x17
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x9
type PlayHeldItemChangeServer_758_0 struct {
	/* The slot which the player has selected (0–8) */
	Slot Short // Short
}

var _ Packet = (*PlayHeldItemChangeServer_758_0)(nil)

func (p PlayHeldItemChangeServer_758_0)Encode(b *PacketBuilder){
	b.Short(p.Slot)
}

func (p *PlayHeldItemChangeServer_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Slot, ok = r.Short(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x21
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x21
type PlayHurtAnimation_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name | Field Type | Field Type | Notes                                                             |
	 * |-----------|-------|----------|------------|------------|------------|------------|-------------------------------------------------------------------|
	 * | 0x21      | Play  | Client   |            |            |            |            |                                                                   |
	 * | 0x21      | Play  | Client   | Entity ID  | Entity ID  | VarInt     | VarInt     | The ID of the entity taking damage                                |
	 * | 0x21      | Play  | Client   | Yaw        | Yaw        | Float      | Float      | The direction the damage is coming from in relation to the entity |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x22
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x22
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x1e
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x1f
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x1d
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x20
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x20
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x20
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x20
type PlayInitializeWorldBorder_763_0 struct {
	X Double // Double
	Z Double // Double
	/* Current length of a single side of the world border, in meters. */
	OldDiameter Double // Double
	/* Target length of a single side of the world border, in meters. */
	NewDiameter Double // Double
	/* Number of real-time milliseconds until New Diameter is reached. It appears that Notchian server does not sync world border speed to game ticks, so it gets out of sync with server lag. If the world border is not moving, this is set to 0. */
	Speed VarLong // VarLong
	/* Resulting coordinates from a portal teleport are limited to ±value. Usually 29999984. */
	PortalTeleportBoundary VarInt // VarInt
	/* In meters. */
	WarningBlocks VarInt // VarInt
	/* In seconds as set by /worldborder warning time. */
	WarningTime VarInt // VarInt
}

var _ Packet = (*PlayInitializeWorldBorder_763_0)(nil)

func (p PlayInitializeWorldBorder_763_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.Z)
	b.Double(p.OldDiameter)
	b.Double(p.NewDiameter)
	b.VarLong(p.Speed)
	b.VarInt(p.PortalTeleportBoundary)
	b.VarInt(p.WarningBlocks)
	b.VarInt(p.WarningTime)
}

func (p *PlayInitializeWorldBorder_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.OldDiameter, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.NewDiameter, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Speed, ok = r.VarLong(); !ok {
		return io.EOF
	}
	if p.PortalTeleportBoundary, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.WarningBlocks, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.WarningTime, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x10
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x10
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0xf
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x10
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0xf
type PlayInteract_763_0 struct {
	/* The ID of the entity to interact. */
	EntityID VarInt // VarInt
	/* 0: interact, 1: attack, 2: interact at. */
	Type VarInt // VarInt Enum
	/* Only if Type is interact at. */
	TargetX Optional[Float] // Optional Float
	/* Only if Type is interact at. */
	TargetY Optional[Float] // Optional Float
	/* Only if Type is interact at. */
	TargetZ Optional[Float] // Optional Float
	/* Only if Type is interact or interact at; 0: main hand, 1: off hand. */
	Hand Optional[VarInt] // Optional VarInt Enum
	/* If the client is sneaking. */
	Sneaking Bool // Boolean
}

var _ Packet = (*PlayInteract_763_0)(nil)

func (p PlayInteract_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.VarInt(p.Type)
	if p.Type == 2 {
		b.Float(p.TargetX.Assert())
	}
	if p.Type == 2 {
		b.Float(p.TargetY.Assert())
	}
	if p.Type == 2 {
		b.Float(p.TargetZ.Assert())
	}
	if p.Type == 0 || p.Type == 2 {
		b.VarInt(p.Hand.Assert())
	}
	b.Bool(p.Sneaking)
}

func (p *PlayInteract_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Type, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.TargetX.Ok = p.Type == 2; p.TargetX.Ok {
		if p.TargetX.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.TargetY.Ok = p.Type == 2; p.TargetY.Ok {
		if p.TargetY.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.TargetZ.Ok = p.Type == 2; p.TargetZ.Ok {
		if p.TargetZ.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.Hand.Ok = p.Type == 0 || p.Type == 2; p.Hand.Ok {
		if p.Hand.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.Sneaking, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0xd
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0xd
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0xd
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0xd
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0xe
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0xe
type PlayInteractEntity_758_0 struct {
	/* The ID of the entity to interact */
	EntityID VarInt // VarInt
	/* 0: interact, 1: attack, 2: interact at */
	Type VarInt // VarInt Enum
	/* Only if Type is interact at */
	TargetX Optional[Float] // Optional Float
	/* Only if Type is interact at */
	TargetY Optional[Float] // Optional Float
	/* Only if Type is interact at */
	TargetZ Optional[Float] // Optional Float
	/* Only if Type is interact or interact at; 0: main hand, 1: off hand */
	Hand Optional[VarInt] // Optional VarInt Enum
	/* If the client is sneaking. */
	Sneaking Bool // Boolean
}

var _ Packet = (*PlayInteractEntity_758_0)(nil)

func (p PlayInteractEntity_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.VarInt(p.Type)
	if p.Type == 2 {
		b.Float(p.TargetX.Assert())
	}
	if p.Type == 2 {
		b.Float(p.TargetY.Assert())
	}
	if p.Type == 2 {
		b.Float(p.TargetZ.Assert())
	}
	if p.Type == 0 || p.Type == 2 {
		b.VarInt(p.Hand.Assert())
	}
	b.Bool(p.Sneaking)
}

func (p *PlayInteractEntity_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Type, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.TargetX.Ok = p.Type == 2; p.TargetX.Ok {
		if p.TargetX.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.TargetY.Ok = p.Type == 2; p.TargetY.Ok {
		if p.TargetY.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.TargetZ.Ok = p.Type == 2; p.TargetZ.Ok {
		if p.TargetZ.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.Hand.Ok = p.Type == 0 || p.Type == 2; p.Hand.Ok {
		if p.Hand.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.Sneaking, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0xe
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0xe
type PlayInteractEntity_578_1 struct {
	/* The ID of the entity to interact */
	EntityID VarInt // VarInt
	/* 0: interact, 1: attack, 2: interact at */
	Type VarInt // VarInt Enum
	/* Only if Type is interact at */
	TargetX Optional[Float] // Optional Float
	/* Only if Type is interact at */
	TargetY Optional[Float] // Optional Float
	/* Only if Type is interact at */
	TargetZ Optional[Float] // Optional Float
	/* Only if Type is interact or interact at; 0: main hand, 1: off hand */
	Hand Optional[VarInt] // Optional VarInt Enum
}

var _ Packet = (*PlayInteractEntity_578_1)(nil)

func (p PlayInteractEntity_578_1)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.VarInt(p.Type)
	if p.Type == 2 {
		b.Float(p.TargetX.Assert())
	}
	if p.Type == 2 {
		b.Float(p.TargetY.Assert())
	}
	if p.Type == 2 {
		b.Float(p.TargetZ.Assert())
	}
	if p.Type == 0 || p.Type == 2 {
		b.VarInt(p.Hand.Assert())
	}
}

func (p *PlayInteractEntity_578_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Type, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.TargetX.Ok = p.Type == 2; p.TargetX.Ok {
		if p.TargetX.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.TargetY.Ok = p.Type == 2; p.TargetY.Ok {
		if p.TargetY.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.TargetZ.Ok = p.Type == 2; p.TargetZ.Ok {
		if p.TargetZ.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.Hand.Ok = p.Type == 0 || p.Type == 2; p.Hand.Ok {
		if p.Hand.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x11
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x11
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x10
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x11
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x10
type PlayJigsawGenerate_763_0 struct {
	/* Block entity location. */
	Location Position // Position
	/* Value of the levels slider/max depth to generate. */
	Levels VarInt // VarInt
	KeepJigsaws Bool // Boolean
}

var _ Packet = (*PlayJigsawGenerate_763_0)(nil)

func (p PlayJigsawGenerate_763_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.VarInt(p.Levels)
	b.Bool(p.KeepJigsaws)
}

func (p *PlayJigsawGenerate_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Levels, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.KeepJigsaws, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x26
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x26
type PlayJoinGame_758_0 struct {
	/* The player's Entity ID (EID). */
	EntityID Int // Int
	IsHardcore Bool // Boolean
	/* 0: Survival, 1: Creative, 2: Adventure, 3: Spectator. */
	Gamemode UByte // Unsigned Byte
	/* 0: survival, 1: creative, 2: adventure, 3: spectator. The hardcore flag is not included. The previous gamemode. Defaults to -1 if there is no previous gamemode. (More information needed) */
	PreviousGamemode Byte // Byte
	/* Size of the following array. */
	WorldCount VarInt // VarInt
	/* Identifiers for all dimensions on the server. */
	DimensionNames []String // Array of Identifier
	/* The full extent of these is still unknown, but the tag represents a dimension and biome registry. See below for the vanilla default. */
	DimensionCodec *nbt.NBTCompound // NBT Tag Compound
	/* Valid dimensions are defined per dimension registry sent before this. The structure of this tag is a dimension type (see below). */
	Dimension *nbt.NBTCompound // NBT Tag Compound
	/* Name of the dimension being spawned into. */
	DimensionName String // Identifier
	/* First 8 bytes of the SHA-256 hash of the world's seed. Used client side for biome noise */
	HashedSeed Long // Long
	/* Was once used by the client to draw the player list, but now is ignored. */
	MaxPlayers VarInt // VarInt
	/* Render distance (2-32). */
	ViewDistance VarInt // VarInt
	/* The distance that the client will process specific things, such as entities. */
	SimulationDistance VarInt // VarInt
	/* If true, a Notchian client shows reduced information on the debug screen.  For servers in development, this should almost always be false. */
	ReducedDebugInfo Bool // Boolean
	/* Set to false when the doImmediateRespawn gamerule is true. */
	EnableRespawnScreen Bool // Boolean
	/* True if the world is a debug mode world; debug mode worlds cannot be modified and have predefined blocks. */
	IsDebug Bool // Boolean
	/* True if the world is a superflat world; flat worlds have different void fog and a horizon at y=0 instead of y=63. */
	IsFlat Bool // Boolean
}

var _ Packet = (*PlayJoinGame_758_0)(nil)

func (p PlayJoinGame_758_0)Encode(b *PacketBuilder){
	b.Int(p.EntityID)
	b.Bool(p.IsHardcore)
	b.UByte(p.Gamemode)
	b.Byte(p.PreviousGamemode)
	b.VarInt(p.WorldCount)
	for _, v := range p.DimensionNames {
		b.String(v)
	}
	p.DimensionCodec.Encode(b)
	p.Dimension.Encode(b)
	b.String(p.DimensionName)
	b.Long(p.HashedSeed)
	b.VarInt(p.MaxPlayers)
	b.VarInt(p.ViewDistance)
	b.VarInt(p.SimulationDistance)
	b.Bool(p.ReducedDebugInfo)
	b.Bool(p.EnableRespawnScreen)
	b.Bool(p.IsDebug)
	b.Bool(p.IsFlat)
}

func (p *PlayJoinGame_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.IsHardcore, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.Gamemode, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.PreviousGamemode, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.WorldCount, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.DimensionNames = make([]String, p.WorldCount)
	for i, _ := range p.DimensionNames {
		if p.DimensionNames[i], ok = r.String(); !ok {
			return io.EOF
		}
	}
	p.DimensionCodec = new(nbt.NBTCompound)
	if err = p.DimensionCodec.DecodeFrom(r); err != nil {
		return err
	}
	p.Dimension = new(nbt.NBTCompound)
	if err = p.Dimension.DecodeFrom(r); err != nil {
		return err
	}
	if p.DimensionName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.HashedSeed, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.MaxPlayers, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ViewDistance, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.SimulationDistance, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ReducedDebugInfo, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.EnableRespawnScreen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.IsDebug, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.IsFlat, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x26
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x26
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x24
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x24
type PlayJoinGame_756_1 struct {
	/* The player's Entity ID (EID) */
	EntityID Int // Int
	IsHardcore Bool // Boolean
	/* 0: Survival, 1: Creative, 2: Adventure, 3: Spectator. */
	Gamemode UByte // Unsigned Byte
	/* 0: survival, 1: creative, 2: adventure, 3: spectator. The hardcore flag is not included. The previous gamemode. Defaults to -1 if there is no previous gamemode. (More information needed) */
	PreviousGamemode Byte // Byte
	/* Size of the following array */
	WorldCount VarInt // VarInt
	/* Identifiers for all worlds on the server */
	WorldNames []String // Array of Identifier
	/* The full extent of these is still unknown, but the tag represents a dimension and biome registry. See below for the vanilla default. */
	DimensionCodec *nbt.NBTCompound // NBT Tag Compound
	/* Valid dimensions are defined per dimension registry sent before this */
	Dimension *nbt.NBTCompound // NBT Tag Compound
	/* Name of the world being spawned into */
	WorldName String // Identifier
	/* First 8 bytes of the SHA-256 hash of the world's seed. */
	HashedSeed Long // Long
	/* Was once used by the client to draw the player list, but now is ignored */
	MaxPlayers VarInt // VarInt
	/* Render distance (2-32) */
	ViewDistance VarInt // VarInt
	/* If true, a Notchian client shows reduced information on the debug screen.  For servers in development, this should almost always be false. */
	ReducedDebugInfo Bool // Boolean
	/* Set to false when the doImmediateRespawn gamerule is true */
	EnableRespawnScreen Bool // Boolean
	/* True if the world is a debug mode world; debug mode worlds cannot be modified and have predefined blocks */
	IsDebug Bool // Boolean
	/* True if the world is a superflat world; flat worlds have different void fog and a horizon at y=0 instead of y=63 */
	IsFlat Bool // Boolean
}

var _ Packet = (*PlayJoinGame_756_1)(nil)

func (p PlayJoinGame_756_1)Encode(b *PacketBuilder){
	b.Int(p.EntityID)
	b.Bool(p.IsHardcore)
	b.UByte(p.Gamemode)
	b.Byte(p.PreviousGamemode)
	p.WorldCount = (VarInt)(len(p.WorldNames))
	b.VarInt(p.WorldCount)
	for _, v := range p.WorldNames {
		b.String(v)
	}
	p.DimensionCodec.Encode(b)
	p.Dimension.Encode(b)
	b.String(p.WorldName)
	b.Long(p.HashedSeed)
	b.VarInt(p.MaxPlayers)
	b.VarInt(p.ViewDistance)
	b.Bool(p.ReducedDebugInfo)
	b.Bool(p.EnableRespawnScreen)
	b.Bool(p.IsDebug)
	b.Bool(p.IsFlat)
}

func (p *PlayJoinGame_756_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.IsHardcore, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.Gamemode, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.PreviousGamemode, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.WorldCount, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.WorldNames = make([]String, p.WorldCount)
	for i, _ := range p.WorldNames {
		if p.WorldNames[i], ok = r.String(); !ok {
			return io.EOF
		}
	}
	p.DimensionCodec = new(nbt.NBTCompound)
	if err = p.DimensionCodec.DecodeFrom(r); err != nil {
		return err
	}
	p.Dimension = new(nbt.NBTCompound)
	if err = p.Dimension.DecodeFrom(r); err != nil {
		return err
	}
	if p.WorldName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.HashedSeed, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.MaxPlayers, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ViewDistance, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ReducedDebugInfo, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.EnableRespawnScreen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.IsDebug, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.IsFlat, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x25
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x23
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x23
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x23
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x23
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x23
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x23
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x23
type PlayJoinGame_404_4 struct {
	/* The player's Entity ID (EID) */
	EntityID Int // Int
	/* 0: Survival, 1: Creative, 2: Adventure, 3: Spectator. Bit 3 (0x8) is the hardcore flag. */
	Gamemode UByte // Unsigned Byte
	/* -1: Nether, 0: Overworld, 1: End; also, note that this is not a VarInt but instead a regular int. */
	Dimension Int // Int Enum
	/* 0: peaceful, 1: easy, 2: normal, 3: hard */
	Difficulty UByte // Unsigned Byte
	/* Was once used by the client to draw the player list, but now is ignored */
	MaxPlayers UByte // Unsigned Byte
	/* default, flat, largeBiomes, amplified, default_1_1 */
	LevelType String // String Enum (16)
	/* If true, a Notchian client shows reduced information on the debug screen.  For servers in development, this should almost always be false. */
	ReducedDebugInfo Bool // Boolean
}

var _ Packet = (*PlayJoinGame_404_4)(nil)

func (p PlayJoinGame_404_4)Encode(b *PacketBuilder){
	b.Int(p.EntityID)
	b.UByte(p.Gamemode)
	b.Int(p.Dimension)
	b.UByte(p.Difficulty)
	b.UByte(p.MaxPlayers)
	b.String(p.LevelType)
	b.Bool(p.ReducedDebugInfo)
}

func (p *PlayJoinGame_404_4)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.Gamemode, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Dimension, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.Difficulty, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.MaxPlayers, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.LevelType, ok = r.String(); !ok {
		return io.EOF
	}
	if p.ReducedDebugInfo, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x23
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x23
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x1f
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x20
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x1e
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x21
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x21
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x21
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x21
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x1f
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x1f
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x21
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x20
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x21
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x1f
type PlayKeepAlive_763_0 struct {
	KeepAliveID Long // Long
}

var _ Packet = (*PlayKeepAlive_763_0)(nil)

func (p PlayKeepAlive_763_0)Encode(b *PacketBuilder){
	b.Long(p.KeepAliveID)
}

func (p *PlayKeepAlive_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.KeepAliveID, ok = r.Long(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x1f
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x1f
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x1f
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x1f
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x1f
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x1f
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x0
type PlayKeepAlive_338_1 struct {
	KeepAliveID VarInt // VarInt
}

var _ Packet = (*PlayKeepAlive_338_1)(nil)

func (p PlayKeepAlive_338_1)Encode(b *PacketBuilder){
	b.VarInt(p.KeepAliveID)
}

func (p *PlayKeepAlive_338_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.KeepAliveID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x12
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x12
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x11
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x12
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x11
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0xf
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0xf
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0xf
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0xf
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x10
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x10
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0xf
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0xf
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0xe
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0xb
type PlayKeepAliveServer_763_0 struct {
	KeepAliveID Long // Long
}

var _ Packet = (*PlayKeepAliveServer_763_0)(nil)

func (p PlayKeepAliveServer_763_0)Encode(b *PacketBuilder){
	b.Long(p.KeepAliveID)
}

func (p *PlayKeepAliveServer_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.KeepAliveID, ok = r.Long(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0xb
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0xc
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0xb
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0xb
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0xb
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0xb
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x0
type PlayKeepAliveServer_338_1 struct {
	KeepAliveID VarInt // VarInt
}

var _ Packet = (*PlayKeepAliveServer_338_1)(nil)

func (p PlayKeepAliveServer_338_1)Encode(b *PacketBuilder){
	b.VarInt(p.KeepAliveID)
}

func (p *PlayKeepAliveServer_338_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.KeepAliveID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x53
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x53
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x4f
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x51
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x4e
type PlayLinkEntities_763_0 struct {
	/* Attached entity's EID. */
	AttachedEntityID Int // Int
	/* ID of the entity holding the lead. Set to -1 to detach. */
	HoldingEntityID Int // Int
}

var _ Packet = (*PlayLinkEntities_763_0)(nil)

func (p PlayLinkEntities_763_0)Encode(b *PacketBuilder){
	b.Int(p.AttachedEntityID)
	b.Int(p.HoldingEntityID)
}

func (p *PlayLinkEntities_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.AttachedEntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.HoldingEntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x13
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x13
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x12
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x13
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x12
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x10
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x10
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x10
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x10
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x11
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x11
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x10
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x10
type PlayLockDifficulty_763_0 struct {
	Locked Bool // Boolean
}

var _ Packet = (*PlayLockDifficulty_763_0)(nil)

func (p PlayLockDifficulty_763_0)Encode(b *PacketBuilder){
	b.Bool(p.Locked)
}

func (p *PlayLockDifficulty_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Locked, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x25
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x23
type PlayLogin_760_3 struct {
	/* The player's Entity ID (EID). */
	EntityID Int // Int
	IsHardcore Bool // Boolean
	/* 0: Survival, 1: Creative, 2: Adventure, 3: Spectator. */
	Gamemode UByte // Unsigned Byte
	/* 0: survival, 1: creative, 2: adventure, 3: spectator. The hardcore flag is not included. The previous gamemode. Defaults to -1 if there is no previous gamemode. (More information needed) */
	PreviousGamemode Byte // Byte
	/* Size of the following array. */
	DimensionCount VarInt // VarInt
	/* Identifiers for all dimensions on the server. */
	DimensionNames []String // Array of Identifier
	/* Represents certain registries that are sent from the server and are applied on the client. */
	RegistryCodec *nbt.NBTCompound // NBT Tag Compound
	/* Name of the dimension type being spawned into. */
	DimensionType String // Identifier
	/* Name of the dimension being spawned into. */
	DimensionName String // Identifier
	/* First 8 bytes of the SHA-256 hash of the world's seed. Used client side for biome noise */
	HashedSeed Long // Long
	/* Was once used by the client to draw the player list, but now is ignored. */
	MaxPlayers VarInt // VarInt
	/* Render distance (2-32). */
	ViewDistance VarInt // VarInt
	/* The distance that the client will process specific things, such as entities. */
	SimulationDistance VarInt // VarInt
	/* If true, a Notchian client shows reduced information on the debug screen.  For servers in development, this should almost always be false. */
	ReducedDebugInfo Bool // Boolean
	/* Set to false when the doImmediateRespawn gamerule is true. */
	EnableRespawnScreen Bool // Boolean
	/* True if the world is a debug mode world; debug mode worlds cannot be modified and have predefined blocks. */
	IsDebug Bool // Boolean
	/* True if the world is a superflat world; flat worlds have different void fog and a horizon at y=0 instead of y=63. */
	IsFlat Bool // Boolean
	/* If true, then the next two fields are present. */
	HasDeathLocation Bool // Boolean
	/* Name of the dimension the player died in. */
	DeathDimensionName String // Identifier
	/* The location that the player died at. */
	DeathLocation Position // Position
}

var _ Packet = (*PlayLogin_760_3)(nil)

func (p PlayLogin_760_3)Encode(b *PacketBuilder){
	b.Int(p.EntityID)
	b.Bool(p.IsHardcore)
	b.UByte(p.Gamemode)
	b.Byte(p.PreviousGamemode)
	p.DimensionCount = (VarInt)(len(p.DimensionNames))
	b.VarInt(p.DimensionCount)
	for _, v := range p.DimensionNames {
		b.String(v)
	}
	p.RegistryCodec.Encode(b)
	b.String(p.DimensionType)
	b.String(p.DimensionName)
	b.Long(p.HashedSeed)
	b.VarInt(p.MaxPlayers)
	b.VarInt(p.ViewDistance)
	b.VarInt(p.SimulationDistance)
	b.Bool(p.ReducedDebugInfo)
	b.Bool(p.EnableRespawnScreen)
	b.Bool(p.IsDebug)
	b.Bool(p.IsFlat)
	b.Bool(p.HasDeathLocation)
	b.String(p.DeathDimensionName)
	p.DeathLocation.Encode(b)
}

func (p *PlayLogin_760_3)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.IsHardcore, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.Gamemode, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.PreviousGamemode, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.DimensionCount, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.DimensionNames = make([]String, p.DimensionCount)
	for i, _ := range p.DimensionNames {
		if p.DimensionNames[i], ok = r.String(); !ok {
			return io.EOF
		}
	}
	p.RegistryCodec = new(nbt.NBTCompound)
	if err = p.RegistryCodec.DecodeFrom(r); err != nil {
		return err
	}
	if p.DimensionType, ok = r.String(); !ok {
		return io.EOF
	}
	if p.DimensionName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.HashedSeed, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.MaxPlayers, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ViewDistance, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.SimulationDistance, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ReducedDebugInfo, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.EnableRespawnScreen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.IsDebug, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.IsFlat, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.HasDeathLocation, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.DeathDimensionName, ok = r.String(); !ok {
		return io.EOF
	}
	if err = p.DeathLocation.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x3b
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x3b
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x37
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x38
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x35
type PlayLookAt_763_0 struct {
	/* Values are feet=0, eyes=1.  If set to eyes, aims using the head position; otherwise aims using the feet position. */
	FeetOrEyes VarInt // VarInt Enum
	/* x coordinate of the point to face towards. */
	TargetX Double // Double
	/* y coordinate of the point to face towards. */
	TargetY Double // Double
	/* z coordinate of the point to face towards. */
	TargetZ Double // Double
	/* If true, additional information about an entity is provided. */
	IsEntity Bool // Boolean
	/* Only if is entity is true — the entity to face towards. */
	EntityID Optional[VarInt] // Optional VarInt
	/* Whether to look at the entity's eyes or feet.  Same values and meanings as before, just for the entity's head/feet. */
	EntityFeetOrEyes Optional[VarInt] // Optional VarInt Enum
}

var _ Packet = (*PlayLookAt_763_0)(nil)

func (p PlayLookAt_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.FeetOrEyes)
	b.Double(p.TargetX)
	b.Double(p.TargetY)
	b.Double(p.TargetZ)
	b.Bool(p.IsEntity)
	if p.IsEntity {
		b.VarInt(p.EntityID.Assert())
	}
	if p.IsEntity {
		b.VarInt(p.EntityFeetOrEyes.Assert())
	}
}

func (p *PlayLookAt_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.FeetOrEyes, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.TargetX, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.TargetY, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.TargetZ, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.IsEntity, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.EntityID.Ok = p.IsEntity; p.EntityID.Ok {
		if p.EntityID.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.EntityFeetOrEyes.Ok = p.IsEntity; p.EntityFeetOrEyes.Ok {
		if p.EntityFeetOrEyes.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x24
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x24
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x24
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x24
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x24
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x24
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x24
type PlayMap_340_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name        | Field Name         | Field Type                      | Field Type                      | Notes                                                                                                      |
	 * |-----------|-------|----------|-------------------|--------------------|---------------------------------|---------------------------------|------------------------------------------------------------------------------------------------------------|
	 * | 0x24      | Play  | Client   | Item Damage       | Item Damage        | VarInt                          | VarInt                          | The damage value (map ID) of the map being modified                                                        |
	 * | 0x24      | Play  | Client   | Scale             | Scale              | Byte                            | Byte                            | From 0 for a fully zoomed-in map (1 block per pixel) to 4 for a fully zoomed-out map (16 blocks per pixel) |
	 * | 0x24      | Play  | Client   | Tracking Position | Tracking Position  | Boolean                         | Boolean                         | Specifies whether the icons are shown                                                                      |
	 * | 0x24      | Play  | Client   | Icon Count        | Icon Count         | VarInt                          | VarInt                          | Number of elements in the following array                                                                  |
	 * | 0x24      | Play  | Client   | Icon              | Direction And Type | Array                           | Byte                            | 0xF0 = Type, 0x0F = Direction                                                                              |
	 * | 0x24      | Play  | Client   | Icon              | X                  | Array                           | Byte                            |                                                                                                            |
	 * | 0x24      | Play  | Client   | Icon              | Z                  | Array                           | Byte                            |                                                                                                            |
	 * | 0x24      | Play  | Client   | Columns           | Columns            | Byte                            | Byte                            | Number of columns updated                                                                                  |
	 * | 0x24      | Play  | Client   | Rows              | Rows               | Optional Byte                   | Optional Byte                   | Only if Columns is more than 0; number of rows updated                                                     |
	 * | 0x24      | Play  | Client   | X                 | X                  | Optional Byte                   | Optional Byte                   | Only if Columns is more than 0; x offset of the westernmost column                                         |
	 * | 0x24      | Play  | Client   | Z                 | Z                  | Optional Byte                   | Optional Byte                   | Only if Columns is more than 0; z offset of the northernmost row                                           |
	 * | 0x24      | Play  | Client   | Length            | Length             | Optional VarInt                 | Optional VarInt                 | Only if Columns is more than 0; length of the following array                                              |
	 * | 0x24      | Play  | Client   | Data              | Data               | Optional Array of Unsigned Byte | Optional Array of Unsigned Byte | Only if Columns is more than 0; see Map item format                                                        |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x29
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x29
type PlayMapData_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name       | Field Type                      | Field Type                      | Notes                                                                                                      |
	 * |-----------|-------|----------|------------|------------------|---------------------------------|---------------------------------|------------------------------------------------------------------------------------------------------------|
	 * | 0x29      | Play  | Client   | Map ID     | Map ID           | VarInt                          | VarInt                          | Map ID of the map being modified                                                                           |
	 * | 0x29      | Play  | Client   | Scale      | Scale            | Byte                            | Byte                            | From 0 for a fully zoomed-in map (1 block per pixel) to 4 for a fully zoomed-out map (16 blocks per pixel) |
	 * | 0x29      | Play  | Client   | Locked     | Locked           | Boolean                         | Boolean                         | True if the map has been locked in a cartography table                                                     |
	 * | 0x29      | Play  | Client   | Has Icons  | Has Icons        | Boolean                         | Boolean                         |                                                                                                            |
	 * | 0x29      | Play  | Client   | Icon Count | Icon Count       | Optional VarInt                 | Optional VarInt                 | Number of elements in the following array. Only present if previous Boolean is true.                       |
	 * | 0x29      | Play  | Client   | Icon       | Type             | Optional Array                  | VarInt Enum                     | See below                                                                                                  |
	 * | 0x29      | Play  | Client   | Icon       | X                | Optional Array                  | Byte                            | Map coordinates: -128 for furthest left, +127 for furthest right                                           |
	 * | 0x29      | Play  | Client   | Icon       | Z                | Optional Array                  | Byte                            | Map coordinates: -128 for highest, +127 for lowest                                                         |
	 * | 0x29      | Play  | Client   | Icon       | Direction        | Optional Array                  | Byte                            | 0-15                                                                                                       |
	 * | 0x29      | Play  | Client   | Icon       | Has Display Name | Optional Array                  | Boolean                         |                                                                                                            |
	 * | 0x29      | Play  | Client   | Icon       | Display Name     | Optional Array                  | Optional Chat                   | Only present if previous Boolean is true                                                                   |
	 * | 0x29      | Play  | Client   | Columns    | Columns          | Unsigned Byte                   | Unsigned Byte                   | Number of columns updated                                                                                  |
	 * | 0x29      | Play  | Client   | Rows       | Rows             | Optional Unsigned Byte          | Optional Unsigned Byte          | Only if Columns is more than 0; number of rows updated                                                     |
	 * | 0x29      | Play  | Client   | X          | X                | Optional Byte                   | Optional Byte                   | Only if Columns is more than 0; x offset of the westernmost column                                         |
	 * | 0x29      | Play  | Client   | Z          | Z                | Optional Byte                   | Optional Byte                   | Only if Columns is more than 0; z offset of the northernmost row                                           |
	 * | 0x29      | Play  | Client   | Length     | Length           | Optional VarInt                 | Optional VarInt                 | Only if Columns is more than 0; length of the following array                                              |
	 * | 0x29      | Play  | Client   | Data       | Data             | Optional Array of Unsigned Byte | Optional Array of Unsigned Byte | Only if Columns is more than 0; see Map item format                                                        |
	 * 
	 */
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x27
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x27
type PlayMapData_758_4 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name        | Field Name        | Field Type                      | Field Type                      | Notes                                                                                                      |
	 * |-----------|-------|----------|-------------------|-------------------|---------------------------------|---------------------------------|------------------------------------------------------------------------------------------------------------|
	 * | 0x27      | Play  | Client   | Map ID            | Map ID            | VarInt                          | VarInt                          | Map ID of the map being modified                                                                           |
	 * | 0x27      | Play  | Client   | Scale             | Scale             | Byte                            | Byte                            | From 0 for a fully zoomed-in map (1 block per pixel) to 4 for a fully zoomed-out map (16 blocks per pixel) |
	 * | 0x27      | Play  | Client   | Locked            | Locked            | Boolean                         | Boolean                         | True if the map has been locked in a cartography table                                                     |
	 * | 0x27      | Play  | Client   | Tracking Position | Tracking Position | Boolean                         | Boolean                         | Specifies whether player and item frame icons are shown                                                    |
	 * | 0x27      | Play  | Client   | Icon Count        | Icon Count        | VarInt                          | VarInt                          | Number of elements in the following array. Only present if "Tracking Position" is true.                    |
	 * | 0x27      | Play  | Client   | Icon              | Type              | Array                           | VarInt enum                     | See below                                                                                                  |
	 * | 0x27      | Play  | Client   | Icon              | X                 | Array                           | Byte                            | Map coordinates: -128 for furthest left, +127 for furthest right                                           |
	 * | 0x27      | Play  | Client   | Icon              | Z                 | Array                           | Byte                            | Map coordinates: -128 for highest, +127 for lowest                                                         |
	 * | 0x27      | Play  | Client   | Icon              | Direction         | Array                           | Byte                            | 0-15                                                                                                       |
	 * | 0x27      | Play  | Client   | Icon              | Has Display Name  | Array                           | Boolean                         |                                                                                                            |
	 * | 0x27      | Play  | Client   | Icon              | Display Name      | Array                           | Optional Chat                   | Only present if previous Boolean is true                                                                   |
	 * | 0x27      | Play  | Client   | Columns           | Columns           | Unsigned Byte                   | Unsigned Byte                   | Number of columns updated                                                                                  |
	 * | 0x27      | Play  | Client   | Rows              | Rows              | Optional Unsigned Byte          | Optional Unsigned Byte          | Only if Columns is more than 0; number of rows updated                                                     |
	 * | 0x27      | Play  | Client   | X                 | X                 | Optional Byte                   | Optional Byte                   | Only if Columns is more than 0; x offset of the westernmost column                                         |
	 * | 0x27      | Play  | Client   | Z                 | Z                 | Optional Byte                   | Optional Byte                   | Only if Columns is more than 0; z offset of the northernmost row                                           |
	 * | 0x27      | Play  | Client   | Length            | Length            | Optional VarInt                 | Optional VarInt                 | Only if Columns is more than 0; length of the following array                                              |
	 * | 0x27      | Play  | Client   | Data              | Data              | Optional Array of Unsigned Byte | Optional Array of Unsigned Byte | Only if Columns is more than 0; see Map item format                                                        |
	 * 
	 */
}

// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x27
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x27
type PlayMapData_756_5 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name        | Field Name        | Field Type                      | Field Type                      | Notes                                                                                                      |
	 * |-----------|-------|----------|-------------------|-------------------|---------------------------------|---------------------------------|------------------------------------------------------------------------------------------------------------|
	 * | 0x27      | Play  | Client   | Map ID            | Map ID            | VarInt                          | VarInt                          | Map ID of the map being modified                                                                           |
	 * | 0x27      | Play  | Client   | Scale             | Scale             | Byte                            | Byte                            | From 0 for a fully zoomed-in map (1 block per pixel) to 4 for a fully zoomed-out map (16 blocks per pixel) |
	 * | 0x27      | Play  | Client   | Locked            | Locked            | Boolean                         | Boolean                         | True if the map has been locked in a cartography table                                                     |
	 * | 0x27      | Play  | Client   | Tracking Position | Tracking Position | Boolean                         | Boolean                         | Specifies whether player and item frame icons are shown                                                    |
	 * | 0x27      | Play  | Client   | Icon Count        | Icon Count        | VarInt                          | VarInt                          | Number of elements in the following array. Only present if "Tracking Position" is true.                    |
	 * | 0x27      | Play  | Client   | Icon              | Type              | Array                           | VarInt enum                     | See below                                                                                                  |
	 * | 0x27      | Play  | Client   | Icon              | X                 | Array                           | Byte                            | Map coordinates: -128 for furthest left, +127 for furthest right                                           |
	 * | 0x27      | Play  | Client   | Icon              | Z                 | Array                           | Byte                            | Map coordinates: -128 for highest, +127 for lowest                                                         |
	 * | 0x27      | Play  | Client   | Icon              | Direction         | Array                           | Byte                            | 0-15                                                                                                       |
	 * | 0x27      | Play  | Client   | Icon              | Has Display Name  | Array                           | Boolean                         |                                                                                                            |
	 * | 0x27      | Play  | Client   | Icon              | Display Name      | Array                           | Optional Chat                   | Only present if previous Boolean is true                                                                   |
	 * | 0x27      | Play  | Client   | Columns           | Columns           | Unsigned Byte                   | Unsigned Byte                   | Number of columns updated                                                                                  |
	 * | 0x27      | Play  | Client   | Rows              | Rows              | Optional Byte                   | Optional Byte                   | Only if Columns is more than 0; number of rows updated                                                     |
	 * | 0x27      | Play  | Client   | X                 | X                 | Optional Byte                   | Optional Byte                   | Only if Columns is more than 0; x offset of the westernmost column                                         |
	 * | 0x27      | Play  | Client   | Z                 | Z                 | Optional Byte                   | Optional Byte                   | Only if Columns is more than 0; z offset of the northernmost row                                           |
	 * | 0x27      | Play  | Client   | Length            | Length            | Optional VarInt                 | Optional VarInt                 | Only if Columns is more than 0; length of the following array                                              |
	 * | 0x27      | Play  | Client   | Data              | Data              | Optional Array of Unsigned Byte | Optional Array of Unsigned Byte | Only if Columns is more than 0; see Map item format                                                        |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x2a
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x2a
type PlayMerchantOffers_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name                   | Field Type | Field Type | Notes                                                                                                                                                                             |
	 * |-----------|-------|----------|---------------------|------------------------------|------------|------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x2A      | Play  | Client   | Window ID           | Window ID                    | VarInt     | VarInt     | The ID of the window that is open; this is an int rather than a byte.                                                                                                             |
	 * | 0x2A      | Play  | Client   | Size                | Size                         | VarInt     | VarInt     | The number of trades in the following array.                                                                                                                                      |
	 * | 0x2A      | Play  | Client   | Trades              | Input item 1                 | Array      | Slot       | The first item the player has to supply for this villager trade. The count of the item stack is the default "price" of this trade.                                                |
	 * | 0x2A      | Play  | Client   | Trades              | Output item                  | Array      | Slot       | The item the player will receive from this villager trade.                                                                                                                        |
	 * | 0x2A      | Play  | Client   | Trades              | Input item 2                 | Array      | Slot       | The second item the player has to supply for this villager trade. May be an empty slot.                                                                                           |
	 * | 0x2A      | Play  | Client   | Trades              | Trade disabled               | Array      | Boolean    | True if the trade is disabled; false if the trade is enabled.                                                                                                                     |
	 * | 0x2A      | Play  | Client   | Trades              | Number of trade uses         | Array      | Int        | Number of times the trade has been used so far. If equal to the maximum number of trades, the client will display a red X.                                                        |
	 * | 0x2A      | Play  | Client   | Trades              | Maximum number of trade uses | Array      | Int        | Number of times this trade can be used before it's exhausted.                                                                                                                     |
	 * | 0x2A      | Play  | Client   | Trades              | XP                           | Array      | Int        | Amount of XP the villager will earn each time the trade is used.                                                                                                                  |
	 * | 0x2A      | Play  | Client   | Trades              | Special Price                | Array      | Int        | Can be zero or negative. The number is added to the price when an item is discounted due to player reputation or other effects.                                                   |
	 * | 0x2A      | Play  | Client   | Trades              | Price Multiplier             | Array      | Float      | Can be low (0.05) or high (0.2). Determines how much demand, player reputation, and temporary effects will adjust the price.                                                      |
	 * | 0x2A      | Play  | Client   | Trades              | Demand                       | Array      | Int        | If positive, causes the price to increase. Negative values seem to be treated the same as zero.                                                                                   |
	 * | 0x2A      | Play  | Client   | Villager level      | Villager level               | VarInt     | VarInt     | Appears on the trade GUI; meaning comes from the translation key merchant.level. + level.
	 * 1: Novice, 2: Apprentice, 3: Journeyman, 4: Expert, 5: Master.                          |
	 * | 0x2A      | Play  | Client   | Experience          | Experience                   | VarInt     | VarInt     | Total experience for this villager (always 0 for the wandering trader).                                                                                                           |
	 * | 0x2A      | Play  | Client   | Is regular villager | Is regular villager          | Boolean    | Boolean    | True if this is a regular villager; false for the wandering trader.  When false, hides the villager level and some other GUI elements.                                            |
	 * | 0x2A      | Play  | Client   | Can restock         | Can restock                  | Boolean    | Boolean    | True for regular villagers and false for the wandering trader. If true, the "Villagers restock up to two times per day." message is displayed when hovering over disabled trades. |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x3
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x3
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x3
type PlayMessageAcknowledgment_763_0 struct {
	MessageCount VarInt // VarInt
}

var _ Packet = (*PlayMessageAcknowledgment_763_0)(nil)

func (p PlayMessageAcknowledgment_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.MessageCount)
}

func (p *PlayMessageAcknowledgment_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.MessageCount, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x2e
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x2e
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x2a
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x2b
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x29
type PlayMoveVehicle_763_0 struct {
	/* Absolute position (X coordinate). */
	X Double // Double
	/* Absolute position (Y coordinate). */
	Y Double // Double
	/* Absolute position (Z coordinate). */
	Z Double // Double
	/* Absolute rotation on the vertical axis, in degrees. */
	Yaw Float // Float
	/* Absolute rotation on the horizontal axis, in degrees. */
	Pitch Float // Float
}

var _ Packet = (*PlayMoveVehicle_763_0)(nil)

func (p PlayMoveVehicle_763_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.Float(p.Yaw)
	b.Float(p.Pitch)
}

func (p *PlayMoveVehicle_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x18
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x18
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x17
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x18
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x17
type PlayMoveVehicleServer_763_0 struct {
	/* Absolute position (X coordinate). */
	X Double // Double
	/* Absolute position (Y coordinate). */
	Y Double // Double
	/* Absolute position (Z coordinate). */
	Z Double // Double
	/* Absolute rotation on the vertical axis, in degrees. */
	Yaw Float // Float
	/* Absolute rotation on the horizontal axis, in degrees. */
	Pitch Float // Float
}

var _ Packet = (*PlayMoveVehicleServer_763_0)(nil)

func (p PlayMoveVehicleServer_763_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.Float(p.Yaw)
	b.Float(p.Pitch)
}

func (p *PlayMoveVehicleServer_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x3f
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x3f
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x3f
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x3f
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x3b
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x3b
type PlayMultiBlockChange_758_0 struct {
	/* Chunk section coordinate (encoded chunk x and z with each 22 bits, and section y with 20 bits, from left to right) */
	ChunkSectionPosition Long // Long
	/* Number of elements in the following array */
	BlocksArraySize VarInt // VarInt
	/* Each entry is composed of the block id, shifted right by 12, and the relative block position in the chunk section (4 bits for x, z, and y, from left to right). */
	Blocks []VarLong // Array of VarLong
}

var _ Packet = (*PlayMultiBlockChange_758_0)(nil)

func (p PlayMultiBlockChange_758_0)Encode(b *PacketBuilder){
	b.Long(p.ChunkSectionPosition)
	p.BlocksArraySize = (VarInt)(len(p.Blocks))
	b.VarInt(p.BlocksArraySize)
	for _, v := range p.Blocks {
		b.VarLong(v)
	}
}

func (p *PlayMultiBlockChange_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ChunkSectionPosition, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.BlocksArraySize, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Blocks = make([]VarLong, p.BlocksArraySize)
	for i, _ := range p.Blocks {
		if p.Blocks[i], ok = r.VarLong(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0xf
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0xf
type PlayMultiBlockChange_498_2 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name   | Field Name          | Field Type | Field Type    | Notes                                                                                                                                                                  |
	 * |-----------|-------|----------|--------------|---------------------|------------|---------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x0F      | Play  | Client   | Chunk X      | Chunk X             | Int        | Int           | Chunk X coordinate                                                                                                                                                     |
	 * | 0x0F      | Play  | Client   | Chunk Z      | Chunk Z             | Int        | Int           | Chunk Z coordinate                                                                                                                                                     |
	 * | 0x0F      | Play  | Client   | Record Count | Record Count        | VarInt     | VarInt        | Number of elements in the following array, i.e. the number of blocks affected                                                                                          |
	 * | 0x0F      | Play  | Client   | Record       | Horizontal Position | Array      | Unsigned Byte | The 4 most significant bits (0xF0) encode the X coordinate, relative to the chunk. The 4 least significant bits (0x0F) encode the Z coordinate, relative to the chunk. |
	 * | 0x0F      | Play  | Client   | Record       | Y Coordinate        | Array      | Unsigned Byte | Y coordinate of the block                                                                                                                                              |
	 * | 0x0F      | Play  | Client   | Record       | Block ID            | Array      | VarInt        | The new block state ID for the block as given in the global palette. See that section for more information.                                                            |
	 * 
	 */
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x10
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x10
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x10
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x10
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x10
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x10
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x10
type PlayMultiBlockChange_340_3 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name   | Field Name          | Field Type | Field Type    | Notes                                                                                                                                                                    |
	 * |-----------|-------|----------|--------------|---------------------|------------|---------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x10      | Play  | Client   | Chunk X      | Chunk X             | Int        | Int           | Chunk X coordinate                                                                                                                                                       |
	 * | 0x10      | Play  | Client   | Chunk Z      | Chunk Z             | Int        | Int           | Chunk Z coordinate                                                                                                                                                       |
	 * | 0x10      | Play  | Client   | Record Count | Record Count        | VarInt     | VarInt        | Number of elements in the following array, i.e. the number of blocks affected                                                                                            |
	 * | 0x10      | Play  | Client   | Record       | Horizontal Position | Array      | Unsigned Byte | The 4 most significant bits (0xF0) encode the X coordinate, relative to the chunk. The 4 least significant bits (0x0F) encode the Z coordinate, relative to the chunk.   |
	 * | 0x10      | Play  | Client   | Record       | Y Coordinate        | Array      | Unsigned Byte | Y coordinate of the block                                                                                                                                                |
	 * | 0x10      | Play  | Client   | Record       | Block ID            | Array      | VarInt        | The new block state ID for the block as given in the global palette (When reading data: type = id >> 4, meta = id & 15, when writing data: id = type << 4 | (meta & 15)) |
	 * 
	 */
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x60
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x60
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x5f
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x5f
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x54
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x54
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x55
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x54
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x1d
type PlayNBTQueryResponse_758_0 struct {
	/* Can be compared to the one sent in the original query packet. */
	TransactionID VarInt // VarInt
	/* The NBT of the block or entity.  May be a TAG_END (0) in which case no NBT is present. */
	NBT nbt.NBT // NBT Tag
}

var _ Packet = (*PlayNBTQueryResponse_758_0)(nil)

func (p PlayNBTQueryResponse_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.TransactionID)
	nbt.WriteNBT(b, p.NBT)
}

func (p *PlayNBTQueryResponse_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TransactionID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.NBT, err = nbt.ReadNBT(r); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x20
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x20
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x20
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x20
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x20
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x20
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x1e
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x1e
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x1c
type PlayNameItem_758_0 struct {
	/* The new name of the item */
	ItemName String // String (32767)
}

var _ Packet = (*PlayNameItem_758_0)(nil)

func (p PlayNameItem_758_0)Encode(b *PacketBuilder){
	b.String(p.ItemName)
}

func (p *PlayNameItem_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ItemName, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x19
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x19
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x19
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x19
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x18
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x18
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x1a
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x19
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x1a
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x19
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x19
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x19
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x19
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x19
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x19
type PlayNamedSoundEffect_758_0 struct {
	/* All sound effect names as of 1.12.2 can be seen here. */
	SoundName String // String (256)
	/* The category that this sound will be played from (current categories) */
	SoundCategory VarInt // VarInt Enum
	/* Effect X multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part) */
	EffectPositionX Int // Int
	/* Effect Y multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part) */
	EffectPositionY Int // Int
	/* Effect Z multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part) */
	EffectPositionZ Int // Int
	/* 1 is 100%, can be more */
	Volume Float // Float
	/* Float between 0.5 and 2.0 by Notchian clients */
	Pitch Float // Float
}

var _ Packet = (*PlayNamedSoundEffect_758_0)(nil)

func (p PlayNamedSoundEffect_758_0)Encode(b *PacketBuilder){
	b.String(p.SoundName)
	b.VarInt(p.SoundCategory)
	b.Int(p.EffectPositionX)
	b.Int(p.EffectPositionY)
	b.Int(p.EffectPositionZ)
	b.Float(p.Volume)
	b.Float(p.Pitch)
}

func (p *PlayNamedSoundEffect_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SoundName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.SoundCategory, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EffectPositionX, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.EffectPositionY, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.EffectPositionZ, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.Volume, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x2f
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x2f
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x2b
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x2c
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x2a
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x2d
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x2d
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x2d
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x2d
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x2c
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x2c
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x2e
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x2d
type PlayOpenBook_763_0 struct {
	/* 0: Main hand, 1: Off hand */
	Hand VarInt // VarInt enum
}

var _ Packet = (*PlayOpenBook_763_0)(nil)

func (p PlayOpenBook_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.Hand)
}

func (p *PlayOpenBook_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Hand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x20
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x20
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x1d
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x1e
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x1c
type PlayOpenHorseScreen_763_0 struct {
	WindowID UByte // Unsigned Byte
	SlotCount VarInt // VarInt
	EntityID Int // Int
}

var _ Packet = (*PlayOpenHorseScreen_763_0)(nil)

func (p PlayOpenHorseScreen_763_0)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
	b.VarInt(p.SlotCount)
	b.Int(p.EntityID)
}

func (p *PlayOpenHorseScreen_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.SlotCount, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x1f
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x1f
type PlayOpenHorseWindow_758_0 struct {
	WindowID UByte // Unsigned Byte
	SlotCount VarInt // VarInt
	EntityID Int // Integer
}

var _ Packet = (*PlayOpenHorseWindow_758_0)(nil)

func (p PlayOpenHorseWindow_758_0)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
	b.VarInt(p.SlotCount)
	b.Int(p.EntityID)
}

func (p *PlayOpenHorseWindow_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.SlotCount, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x1f
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x1f
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x1e
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x1e
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x20
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x1f
type PlayOpenHorseWindow_756_1 struct {
	WindowID Byte // Byte
	NumberOfSlots VarInt // VarInt
	EntityID Int // Integer
}

var _ Packet = (*PlayOpenHorseWindow_756_1)(nil)

func (p PlayOpenHorseWindow_756_1)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.VarInt(p.NumberOfSlots)
	b.Int(p.EntityID)
}

func (p *PlayOpenHorseWindow_756_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.NumberOfSlots, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityID, ok = r.Int(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x30
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x30
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x2c
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x2d
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x2b
type PlayOpenScreen_763_0 struct {
	/* A unique id number for the window to be displayed. Notchian server implementation is a counter, starting at 1. */
	WindowID VarInt // VarInt
	/* The window type to use for display. Contained in the minecraft:menu registry; see Inventory for the different values. */
	WindowType VarInt // VarInt
	/* The title of the window. */
	WindowTitle Object // Chat
}

var _ Packet = (*PlayOpenScreen_763_0)(nil)

func (p PlayOpenScreen_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.WindowID)
	b.VarInt(p.WindowType)
	b.JSON(p.WindowTitle)
}

func (p *PlayOpenScreen_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.WindowType, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = r.JSON(&p.WindowTitle); err != nil {
		return err
	}
	return nil
}

// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x31
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x2d
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x2e
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x2c
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x2f
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x2f
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x2f
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x2f
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x2e
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x2e
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x30
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x2f
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x2c
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x2a
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x2a
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x2a
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x2a
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x2a
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x2a
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x2a
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x36
type PlayOpenSignEditor_762_1 struct {
	Location Position // Position
}

var _ Packet = (*PlayOpenSignEditor_762_1)(nil)

func (p PlayOpenSignEditor_762_1)Encode(b *PacketBuilder){
	p.Location.Encode(b)
}

func (p *PlayOpenSignEditor_762_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x2e
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x2e
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x2e
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x2e
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x2d
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x2d
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x2f
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x2e
type PlayOpenWindow_758_0 struct {
	/* A unique id number for the window to be displayed. Notchian server implementation is a counter, starting at 1. */
	WindowID VarInt // VarInt
	/* The window type to use for display. Contained in the minecraft:menu regisry; see Inventory for the different values. */
	WindowType VarInt // VarInt
	/* The title of the window */
	WindowTitle Object // Chat
}

var _ Packet = (*PlayOpenWindow_758_0)(nil)

func (p PlayOpenWindow_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.WindowID)
	b.VarInt(p.WindowType)
	b.JSON(p.WindowTitle)
}

func (p *PlayOpenWindow_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.WindowType, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = r.JSON(&p.WindowTitle); err != nil {
		return err
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x14
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x13
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x13
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x13
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x13
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x13
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x13
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x13
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x2d
type PlayOpenWindow_404_1 struct {
	/* A unique id number for the window to be displayed. Notchian server implementation is a counter, starting at 1. */
	WindowID UByte // Unsigned Byte
	/* The window type to use for display. See Inventory for a list. */
	WindowType String // String (32)
	/* The title of the window */
	WindowTitle Object // Chat
	/* Number of slots in the window (excluding the number of slots in the player inventory). Always 0 for non-storage windows (e.g. Workbench, Anvil). */
	NumberOfSlots UByte // Unsigned Byte
	/* EntityHorse's EID. Only sent when Window Type is “EntityHorse” */
	EntityID Optional[Int] // Optional Int
}

var _ Packet = (*PlayOpenWindow_404_1)(nil)

func (p PlayOpenWindow_404_1)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
	b.String(p.WindowType)
	b.JSON(p.WindowTitle)
	b.UByte(p.NumberOfSlots)
	if p.WindowType == "EntityHorse" {
		b.Int(p.EntityID.Assert())
	}
}

func (p *PlayOpenWindow_404_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.WindowType, ok = r.String(); !ok {
		return io.EOF
	}
	if err = r.JSON(&p.WindowTitle); err != nil {
		return err
	}
	if p.NumberOfSlots, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.EntityID.Ok = p.WindowType == "EntityHorse"; p.EntityID.Ok {
		if p.EntityID.V, ok = r.Int(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x19
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x19
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x18
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x19
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x18
type PlayPaddleBoat_763_0 struct {
	LeftPaddleTurning Bool // Boolean
	RightPaddleTurning Bool // Boolean
}

var _ Packet = (*PlayPaddleBoat_763_0)(nil)

func (p PlayPaddleBoat_763_0)Encode(b *PacketBuilder){
	b.Bool(p.LeftPaddleTurning)
	b.Bool(p.RightPaddleTurning)
}

func (p *PlayPaddleBoat_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.LeftPaddleTurning, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.RightPaddleTurning, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x26
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x26
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x22
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x23
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x21
type PlayParticle_763_0 struct {
	/* The particle ID listed in the particle data type. */
	ParticleID VarInt // VarInt
	/* If true, particle distance increases from 256 to 65536. */
	LongDistance Bool // Boolean
	/* X position of the particle. */
	X Double // Double
	/* Y position of the particle. */
	Y Double // Double
	/* Z position of the particle. */
	Z Double // Double
	/* This is added to the X position after being multiplied by random.nextGaussian(). */
	OffsetX Float // Float
	/* This is added to the Y position after being multiplied by random.nextGaussian(). */
	OffsetY Float // Float
	/* This is added to the Z position after being multiplied by random.nextGaussian(). */
	OffsetZ Float // Float
	MaxSpeed Float // Float
	/* The number of particles to create. */
	ParticleCount Int // Int
	/* The variable data listed in the particle data type. */
	Data any // Varies
}

var _ Packet = (*PlayParticle_763_0)(nil)

func (p PlayParticle_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.ParticleID)
	b.Bool(p.LongDistance)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.Float(p.OffsetX)
	b.Float(p.OffsetY)
	b.Float(p.OffsetZ)
	b.Float(p.MaxSpeed)
	b.Int(p.ParticleCount)
	p.Data.Encode(b)
}

func (p *PlayParticle_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ParticleID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.LongDistance, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.OffsetX, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OffsetY, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OffsetZ, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.MaxSpeed, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.ParticleCount, ok = r.Int(); !ok {
		return io.EOF
	}
	if err = p.Data.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x24
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x24
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x24
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x24
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x22
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x22
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x24
type PlayParticle_758_1 struct {
	/* The particle ID listed in the particle data type. */
	ParticleID Int // Int
	/* If true, particle distance increases from 256 to 65536 */
	LongDistance Bool // Boolean
	/* X position of the particle */
	X Double // Double
	/* Y position of the particle */
	Y Double // Double
	/* Z position of the particle */
	Z Double // Double
	/* This is added to the X position after being multiplied by random.nextGaussian() */
	OffsetX Float // Float
	/* This is added to the Y position after being multiplied by random.nextGaussian() */
	OffsetY Float // Float
	/* This is added to the Z position after being multiplied by random.nextGaussian() */
	OffsetZ Float // Float
	/* The data of each particle */
	ParticleData Float // Float
	/* The number of particles to create */
	ParticleCount Int // Int
	/* The variable data listed in the particle data type. */
	Data any // Varies
}

var _ Packet = (*PlayParticle_758_1)(nil)

func (p PlayParticle_758_1)Encode(b *PacketBuilder){
	b.Int(p.ParticleID)
	b.Bool(p.LongDistance)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.Float(p.OffsetX)
	b.Float(p.OffsetY)
	b.Float(p.OffsetZ)
	b.Float(p.ParticleData)
	b.Int(p.ParticleCount)
	p.Data.Encode(b)
}

func (p *PlayParticle_758_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ParticleID, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.LongDistance, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.OffsetX, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OffsetY, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OffsetZ, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.ParticleData, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.ParticleCount, ok = r.Int(); !ok {
		return io.EOF
	}
	if err = p.Data.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x23
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x24
type PlayParticle_498_2 struct {
	/* The particle ID listed in the particle data type. */
	ParticleID Int // Int
	/* If true, particle distance increases from 256 to 65536 */
	LongDistance Bool // Boolean
	/* X position of the particle */
	X Float // Float
	/* Y position of the particle */
	Y Float // Float
	/* Z position of the particle */
	Z Float // Float
	/* This is added to the X position after being multiplied by random.nextGaussian() */
	OffsetX Float // Float
	/* This is added to the Y position after being multiplied by random.nextGaussian() */
	OffsetY Float // Float
	/* This is added to the Z position after being multiplied by random.nextGaussian() */
	OffsetZ Float // Float
	/* The data of each particle */
	ParticleData Float // Float
	/* The number of particles to create */
	ParticleCount Int // Int
	/* The variable data listed in the particle data type. */
	Data any // Varies
}

var _ Packet = (*PlayParticle_498_2)(nil)

func (p PlayParticle_498_2)Encode(b *PacketBuilder){
	b.Int(p.ParticleID)
	b.Bool(p.LongDistance)
	b.Float(p.X)
	b.Float(p.Y)
	b.Float(p.Z)
	b.Float(p.OffsetX)
	b.Float(p.OffsetY)
	b.Float(p.OffsetZ)
	b.Float(p.ParticleData)
	b.Int(p.ParticleCount)
	p.Data.Encode(b)
}

func (p *PlayParticle_498_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ParticleID, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.LongDistance, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OffsetX, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OffsetY, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OffsetZ, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.ParticleData, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.ParticleCount, ok = r.Int(); !ok {
		return io.EOF
	}
	if err = p.Data.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x22
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x22
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x22
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x22
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x22
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x22
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x22
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x2a
type PlayParticle_340_3 struct {
	/* See below */
	ParticleID Int // Int
	/* If true, particle distance increases from 256 to 65536 */
	LongDistance Bool // Boolean
	/* X position of the particle */
	X Float // Float
	/* Y position of the particle */
	Y Float // Float
	/* Z position of the particle */
	Z Float // Float
	/* This is added to the X position after being multiplied by random.nextGaussian() */
	OffsetX Float // Float
	/* This is added to the Y position after being multiplied by random.nextGaussian() */
	OffsetY Float // Float
	/* This is added to the Z position after being multiplied by random.nextGaussian() */
	OffsetZ Float // Float
	/* The data of each particle */
	ParticleData Float // Float
	/* The number of particles to create */
	ParticleCount Int // Int
	/* Length depends on particle. "iconcrack" has length of 2, "blockcrack", "blockdust", and "fallingdust" have lengths of 1, the rest have 0. */
	Data []VarInt // Array of VarInt
}

var _ Packet = (*PlayParticle_340_3)(nil)

func (p PlayParticle_340_3)Encode(b *PacketBuilder){
	b.Int(p.ParticleID)
	b.Bool(p.LongDistance)
	b.Float(p.X)
	b.Float(p.Y)
	b.Float(p.Z)
	b.Float(p.OffsetX)
	b.Float(p.OffsetY)
	b.Float(p.OffsetZ)
	b.Float(p.ParticleData)
	b.Int(p.ParticleCount)
	dataLeng := TODO
	assert(len(p.Data) == dataLeng, "len(p.Data) != dataLeng")
	for _, v := range p.Data {
		b.VarInt(v)
	}
}

func (p *PlayParticle_340_3)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ParticleID, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.LongDistance, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OffsetX, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OffsetY, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OffsetZ, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.ParticleData, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.ParticleCount, ok = r.Int(); !ok {
		return io.EOF
	}
	dataLeng := TODO
	p.Data = make([]VarInt, dataLeng)
	for i, _ := range p.Data {
		if p.Data[i], ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x1a
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x1a
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x19
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x1a
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x19
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x17
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x17
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x17
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x17
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x18
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x18
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x17
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x17
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x15
type PlayPickItem_763_0 struct {
	/* See Inventory */
	SlotToUse VarInt // VarInt
}

var _ Packet = (*PlayPickItem_763_0)(nil)

func (p PlayPickItem_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.SlotToUse)
}

func (p *PlayPickItem_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SlotToUse, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x67
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x67
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x63
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x65
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x62
type PlayPickupItem_763_0 struct {
	CollectedEntityID VarInt // VarInt
	CollectorEntityID VarInt // VarInt
	/* Seems to be 1 for XP orbs, otherwise the number of items in the stack. */
	PickupItemCount VarInt // VarInt
}

var _ Packet = (*PlayPickupItem_763_0)(nil)

func (p PlayPickupItem_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.CollectedEntityID)
	b.VarInt(p.CollectorEntityID)
	b.VarInt(p.PickupItemCount)
}

func (p *PlayPickupItem_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.CollectedEntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.CollectorEntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.PickupItemCount, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x32
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x32
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x2e
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x2f
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x2d
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x30
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x30
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x30
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x30
type PlayPing_763_0 struct {
	ID Int // Int
}

var _ Packet = (*PlayPing_763_0)(nil)

func (p PlayPing_763_0)Encode(b *PacketBuilder){
	b.Int(p.ID)
}

func (p *PlayPing_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ID, ok = r.Int(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x33
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x33
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x2f
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x30
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x2e
type PlayPlaceGhostRecipe_763_0 struct {
	WindowID Byte // Byte
	/* A recipe ID. */
	Recipe String // Identifier
}

var _ Packet = (*PlayPlaceGhostRecipe_763_0)(nil)

func (p PlayPlaceGhostRecipe_763_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.String(p.Recipe)
}

func (p *PlayPlaceGhostRecipe_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Recipe, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x1b
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x1b
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x1a
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x1b
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x1a
type PlayPlaceRecipe_763_0 struct {
	WindowID Byte // Byte
	/* A recipe ID. */
	Recipe String // Identifier
	/* Affects the amount of items processed; true if shift is down when clicked. */
	MakeAll Bool // Boolean
}

var _ Packet = (*PlayPlaceRecipe_763_0)(nil)

func (p PlayPlaceRecipe_763_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.String(p.Recipe)
	b.Bool(p.MakeAll)
}

func (p *PlayPlaceRecipe_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Recipe, ok = r.String(); !ok {
		return io.EOF
	}
	if p.MakeAll, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x17
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x17
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x15
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x16
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x15
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x18
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x18
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x18
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x18
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x17
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x17
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x19
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x18
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x19
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x18
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x18
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x18
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x18
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x18
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x18
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x18
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x3f
type PlayPluginMessage_763_0 struct {
	/* Name of the plugin channel used to send the data */
	Channel String // String (20)
	/* Any data, depending on the channel. MC| channels are documented here.  The length of this array must be inferred from the packet length. */
	Data ByteArray // Byte Array
}

var _ Packet = (*PlayPluginMessage_763_0)(nil)

func (p PlayPluginMessage_763_0)Encode(b *PacketBuilder){
	b.String(p.Channel)
	b.ByteArray(p.Data)
}

func (p *PlayPluginMessage_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Channel, ok = r.String(); !ok {
		return io.EOF
	}
	p.Data = r.ReadAll()
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0xd
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0xd
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0xc
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0xd
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0xc
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0xa
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0xa
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0xa
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0xa
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0xb
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0xb
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0xb
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0xb
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0xa
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x9
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x9
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0xa
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x9
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x9
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x9
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x9
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x17
type PlayPluginMessageServer_763_0 struct {
	/* Name of the plugin channel used to send the data */
	Channel String // String (20)
	/* Any data, depending on the channel. MC| channels are documented here.  The length of this array must be inferred from the packet length. */
	Data ByteArray // Byte Array
}

var _ Packet = (*PlayPluginMessageServer_763_0)(nil)

func (p PlayPluginMessageServer_763_0)Encode(b *PacketBuilder){
	b.String(p.Channel)
	b.ByteArray(p.Data)
}

func (p *PlayPluginMessageServer_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Channel, ok = r.String(); !ok {
		return io.EOF
	}
	p.Data = r.ReadAll()
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x20
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x20
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x1f
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x20
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x1f
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x1d
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x1d
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x1d
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x1d
type PlayPong_763_0 struct {
	ID Int // Int
}

var _ Packet = (*PlayPong_763_0)(nil)

func (p PlayPong_763_0)Encode(b *PacketBuilder){
	b.Int(p.ID)
}

func (p *PlayPong_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ID, ok = r.Int(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x29
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x29
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x29
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x29
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x28
type PlayProgramCommandBlock_763_0 struct {
	Location Position // Position
	Command String // String (32767)
	/* One of SEQUENCE (0), AUTO (1), or REDSTONE (2). */
	Mode VarInt // VarInt Enum
	/* 0x01: Track Output (if false, the output of the previous command will not be stored within the command block); 0x02: Is conditional; 0x04: Automatic. */
	Flags Byte // Byte
}

var _ Packet = (*PlayProgramCommandBlock_763_0)(nil)

func (p PlayProgramCommandBlock_763_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.String(p.Command)
	b.VarInt(p.Mode)
	b.Byte(p.Flags)
}

func (p *PlayProgramCommandBlock_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Command, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Mode, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x2a
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x2a
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x2a
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x2a
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x29
type PlayProgramCommandBlockMinecart_763_0 struct {
	EntityID VarInt // VarInt
	Command String // String (32767)
	/* If false, the output of the previous command will not be stored within the command block. */
	TrackOutput Bool // Boolean
}

var _ Packet = (*PlayProgramCommandBlockMinecart_763_0)(nil)

func (p PlayProgramCommandBlockMinecart_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.String(p.Command)
	b.Bool(p.TrackOutput)
}

func (p *PlayProgramCommandBlockMinecart_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Command, ok = r.String(); !ok {
		return io.EOF
	}
	if p.TrackOutput, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x2c
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x2c
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x2c
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x2c
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x2b
type PlayProgramJigsawBlock_763_0 struct {
	/* Block entity location */
	Location Position // Position
	Name String // Identifier
	Target String // Identifier
	Pool String // Identifier
	/* "Turns into" on the GUI, final_state in NBT. */
	FinalState String // String (32767)
	/* rollable if the attached piece can be rotated, else aligned. */
	JointType String // String
}

var _ Packet = (*PlayProgramJigsawBlock_763_0)(nil)

func (p PlayProgramJigsawBlock_763_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.String(p.Name)
	b.String(p.Target)
	b.String(p.Pool)
	b.String(p.FinalState)
	b.String(p.JointType)
}

func (p *PlayProgramJigsawBlock_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Name, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Target, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Pool, ok = r.String(); !ok {
		return io.EOF
	}
	if p.FinalState, ok = r.String(); !ok {
		return io.EOF
	}
	if p.JointType, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x2d
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x2d
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x2d
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x2d
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x2c
type PlayProgramStructureBlock_763_0 struct {
	/* Block entity location. */
	Location Position // Position
	/* An additional action to perform beyond simply saving the given data; see below. */
	Action VarInt // VarInt Enum
	/* One of SAVE (0), LOAD (1), CORNER (2), DATA (3). */
	Mode VarInt // VarInt Enum
	Name String // String (32767)
	/* Between -32 and 32. */
	OffsetX Byte // Byte
	/* Between -32 and 32. */
	OffsetY Byte // Byte
	/* Between -32 and 32. */
	OffsetZ Byte // Byte
	/* Between 0 and 32. */
	SizeX Byte // Byte
	/* Between 0 and 32. */
	SizeY Byte // Byte
	/* Between 0 and 32. */
	SizeZ Byte // Byte
	/* One of NONE (0), LEFT_RIGHT (1), FRONT_BACK (2). */
	Mirror VarInt // VarInt Enum
	/* One of NONE (0), CLOCKWISE_90 (1), CLOCKWISE_180 (2), COUNTERCLOCKWISE_90 (3). */
	Rotation VarInt // VarInt Enum
	Metadata String // String (128)
	/* Between 0 and 1. */
	Integrity Float // Float
	Seed VarLong // VarLong
	/* 0x01: Ignore entities; 0x02: Show air; 0x04: Show bounding box. */
	Flags Byte // Byte
}

var _ Packet = (*PlayProgramStructureBlock_763_0)(nil)

func (p PlayProgramStructureBlock_763_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.VarInt(p.Action)
	b.VarInt(p.Mode)
	b.String(p.Name)
	b.Byte(p.OffsetX)
	b.Byte(p.OffsetY)
	b.Byte(p.OffsetZ)
	b.Byte(p.SizeX)
	b.Byte(p.SizeY)
	b.Byte(p.SizeZ)
	b.VarInt(p.Mirror)
	b.VarInt(p.Rotation)
	b.String(p.Metadata)
	b.Float(p.Integrity)
	b.VarLong(p.Seed)
	b.Byte(p.Flags)
}

func (p *PlayProgramStructureBlock_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Action, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Mode, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Name, ok = r.String(); !ok {
		return io.EOF
	}
	if p.OffsetX, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.OffsetY, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.OffsetZ, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.SizeX, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.SizeY, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.SizeZ, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Mirror, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Rotation, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Metadata, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Integrity, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Seed, ok = r.VarLong(); !ok {
		return io.EOF
	}
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x1
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x1
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x1
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x1
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x1
type PlayQueryBlockEntityTag_763_0 struct {
	/* An incremental ID so that the client can verify that the response matches. */
	TransactionID VarInt // VarInt
	/* The location of the block to check. */
	Location Position // Position
}

var _ Packet = (*PlayQueryBlockEntityTag_763_0)(nil)

func (p PlayQueryBlockEntityTag_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.TransactionID)
	p.Location.Encode(b)
}

func (p *PlayQueryBlockEntityTag_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TransactionID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x1
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x1
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x1
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x1
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x1
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x1
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x1
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x1
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x1
type PlayQueryBlockNBT_758_0 struct {
	/* An incremental ID so that the client can verify that the response matches. */
	TransactionID VarInt // VarInt
	/* The location of the block to check. */
	Location Position // Position
}

var _ Packet = (*PlayQueryBlockNBT_758_0)(nil)

func (p PlayQueryBlockNBT_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.TransactionID)
	p.Location.Encode(b)
}

func (p *PlayQueryBlockNBT_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TransactionID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0xc
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0xc
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0xc
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0xc
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0xd
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0xd
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0xd
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0xc
type PlayQueryEntityNBT_758_0 struct {
	/* An incremental ID so that the client can verify that the response matches. */
	TransactionID VarInt // VarInt
	/* The ID of the entity to query. */
	EntityID VarInt // VarInt
}

var _ Packet = (*PlayQueryEntityNBT_758_0)(nil)

func (p PlayQueryEntityNBT_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.TransactionID)
	b.VarInt(p.EntityID)
}

func (p *PlayQueryEntityNBT_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TransactionID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0xf
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0xf
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0xe
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0xf
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0xe
type PlayQueryEntityTag_763_0 struct {
	/* An incremental ID so that the client can verify that the response matches. */
	TransactionID VarInt // VarInt
	/* The ID of the entity to query. */
	EntityID VarInt // VarInt
}

var _ Packet = (*PlayQueryEntityTag_763_0)(nil)

func (p PlayQueryEntityTag_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.TransactionID)
	b.VarInt(p.EntityID)
}

func (p *PlayQueryEntityTag_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TransactionID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x3e
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x3e
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x3a
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x3b
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x38
type PlayRemoveEntities_763_0 struct {
	/* Number of elements in the following array. */
	Count VarInt // VarInt
	/* The list of entities to destroy. */
	EntityIDs []VarInt // Array of VarInt
}

var _ Packet = (*PlayRemoveEntities_763_0)(nil)

func (p PlayRemoveEntities_763_0)Encode(b *PacketBuilder){
	p.Count = (VarInt)(len(p.EntityIDs))
	b.VarInt(p.Count)
	for _, v := range p.EntityIDs {
		b.VarInt(v)
	}
}

func (p *PlayRemoveEntities_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Count, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.EntityIDs = make([]VarInt, p.Count)
	for i, _ := range p.EntityIDs {
		if p.EntityIDs[i], ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x3f
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x3f
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x3b
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x3c
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x39
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x3b
type PlayRemoveEntityEffect_763_0 struct {
	EntityID VarInt // VarInt
	/* See this table. */
	EffectID VarInt // VarInt
}

var _ Packet = (*PlayRemoveEntityEffect_763_0)(nil)

func (p PlayRemoveEntityEffect_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.VarInt(p.EffectID)
}

func (p *PlayRemoveEntityEffect_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EffectID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x3b
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x3b
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x3b
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x37
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x37
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x39
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x38
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x36
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x33
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x33
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x32
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x31
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x31
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x31
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x31
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x1e
type PlayRemoveEntityEffect_757_1 struct {
	EntityID VarInt // VarInt
	/* See this table */
	EffectID Byte // Byte
}

var _ Packet = (*PlayRemoveEntityEffect_757_1)(nil)

func (p PlayRemoveEntityEffect_757_1)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Byte(p.EffectID)
}

func (p *PlayRemoveEntityEffect_757_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EffectID, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x23
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x23
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x23
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x23
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x22
type PlayRenameItem_763_0 struct {
	/* The new name of the item. */
	ItemName String // String (32767)
}

var _ Packet = (*PlayRenameItem_763_0)(nil)

func (p PlayRenameItem_763_0)Encode(b *PacketBuilder){
	b.String(p.ItemName)
}

func (p *PlayRenameItem_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ItemName, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x40
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x40
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x3c
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x3d
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x3a
type PlayResourcePack_763_0 struct {
	/* The URL to the resource pack. */
	URL String // String (32767)
	/* A 40 character hexadecimal and lowercase SHA-1 hash of the resource pack file.If it's not a 40 character hexadecimal string, the client will not use it for hash verification and likely waste bandwidth — but it will still treat it as a unique id */
	Hash String // String (40)
	/* The notchian client will be forced to use the resource pack from the server. If they decline they will be kicked from the server. */
	Forced Bool // Boolean
	/* true If the next field will be sent false otherwise. When false, this is the end of the packet */
	HasPromptMessage Bool // Boolean
	/* This is shown in the prompt making the client accept or decline the resource pack. */
	PromptMessage Optional[Object] // Optional Chat
}

var _ Packet = (*PlayResourcePack_763_0)(nil)

func (p PlayResourcePack_763_0)Encode(b *PacketBuilder){
	b.String(p.URL)
	b.String(p.Hash)
	b.Bool(p.Forced)
	p.HasPromptMessage = p.PromptMessage.Ok
	b.Bool(p.HasPromptMessage)
	if p.PromptMessage.Ok {
		b.JSON(p.PromptMessage.V)
	}
}

func (p *PlayResourcePack_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.URL, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Hash, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Forced, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.HasPromptMessage, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.PromptMessage.Ok = p.HasPromptMessage; p.PromptMessage.Ok {
		if err = r.JSON(&p.PromptMessage.V); err != nil {
			return err
		}
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x3c
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x3c
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x3c
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x3c
type PlayResourcePackSend_758_0 struct {
	/* The URL to the resource pack. */
	URL String // String (32767)
	/* A 40 character hexadecimal and lowercase SHA-1 hash of the resource pack file. (must be lower case in order to work)If it's not a 40 character hexadecimal string, the client will not use it for hash verification and likely waste bandwidth — but it will still treat it as a unique id */
	Hash String // String (40)
	/* The notchian client will be forced to use the resource pack from the server. If they decline they will be kicked from the server. */
	Forced Bool // Boolean
	/* true If the next field will be sent false otherwise. When false, this is the end of the packet */
	HasPromptMessage Bool // Boolean
	/* This is shown in the prompt making the client accept or decline the resource pack. */
	PromptMessage Optional[Object] // Optional Chat
}

var _ Packet = (*PlayResourcePackSend_758_0)(nil)

func (p PlayResourcePackSend_758_0)Encode(b *PacketBuilder){
	b.String(p.URL)
	b.String(p.Hash)
	b.Bool(p.Forced)
	p.HasPromptMessage = p.PromptMessage.Ok
	b.Bool(p.HasPromptMessage)
	if p.PromptMessage.Ok {
		b.JSON(p.PromptMessage.V)
	}
}

func (p *PlayResourcePackSend_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.URL, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Hash, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Forced, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.HasPromptMessage, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.PromptMessage.Ok = p.HasPromptMessage; p.PromptMessage.Ok {
		if err = r.JSON(&p.PromptMessage.V); err != nil {
			return err
		}
	}
	return nil
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x38
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x38
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x3a
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x39
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x37
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x34
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x34
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x33
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x32
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x32
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x32
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x32
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x48
type PlayResourcePackSend_754_1 struct {
	/* The URL to the resource pack. */
	URL String // String (32767)
	/* A 40 character hexadecimal and lowercase SHA-1 hash of the resource pack file. (must be lower case in order to work)If it's not a 40 character hexadecimal string, the client will not use it for hash verification and likely waste bandwidth — but it will still treat it as a unique id */
	Hash String // String (40)
}

var _ Packet = (*PlayResourcePackSend_754_1)(nil)

func (p PlayResourcePackSend_754_1)Encode(b *PacketBuilder){
	b.String(p.URL)
	b.String(p.Hash)
}

func (p *PlayResourcePackSend_754_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.URL, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Hash, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x24
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x24
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x24
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x24
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x23
type PlayResourcePackServer_763_0 struct {
	/* 0: successfully loaded, 1: declined, 2: failed download, 3: accepted. */
	Result VarInt // VarInt Enum
}

var _ Packet = (*PlayResourcePackServer_763_0)(nil)

func (p PlayResourcePackServer_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.Result)
}

func (p *PlayResourcePackServer_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Result, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x21
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x21
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x21
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x21
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x21
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x21
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x1f
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x1f
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x1d
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x18
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x18
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x18
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x16
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x16
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x16
type PlayResourcePackStatus_758_0 struct {
	/* 0: successfully loaded, 1: declined, 2: failed download, 3: accepted */
	Result VarInt // VarInt Enum
}

var _ Packet = (*PlayResourcePackStatus_758_0)(nil)

func (p PlayResourcePackStatus_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.Result)
}

func (p *PlayResourcePackStatus_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Result, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x16
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x19
type PlayResourcePackStatus_110_1 struct {
	/* The hash sent in the Resource Pack Send packet. */
	Hash String // String
	/* 0: successfully loaded, 1: declined, 2: failed download, 3: accepted */
	Result VarInt // VarInt Enum
}

var _ Packet = (*PlayResourcePackStatus_110_1)(nil)

func (p PlayResourcePackStatus_110_1)Encode(b *PacketBuilder){
	b.String(p.Hash)
	b.VarInt(p.Result)
}

func (p *PlayResourcePackStatus_110_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Hash, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Result, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x3e
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x3b
type PlayRespawn_760_3 struct {
	/* Valid dimensions are defined per dimension registry sent in Login (play) */
	DimensionType String // Identifier
	/* Name of the dimension being spawned into. */
	DimensionName String // Identifier
	/* First 8 bytes of the SHA-256 hash of the world's seed. Used client side for biome noise */
	HashedSeed Long // Long
	/* 0: survival, 1: creative, 2: adventure, 3: spectator. The hardcore flag is not included */
	Gamemode UByte // Unsigned Byte
	/* -1: null 0: survival, 1: creative, 2: adventure, 3: spectator. The hardcore flag is not included. The previous gamemode. (More information needed) */
	PreviousGamemode Byte // Byte
	/* True if the world is a debug mode world; debug mode worlds cannot be modified and have predefined blocks. */
	IsDebug Bool // Boolean
	/* True if the world is a superflat world; flat worlds have different void fog and a horizon at y=0 instead of y=63. */
	IsFlat Bool // Boolean
	/* If false, metadata is reset on the respawned player entity.  Set to true for dimension changes (including the dimension change triggered by sending client status perform respawn to exit the end poem/credits), and false for normal respawns. */
	CopyMetadata Bool // Boolean
	/* If true, then the next two fields are present. */
	HasDeathLocation Bool // Boolean
	/* Name of the dimension the player died in. */
	DeathDimensionName String // Identifier
	/* The location that the player died at. */
	DeathLocation Position // Position
}

var _ Packet = (*PlayRespawn_760_3)(nil)

func (p PlayRespawn_760_3)Encode(b *PacketBuilder){
	b.String(p.DimensionType)
	b.String(p.DimensionName)
	b.Long(p.HashedSeed)
	b.UByte(p.Gamemode)
	b.Byte(p.PreviousGamemode)
	b.Bool(p.IsDebug)
	b.Bool(p.IsFlat)
	b.Bool(p.CopyMetadata)
	b.Bool(p.HasDeathLocation)
	b.String(p.DeathDimensionName)
	p.DeathLocation.Encode(b)
}

func (p *PlayRespawn_760_3)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.DimensionType, ok = r.String(); !ok {
		return io.EOF
	}
	if p.DimensionName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.HashedSeed, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.Gamemode, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.PreviousGamemode, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.IsDebug, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.IsFlat, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.CopyMetadata, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.HasDeathLocation, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.DeathDimensionName, ok = r.String(); !ok {
		return io.EOF
	}
	if err = p.DeathLocation.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x3d
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x3d
type PlayRespawn_758_4 struct {
	/* Valid dimensions are defined per dimension registry sent in Join Game */
	Dimension *nbt.NBTCompound // NBT Tag Compound
	/* Name of the dimension being spawned into. */
	DimensionName String // Identifier
	/* First 8 bytes of the SHA-256 hash of the world's seed. Used client side for biome noise */
	HashedSeed Long // Long
	/* 0: survival, 1: creative, 2: adventure, 3: spectator. The hardcore flag is not included */
	Gamemode UByte // Unsigned Byte
	/* -1: null 0: survival, 1: creative, 2: adventure, 3: spectator. The hardcore flag is not included. The previous gamemode. (More information needed) */
	PreviousGamemode UByte // Unsigned Byte
	/* True if the world is a debug mode world; debug mode worlds cannot be modified and have predefined blocks. */
	IsDebug Bool // Boolean
	/* True if the world is a superflat world; flat worlds have different void fog and a horizon at y=0 instead of y=63. */
	IsFlat Bool // Boolean
	/* If false, metadata is reset on the respawned player entity.  Set to true for dimension changes (including the dimension change triggered by sending client status perform respawn to exit the end poem/credits), and false for normal respawns. */
	CopyMetadata Bool // Boolean
}

var _ Packet = (*PlayRespawn_758_4)(nil)

func (p PlayRespawn_758_4)Encode(b *PacketBuilder){
	p.Dimension.Encode(b)
	b.String(p.DimensionName)
	b.Long(p.HashedSeed)
	b.UByte(p.Gamemode)
	b.UByte(p.PreviousGamemode)
	b.Bool(p.IsDebug)
	b.Bool(p.IsFlat)
	b.Bool(p.CopyMetadata)
}

func (p *PlayRespawn_758_4)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	p.Dimension = new(nbt.NBTCompound)
	if err = p.Dimension.DecodeFrom(r); err != nil {
		return err
	}
	if p.DimensionName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.HashedSeed, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.Gamemode, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.PreviousGamemode, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.IsDebug, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.IsFlat, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.CopyMetadata, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x3d
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x3d
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x39
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x39
type PlayRespawn_756_5 struct {
	/* Valid dimensions are defined per dimension registry sent in Join Game */
	Dimension *nbt.NBTCompound // NBT Tag Compound
	/* Name of the world being spawned into */
	WorldName String // Identifier
	/* First 8 bytes of the SHA-256 hash of the world's seed. */
	HashedSeed Long // Long
	/* 0: survival, 1: creative, 2: adventure, 3: spectator. The hardcore flag is not included */
	Gamemode UByte // Unsigned Byte
	/* 0: survival, 1: creative, 2: adventure, 3: spectator. The hardcore flag is not included. The previous gamemode. (More information needed) */
	PreviousGamemode UByte // Unsigned Byte
	/* True if the world is a debug mode world; debug mode worlds cannot be modified and have predefined blocks */
	IsDebug Bool // Boolean
	/* True if the world is a superflat world; flat worlds have different void fog and a horizon at y=0 instead of y=63 */
	IsFlat Bool // Boolean
	/* If false, metadata is reset on the respawned player entity.  Set to true for dimension changes (including the dimension change triggered by sending client status perform respawn to exit the end poem/credits), and false for normal respawns. */
	CopyMetadata Bool // Boolean
}

var _ Packet = (*PlayRespawn_756_5)(nil)

func (p PlayRespawn_756_5)Encode(b *PacketBuilder){
	p.Dimension.Encode(b)
	b.String(p.WorldName)
	b.Long(p.HashedSeed)
	b.UByte(p.Gamemode)
	b.UByte(p.PreviousGamemode)
	b.Bool(p.IsDebug)
	b.Bool(p.IsFlat)
	b.Bool(p.CopyMetadata)
}

func (p *PlayRespawn_756_5)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	p.Dimension = new(nbt.NBTCompound)
	if err = p.Dimension.DecodeFrom(r); err != nil {
		return err
	}
	if p.WorldName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.HashedSeed, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.Gamemode, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.PreviousGamemode, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.IsDebug, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.IsFlat, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.CopyMetadata, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x38
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x35
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x35
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x34
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x33
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x33
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x33
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x33
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x7
type PlayRespawn_404_8 struct {
	/* -1: The Nether, 0: The Overworld, 1: The End */
	Dimension Int // Int Enum
	/* 0: Peaceful, 1: Easy, 2: Normal, 3: Hard */
	Difficulty UByte // Unsigned Byte
	/* 0: survival, 1: creative, 2: adventure, 3: spectator. The hardcore flag is not included */
	Gamemode UByte // Unsigned Byte
	/* Same as Join Game */
	LevelType String // String (16)
}

var _ Packet = (*PlayRespawn_404_8)(nil)

func (p PlayRespawn_404_8)Encode(b *PacketBuilder){
	b.Int(p.Dimension)
	b.UByte(p.Difficulty)
	b.UByte(p.Gamemode)
	b.String(p.LevelType)
}

func (p *PlayRespawn_404_8)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Dimension, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.Difficulty, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Gamemode, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.LevelType, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x53
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x53
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x53
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x53
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x4a
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x4a
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x4a
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x49
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x45
type PlayScoreboardObjective_758_0 struct {
	/* An unique name for the objective */
	ObjectiveName String // String (16)
	/* 0 to create the scoreboard. 1 to remove the scoreboard. 2 to update the display text. */
	Mode Byte // Byte
	/* Only if mode is 0 or 2. The text to be displayed for the score */
	ObjectiveValue Optional[Object] // Optional Chat
	/* Only if mode is 0 or 2. 0 = "integer", 1 = "hearts". */
	Type Optional[VarInt] // Optional VarInt enum
}

var _ Packet = (*PlayScoreboardObjective_758_0)(nil)

func (p PlayScoreboardObjective_758_0)Encode(b *PacketBuilder){
	b.String(p.ObjectiveName)
	b.Byte(p.Mode)
	if p.Mode == 0 || p.Mode == 2 {
		b.JSON(p.ObjectiveValue.Assert())
		b.VarInt(p.Type.Assert())
	}
}

func (p *PlayScoreboardObjective_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ObjectiveName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Mode, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ObjectiveValue.Ok = p.Mode == 0 || p.Mode == 2; p.ObjectiveValue.Ok {
		if err = r.JSON(&p.ObjectiveValue.V); err != nil {
			return err
		}
	}
	if p.Type.Ok = p.Mode == 0 || p.Mode == 2; p.Type.Ok {
		if p.Type.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x42
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x42
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x41
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x3f
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x3f
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x3f
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x3f
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x3b
type PlayScoreboardObjective_340_1 struct {
	/* An unique name for the objective */
	ObjectiveName String // String (16)
	/* 0 to create the scoreboard. 1 to remove the scoreboard. 2 to update the display text. */
	Mode Byte // Byte
	/* Only if mode is 0 or 2. The text to be displayed for the score */
	ObjectiveValue Optional[String] // Optional String (32)
	/* Only if mode is 0 or 2. “integer” or “hearts” */
	Type Optional[String] // Optional String (16)
}

var _ Packet = (*PlayScoreboardObjective_340_1)(nil)

func (p PlayScoreboardObjective_340_1)Encode(b *PacketBuilder){
	b.String(p.ObjectiveName)
	b.Byte(p.Mode)
	if p.Mode == 0 || p.Mode == 2 {
		b.String(p.ObjectiveValue.Assert())
		b.String(p.Type.Assert())
	}
}

func (p *PlayScoreboardObjective_340_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ObjectiveName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Mode, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ObjectiveValue.Ok = p.Mode == 0 || p.Mode == 2; p.ObjectiveValue.Ok {
		if p.ObjectiveValue.V, ok = r.String(); !ok {
			return io.EOF
		}
	}
	if p.Type.Ok = p.Mode == 0 || p.Mode == 2; p.Type.Ok {
		if p.Type.V, ok = r.String(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x5
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x5
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x5
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x5
type PlaySculkVibrationSignal_758_0 struct {
	/* Source position for the vibration. */
	SourcePosition Position // Position
	/* Identifier of the destination codec type. */
	DestinationIdentifier String // Identifier
	/* Vanilla default destinations are a block position encoded as a Position for "block" or an entity id encoded as a VarInt for "entity". */
	Destination any // Varies
	/* Ticks for the signal to arrive at the destination. */
	ArrivalTicks VarInt // VarInt
}

var _ Packet = (*PlaySculkVibrationSignal_758_0)(nil)

func (p PlaySculkVibrationSignal_758_0)Encode(b *PacketBuilder){
	p.SourcePosition.Encode(b)
	b.String(p.DestinationIdentifier)
	switch p.DestinationIdentifier {
	case "block":
		p.Destination.(Position).Encode(b)
	case "entity":
		b.VarInt(p.Destination.(VarInt))
	}
	b.VarInt(p.ArrivalTicks)
}

func (p *PlaySculkVibrationSignal_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.SourcePosition.DecodeFrom(r); err != nil {
		return err
	}
	if p.DestinationIdentifier, ok = r.String(); !ok {
		return io.EOF
	}
	switch p.DestinationIdentifier {
	case "block":
		var v Position
		if err = v.DecodeFrom(r); err != nil {
			return err
		}
		p.Destination = v
	case "entity":
		var v VarInt
		if v, ok = r.VarInt(); !ok {
			return io.EOF
		}
		p.Destination = v
	}
	if p.ArrivalTicks, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x25
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x25
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x25
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x25
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x24
type PlaySeenAdvancements_763_0 struct {
	/* 0: Opened tab, 1: Closed screen. */
	Action VarInt // VarInt Enum
	/* Only present if action is Opened tab. */
	TabID Optional[String] // Optional identifier
}

var _ Packet = (*PlaySeenAdvancements_763_0)(nil)

func (p PlaySeenAdvancements_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.Action)
	if p.Action == 0 {
		b.String(p.TabID.Assert())
	}
}

func (p *PlaySeenAdvancements_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Action, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.TabID.Ok = p.Action == 0; p.TabID.Ok {
		if p.TabID.V, ok = r.String(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x40
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x40
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x40
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x40
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x3c
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x3c
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x3d
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x3c
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x3a
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x37
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x37
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x36
type PlaySelectAdvancementTab_758_0 struct {
	/* Indicates if the next field is present */
	HasId Bool // Boolean
	/* See below */
	OptionalIdentifier String // String (32767)
}

var _ Packet = (*PlaySelectAdvancementTab_758_0)(nil)

func (p PlaySelectAdvancementTab_758_0)Encode(b *PacketBuilder){
	b.Bool(p.HasId)
	b.String(p.OptionalIdentifier)
}

func (p *PlaySelectAdvancementTab_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.HasId, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.OptionalIdentifier, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x44
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x44
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x40
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x41
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x3e
type PlaySelectAdvancementsTab_763_0 struct {
	/* Indicates if the next field is present. */
	HasId Bool // Boolean
	/* See below. */
	OptionalIdentifier String // Identifier
}

var _ Packet = (*PlaySelectAdvancementsTab_763_0)(nil)

func (p PlaySelectAdvancementsTab_763_0)Encode(b *PacketBuilder){
	b.Bool(p.HasId)
	b.String(p.OptionalIdentifier)
}

func (p *PlaySelectAdvancementsTab_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.HasId, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.OptionalIdentifier, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x26
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x26
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x26
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x26
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x25
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x23
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x23
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x23
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x23
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x23
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x23
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x21
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x21
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x1f
type PlaySelectTrade_763_0 struct {
	/* The selected slot int the players current (trading) inventory. (Was a full Integer for the plugin message) */
	SelectedSlot VarInt // VarInt
}

var _ Packet = (*PlaySelectTrade_763_0)(nil)

func (p PlaySelectTrade_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.SelectedSlot)
}

func (p *PlaySelectTrade_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SelectedSlot, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x45
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x45
type PlayServerData_763_0 struct {
	MOTD Object // Chat
	HasIcon Bool // Boolean
	/* Icon PNG base64 String */
	Icon Optional[String] // Optional String (32767)
	EnforcesSecureChat Bool // Boolean
}

var _ Packet = (*PlayServerData_763_0)(nil)

func (p PlayServerData_763_0)Encode(b *PacketBuilder){
	b.JSON(p.MOTD)
	p.HasIcon = p.Icon.Ok
	b.Bool(p.HasIcon)
	if p.Icon.Ok {
		b.String(p.Icon.V)
	}
	b.Bool(p.EnforcesSecureChat)
}

func (p *PlayServerData_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.MOTD); err != nil {
		return err
	}
	if p.HasIcon, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.Icon.Ok = p.HasIcon; p.Icon.Ok {
		if p.Icon.V, ok = r.String(); !ok {
			return io.EOF
		}
	}
	if p.EnforcesSecureChat, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x42
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x3f
type PlayServerData_760_2 struct {
	HasMOTD Bool // Boolean
	MOTD Optional[Object] // Optional Chat
	HasIcon Bool // Boolean
	/* Icon PNG base64 String */
	Icon Optional[String] // Optional String (32767)
	PreviewsChat Bool // Boolean
	EnforcesSecureChat Bool // Boolean
}

var _ Packet = (*PlayServerData_760_2)(nil)

func (p PlayServerData_760_2)Encode(b *PacketBuilder){
	p.HasMOTD = p.MOTD.Ok
	b.Bool(p.HasMOTD)
	if p.MOTD.Ok {
		b.JSON(p.MOTD.V)
	}
	p.HasIcon = p.Icon.Ok
	b.Bool(p.HasIcon)
	if p.Icon.Ok {
		b.String(p.Icon.V)
	}
	b.Bool(p.PreviewsChat)
	b.Bool(p.EnforcesSecureChat)
}

func (p *PlayServerData_760_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.HasMOTD, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.MOTD.Ok = p.HasMOTD; p.MOTD.Ok {
		if err = r.JSON(&p.MOTD.V); err != nil {
			return err
		}
	}
	if p.HasIcon, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.Icon.Ok = p.HasIcon; p.Icon.Ok {
		if p.Icon.V, ok = r.String(); !ok {
			return io.EOF
		}
	}
	if p.PreviewsChat, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.EnforcesSecureChat, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0xe
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0xe
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0xe
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0xe
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0xd
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0xd
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0xe
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0xd
type PlayServerDifficulty_758_0 struct {
	/* 0: peaceful, 1: easy, 2: normal, 3: hard */
	Difficulty UByte // Unsigned Byte
	DifficultyLocked Bool // Boolean
}

var _ Packet = (*PlayServerDifficulty_758_0)(nil)

func (p PlayServerDifficulty_758_0)Encode(b *PacketBuilder){
	b.UByte(p.Difficulty)
	b.Bool(p.DifficultyLocked)
}

func (p *PlayServerDifficulty_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Difficulty, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.DifficultyLocked, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0xd
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0xd
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0xd
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0xd
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0xd
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0xd
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0xd
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0xd
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x41
type PlayServerDifficulty_404_1 struct {
	/* 0: peaceful, 1: easy, 2: normal, 3: hard */
	Difficulty UByte // Unsigned Byte
}

var _ Packet = (*PlayServerDifficulty_404_1)(nil)

func (p PlayServerDifficulty_404_1)Encode(b *PacketBuilder){
	b.UByte(p.Difficulty)
}

func (p *PlayServerDifficulty_404_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Difficulty, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x46
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x46
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x42
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x43
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x40
type PlaySetActionBarText_763_0 struct {
	/* Displays a message above the hotbar (the same as position 2 in Player Chat Message. */
	ActionBarText Object // Chat
}

var _ Packet = (*PlaySetActionBarText_763_0)(nil)

func (p PlaySetActionBarText_763_0)Encode(b *PacketBuilder){
	b.JSON(p.ActionBarText)
}

func (p *PlaySetActionBarText_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.ActionBarText); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x27
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x27
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x27
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x27
type PlaySetBeaconEffect_763_0 struct {
	HasPrimaryEffect Bool // Boolean
	/* A Potion ID. (Was a full Integer for the plugin message). */
	PrimaryEffect VarInt // VarInt
	HasSecondaryEffect Bool // Boolean
	/* A Potion ID. (Was a full Integer for the plugin message). */
	SecondaryEffect VarInt // VarInt
}

var _ Packet = (*PlaySetBeaconEffect_763_0)(nil)

func (p PlaySetBeaconEffect_763_0)Encode(b *PacketBuilder){
	b.Bool(p.HasPrimaryEffect)
	b.VarInt(p.PrimaryEffect)
	b.Bool(p.HasSecondaryEffect)
	b.VarInt(p.SecondaryEffect)
}

func (p *PlaySetBeaconEffect_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.HasPrimaryEffect, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.PrimaryEffect, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.HasSecondaryEffect, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.SecondaryEffect, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x24
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x24
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x24
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x24
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x24
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x24
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x22
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x22
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x20
type PlaySetBeaconEffect_758_2 struct {
	/* A Potion ID. (Was a full Integer for the plugin message) */
	PrimaryEffect VarInt // VarInt
	/* A Potion ID. (Was a full Integer for the plugin message) */
	SecondaryEffect VarInt // VarInt
}

var _ Packet = (*PlaySetBeaconEffect_758_2)(nil)

func (p PlaySetBeaconEffect_758_2)Encode(b *PacketBuilder){
	b.VarInt(p.PrimaryEffect)
	b.VarInt(p.SecondaryEffect)
}

func (p *PlaySetBeaconEffect_758_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.PrimaryEffect, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.SecondaryEffect, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x7
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x7
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x6
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x6
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x6
type PlaySetBlockDestroyStage_763_0 struct {
	/* The ID of the entity breaking the block. */
	EntityID VarInt // VarInt
	/* Block Position. */
	Location Position // Position
	/* 0–9 to set it, any other value to remove it. */
	DestroyStage Byte // Byte
}

var _ Packet = (*PlaySetBlockDestroyStage_763_0)(nil)

func (p PlaySetBlockDestroyStage_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	p.Location.Encode(b)
	b.Byte(p.DestroyStage)
}

func (p *PlaySetBlockDestroyStage_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.DestroyStage, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x47
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x47
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x43
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x44
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x41
type PlaySetBorderCenter_763_0 struct {
	X Double // Double
	Z Double // Double
}

var _ Packet = (*PlaySetBorderCenter_763_0)(nil)

func (p PlaySetBorderCenter_763_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.Z)
}

func (p *PlaySetBorderCenter_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x48
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x48
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x44
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x45
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x42
type PlaySetBorderLerpSize_763_0 struct {
	/* Current length of a single side of the world border, in meters. */
	OldDiameter Double // Double
	/* Target length of a single side of the world border, in meters. */
	NewDiameter Double // Double
	/* Number of real-time milliseconds until New Diameter is reached. It appears that Notchian server does not sync world border speed to game ticks, so it gets out of sync with server lag. If the world border is not moving, this is set to 0. */
	Speed VarLong // VarLong
}

var _ Packet = (*PlaySetBorderLerpSize_763_0)(nil)

func (p PlaySetBorderLerpSize_763_0)Encode(b *PacketBuilder){
	b.Double(p.OldDiameter)
	b.Double(p.NewDiameter)
	b.VarLong(p.Speed)
}

func (p *PlaySetBorderLerpSize_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.OldDiameter, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.NewDiameter, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Speed, ok = r.VarLong(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x49
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x49
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x45
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x46
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x43
type PlaySetBorderSize_763_0 struct {
	/* Length of a single side of the world border, in meters. */
	Diameter Double // Double
}

var _ Packet = (*PlaySetBorderSize_763_0)(nil)

func (p PlaySetBorderSize_763_0)Encode(b *PacketBuilder){
	b.Double(p.Diameter)
}

func (p *PlaySetBorderSize_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Diameter, ok = r.Double(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x4a
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x4a
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x46
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x47
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x44
type PlaySetBorderWarningDelay_763_0 struct {
	/* In seconds as set by /worldborder warning time. */
	WarningTime VarInt // VarInt
}

var _ Packet = (*PlaySetBorderWarningDelay_763_0)(nil)

func (p PlaySetBorderWarningDelay_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.WarningTime)
}

func (p *PlaySetBorderWarningDelay_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WarningTime, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x4b
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x4b
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x47
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x48
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x45
type PlaySetBorderWarningDistance_763_0 struct {
	/* In meters. */
	WarningBlocks VarInt // VarInt
}

var _ Packet = (*PlaySetBorderWarningDistance_763_0)(nil)

func (p PlaySetBorderWarningDistance_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.WarningBlocks)
}

func (p *PlaySetBorderWarningDistance_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WarningBlocks, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x4c
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x4c
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x48
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x49
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x46
type PlaySetCamera_763_0 struct {
	/* ID of the entity to set the client's camera to. */
	CameraID VarInt // VarInt
}

var _ Packet = (*PlaySetCamera_763_0)(nil)

func (p PlaySetCamera_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.CameraID)
}

func (p *PlaySetCamera_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.CameraID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x4e
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x4e
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x4a
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x4b
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x48
type PlaySetCenterChunk_763_0 struct {
	/* Chunk X coordinate of the player's position. */
	ChunkX VarInt // VarInt
	/* Chunk Z coordinate of the player's position. */
	ChunkZ VarInt // VarInt
}

var _ Packet = (*PlaySetCenterChunk_763_0)(nil)

func (p PlaySetCenterChunk_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.ChunkX)
	b.VarInt(p.ChunkZ)
}

func (p *PlaySetCenterChunk_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ChunkX, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ChunkZ, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x12
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x12
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x10
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x11
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x11
type PlaySetContainerContent_763_0 struct {
	/* The ID of window which items are being sent for. 0 for player inventory. */
	WindowID UByte // Unsigned Byte
	/* The last received State ID from either a Set Container Slot or a Set Container Content packet */
	StateID VarInt // VarInt
	/* Number of elements in the following array. */
	Count VarInt // VarInt
	SlotData []*data.Slot // Array of Slot
	/* Item held by player. */
	CarriedItem *data.Slot // Slot
}

var _ Packet = (*PlaySetContainerContent_763_0)(nil)

func (p PlaySetContainerContent_763_0)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
	b.VarInt(p.StateID)
	p.Count = (VarInt)(len(p.SlotData))
	b.VarInt(p.Count)
	for _, v := range p.SlotData {
		v.Encode(b)
	}
	p.CarriedItem.Encode(b)
}

func (p *PlaySetContainerContent_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.StateID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Count, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.SlotData = make([]*data.Slot, p.Count)
	for i, _ := range p.SlotData {
		p.SlotData[i] = new(data.Slot)
		if err = p.SlotData[i].DecodeFrom(r); err != nil {
			return err
		}
	}
	p.CarriedItem = new(data.Slot)
	if err = p.CarriedItem.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x13
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x13
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x11
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x12
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x12
type PlaySetContainerProperty_763_0 struct {
	WindowID UByte // Unsigned Byte
	/* The property to be updated, see below. */
	Property Short // Short
	/* The new value for the property, see below. */
	Value Short // Short
}

var _ Packet = (*PlaySetContainerProperty_763_0)(nil)

func (p PlaySetContainerProperty_763_0)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
	b.Short(p.Property)
	b.Short(p.Value)
}

func (p *PlaySetContainerProperty_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Property, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.Value, ok = r.Short(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x14
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x14
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x12
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x13
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x13
type PlaySetContainerSlot_763_0 struct {
	/* The window which is being updated. 0 for player inventory. Note that all known window types include the player inventory. This packet will only be sent for the currently opened window while the player is performing actions, even if it affects the player inventory. After the window is closed, a number of these packets are sent to update the player's inventory window (0). */
	WindowID Byte // Byte
	/* The last received State ID from either a Set Container Slot or a Set Container Content packet */
	StateID VarInt // VarInt
	/* The slot that should be updated. */
	Slot Short // Short
	SlotData *data.Slot // Slot
}

var _ Packet = (*PlaySetContainerSlot_763_0)(nil)

func (p PlaySetContainerSlot_763_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.VarInt(p.StateID)
	b.Short(p.Slot)
	p.SlotData.Encode(b)
}

func (p *PlaySetContainerSlot_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.StateID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Slot, ok = r.Short(); !ok {
		return io.EOF
	}
	p.SlotData = new(data.Slot)
	if err = p.SlotData.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x15
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x15
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x13
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x14
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x14
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x17
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x17
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x17
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x17
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x16
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x16
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x18
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x17
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x18
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x17
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x17
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x17
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x17
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x17
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x17
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x17
type PlaySetCooldown_763_0 struct {
	/* Numeric ID of the item to apply a cooldown to. */
	ItemID VarInt // VarInt
	/* Number of ticks to apply a cooldown for, or 0 to clear the cooldown. */
	CooldownTicks VarInt // VarInt
}

var _ Packet = (*PlaySetCooldown_763_0)(nil)

func (p PlaySetCooldown_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.ItemID)
	b.VarInt(p.CooldownTicks)
}

func (p *PlaySetCooldown_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ItemID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.CooldownTicks, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x2b
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x2b
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x2b
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x2b
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x2a
type PlaySetCreativeModeSlot_763_0 struct {
	/* Inventory slot. */
	Slot Short // Short
	ClickedItem *data.Slot // Slot
}

var _ Packet = (*PlaySetCreativeModeSlot_763_0)(nil)

func (p PlaySetCreativeModeSlot_763_0)Encode(b *PacketBuilder){
	b.Short(p.Slot)
	p.ClickedItem.Encode(b)
}

func (p *PlaySetCreativeModeSlot_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Slot, ok = r.Short(); !ok {
		return io.EOF
	}
	p.ClickedItem = new(data.Slot)
	if err = p.ClickedItem.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x50
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x50
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x4c
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x4d
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x4a
type PlaySetDefaultSpawnPosition_763_0 struct {
	/* Spawn location. */
	Location Position // Position
	/* The angle at which to respawn at. */
	Angle Float // Float
}

var _ Packet = (*PlaySetDefaultSpawnPosition_763_0)(nil)

func (p PlaySetDefaultSpawnPosition_763_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.Float(p.Angle)
}

func (p *PlaySetDefaultSpawnPosition_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Angle, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x2
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x2
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x2
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x2
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x2
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x2
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x2
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x2
type PlaySetDifficulty_758_0 struct {
	/* 0: peaceful, 1: easy, 2: normal, 3: hard */
	NewDifficulty Byte // Byte
}

var _ Packet = (*PlaySetDifficulty_758_0)(nil)

func (p PlaySetDifficulty_758_0)Encode(b *PacketBuilder){
	b.Byte(p.NewDifficulty)
}

func (p *PlaySetDifficulty_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.NewDifficulty, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x4e
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x4b
type PlaySetDisplayChatPreview_760_0 struct {
	ChatPreviewSetting Bool // Boolean
}

var _ Packet = (*PlaySetDisplayChatPreview_760_0)(nil)

func (p PlaySetDisplayChatPreview_760_0)Encode(b *PacketBuilder){
	b.Bool(p.ChatPreviewSetting)
}

func (p *PlaySetDisplayChatPreview_760_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ChatPreviewSetting, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x1f
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x1f
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x1f
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x1f
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x1f
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x1e
type PlaySetDisplayedRecipe_758_0 struct {
	RecipeID String // Identifier
}

var _ Packet = (*PlaySetDisplayedRecipe_758_0)(nil)

func (p PlaySetDisplayedRecipe_758_0)Encode(b *PacketBuilder){
	b.String(p.RecipeID)
}

func (p *PlaySetDisplayedRecipe_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.RecipeID, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x52
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x52
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x4e
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x50
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x4d
type PlaySetEntityMetadata_763_0 struct {
	EntityID VarInt // VarInt
	Metadata *data.EntityMetadata // Entity Metadata
}

var _ Packet = (*PlaySetEntityMetadata_763_0)(nil)

func (p PlaySetEntityMetadata_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	p.Metadata.Encode(b)
}

func (p *PlaySetEntityMetadata_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Metadata = new(data.EntityMetadata)
	if err = p.Metadata.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x54
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x54
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x50
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x52
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x4f
type PlaySetEntityVelocity_763_0 struct {
	EntityID VarInt // VarInt
	/* Velocity on the X axis. */
	VelocityX Short // Short
	/* Velocity on the Y axis. */
	VelocityY Short // Short
	/* Velocity on the Z axis. */
	VelocityZ Short // Short
}

var _ Packet = (*PlaySetEntityVelocity_763_0)(nil)

func (p PlaySetEntityVelocity_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Short(p.VelocityX)
	b.Short(p.VelocityY)
	b.Short(p.VelocityZ)
}

func (p *PlaySetEntityVelocity_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.VelocityX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityZ, ok = r.Short(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x55
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x55
type PlaySetEquipment_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name | Field Type | Field Type | Notes                                                                                                                                                                                                                          |
	 * |-----------|-------|----------|------------|------------|------------|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x55      | Play  | Client   | Entity ID  | Entity ID  | VarInt     | VarInt     | Entity's ID.                                                                                                                                                                                                                   |
	 * | 0x55      | Play  | Client   | Equipment  | Slot       | Array      | Byte Enum  | Equipment slot. 0: main hand, 1: off hand, 2–5: armor slot (2: boots, 3: leggings, 4: chestplate, 5: helmet).  Also has the top bit set if another entry follows, and otherwise unset if this is the last item in the array. |
	 * | 0x55      | Play  | Client   | Equipment  | Item       | Array      | Slot       |                                                                                                                                                                                                                                |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x56
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x56
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x52
type PlaySetExperience_763_0 struct {
	/* Between 0 and 1. */
	ExperienceBar Float // Float
	/* See Experience#Leveling up on the Minecraft Wiki for Total Experience to Level conversion. */
	TotalExperience VarInt // VarInt
	Level VarInt // VarInt
}

var _ Packet = (*PlaySetExperience_763_0)(nil)

func (p PlaySetExperience_763_0)Encode(b *PacketBuilder){
	b.Float(p.ExperienceBar)
	b.VarInt(p.TotalExperience)
	b.VarInt(p.Level)
}

func (p *PlaySetExperience_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ExperienceBar, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.TotalExperience, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Level, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x54
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x51
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x51
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x51
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x51
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x51
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x48
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x48
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x48
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x47
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x43
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x40
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x40
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x3f
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x3d
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x3d
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x3d
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x3d
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x1f
type PlaySetExperience_760_1 struct {
	/* Between 0 and 1 */
	ExperienceBar Float // Float
	Level VarInt // VarInt
	/* See Experience#Leveling up on the Minecraft Wiki for Total Experience to Level conversion */
	TotalExperience VarInt // VarInt
}

var _ Packet = (*PlaySetExperience_760_1)(nil)

func (p PlaySetExperience_760_1)Encode(b *PacketBuilder){
	b.Float(p.ExperienceBar)
	b.VarInt(p.Level)
	b.VarInt(p.TotalExperience)
}

func (p *PlaySetExperience_760_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ExperienceBar, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Level, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.TotalExperience, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x42
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x42
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x3e
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x3f
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x3c
type PlaySetHeadRotation_763_0 struct {
	EntityID VarInt // VarInt
	/* New angle, not a delta. */
	HeadYaw Angle // Angle
}

var _ Packet = (*PlaySetHeadRotation_763_0)(nil)

func (p PlaySetHeadRotation_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UByte(p.HeadYaw)
}

func (p *PlaySetHeadRotation_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.HeadYaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x57
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x57
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x53
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x55
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x52
type PlaySetHealth_763_0 struct {
	/* 0 or less = dead, 20 = full HP. */
	Health Float // Float
	/* 0–20. */
	Food VarInt // VarInt
	/* Seems to vary from 0.0 to 5.0 in integer increments. */
	FoodSaturation Float // Float
}

var _ Packet = (*PlaySetHealth_763_0)(nil)

func (p PlaySetHealth_763_0)Encode(b *PacketBuilder){
	b.Float(p.Health)
	b.VarInt(p.Food)
	b.Float(p.FoodSaturation)
}

func (p *PlaySetHealth_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Health, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Food, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.FoodSaturation, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x4d
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x4d
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x49
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x4a
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x47
type PlaySetHeldItem_763_0 struct {
	/* The slot which the player has selected (0–8). */
	Slot Byte // Byte
}

var _ Packet = (*PlaySetHeldItem_763_0)(nil)

func (p PlaySetHeldItem_763_0)Encode(b *PacketBuilder){
	b.Byte(p.Slot)
}

func (p *PlaySetHeldItem_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Slot, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x28
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x28
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x28
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x28
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x27
type PlaySetHeldItemServer_763_0 struct {
	/* The slot which the player has selected (0–8). */
	Slot Short // Short
}

var _ Packet = (*PlaySetHeldItemServer_763_0)(nil)

func (p PlaySetHeldItemServer_763_0)Encode(b *PacketBuilder){
	b.Short(p.Slot)
}

func (p *PlaySetHeldItemServer_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Slot, ok = r.Short(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x59
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x59
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x55
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x57
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x54
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x54
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x54
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x54
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x54
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x4b
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x4b
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x4b
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x4a
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x46
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x43
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x43
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x42
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x40
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x40
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x40
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x40
type PlaySetPassengers_763_0 struct {
	/* Vehicle's EID */
	EntityID VarInt // VarInt
	/* Number of elements in the following array */
	PassengerCount VarInt // VarInt
	/* EIDs of entity's passengers */
	Passengers []VarInt // Array of VarInt
}

var _ Packet = (*PlaySetPassengers_763_0)(nil)

func (p PlaySetPassengers_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	p.PassengerCount = (VarInt)(len(p.Passengers))
	b.VarInt(p.PassengerCount)
	for _, v := range p.Passengers {
		b.VarInt(v)
	}
}

func (p *PlaySetPassengers_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.PassengerCount, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Passengers = make([]VarInt, p.PassengerCount)
	for i, _ := range p.Passengers {
		if p.Passengers[i], ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x17
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x17
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x16
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x17
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x16
type PlaySetPlayerOnGround_763_0 struct {
	/* True if the client is on the ground, false otherwise. */
	OnGround Bool // Boolean
}

var _ Packet = (*PlaySetPlayerOnGround_763_0)(nil)

func (p PlaySetPlayerOnGround_763_0)Encode(b *PacketBuilder){
	b.Bool(p.OnGround)
}

func (p *PlaySetPlayerOnGround_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x14
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x14
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x13
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x14
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x13
type PlaySetPlayerPosition_763_0 struct {
	/* Absolute position. */
	X Double // Double
	/* Absolute feet position, normally Head Y - 1.62. */
	FeetY Double // Double
	/* Absolute position. */
	Z Double // Double
	/* True if the client is on the ground, false otherwise. */
	OnGround Bool // Boolean
}

var _ Packet = (*PlaySetPlayerPosition_763_0)(nil)

func (p PlaySetPlayerPosition_763_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.FeetY)
	b.Double(p.Z)
	b.Bool(p.OnGround)
}

func (p *PlaySetPlayerPosition_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.FeetY, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x15
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x15
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x14
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x15
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x14
type PlaySetPlayerPositionAndRotation_763_0 struct {
	/* Absolute position. */
	X Double // Double
	/* Absolute feet position, normally Head Y - 1.62. */
	FeetY Double // Double
	/* Absolute position. */
	Z Double // Double
	/* Absolute rotation on the X Axis, in degrees. */
	Yaw Float // Float
	/* Absolute rotation on the Y Axis, in degrees. */
	Pitch Float // Float
	/* True if the client is on the ground, false otherwise. */
	OnGround Bool // Boolean
}

var _ Packet = (*PlaySetPlayerPositionAndRotation_763_0)(nil)

func (p PlaySetPlayerPositionAndRotation_763_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.FeetY)
	b.Double(p.Z)
	b.Float(p.Yaw)
	b.Float(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlaySetPlayerPositionAndRotation_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.FeetY, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x16
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x16
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x15
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x16
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x15
type PlaySetPlayerRotation_763_0 struct {
	/* Absolute rotation on the X Axis, in degrees. */
	Yaw Float // Float
	/* Absolute rotation on the Y Axis, in degrees. */
	Pitch Float // Float
	/* True if the client is on the ground, false otherwise. */
	OnGround Bool // Boolean
}

var _ Packet = (*PlaySetPlayerRotation_763_0)(nil)

func (p PlaySetPlayerRotation_763_0)Encode(b *PacketBuilder){
	b.Float(p.Yaw)
	b.Float(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlaySetPlayerRotation_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x1e
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x1e
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x1e
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x1e
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x1e
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x1f
type PlaySetRecipeBookState_758_0 struct {
	/* 0: crafting, 1: furnace, 2: blast furnace, 3: smoker */
	BookID VarInt // VarInt enum
	BookOpen Bool // Boolean
	FilterActive Bool // Boolean
}

var _ Packet = (*PlaySetRecipeBookState_758_0)(nil)

func (p PlaySetRecipeBookState_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.BookID)
	b.Bool(p.BookOpen)
	b.Bool(p.FilterActive)
}

func (p *PlaySetRecipeBookState_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.BookID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.BookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.FilterActive, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x4f
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x4f
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x4b
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x4c
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x49
type PlaySetRenderDistance_763_0 struct {
	/* Render distance (2-32). */
	ViewDistance VarInt // VarInt
}

var _ Packet = (*PlaySetRenderDistance_763_0)(nil)

func (p PlaySetRenderDistance_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.ViewDistance)
}

func (p *PlaySetRenderDistance_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ViewDistance, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x22
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x22
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x22
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x22
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x21
type PlaySetSeenRecipe_763_0 struct {
	RecipeID String // Identifier
}

var _ Packet = (*PlaySetSeenRecipe_763_0)(nil)

func (p PlaySetSeenRecipe_763_0)Encode(b *PacketBuilder){
	b.String(p.RecipeID)
}

func (p *PlaySetSeenRecipe_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.RecipeID, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x5c
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x5c
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x58
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x5a
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x57
type PlaySetSimulationDistance_763_0 struct {
	/* The distance that the client will process specific things, such as entities. */
	SimulationDistance VarInt // VarInt
}

var _ Packet = (*PlaySetSimulationDistance_763_0)(nil)

func (p PlaySetSimulationDistance_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.SimulationDistance)
}

func (p *PlaySetSimulationDistance_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SimulationDistance, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x16
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x16
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x16
type PlaySetSlot_758_0 struct {
	/* The window which is being updated. 0 for player inventory. Note that all known window types include the player inventory. This packet will only be sent for the currently opened window while the player is performing actions, even if it affects the player inventory. After the window is closed, a number of these packets are sent to update the player's inventory window (0). */
	WindowID Byte // Byte
	/* See State ID */
	StateID VarInt // VarInt
	/* The slot that should be updated. */
	Slot Short // Short
	SlotData *data.Slot // Slot
}

var _ Packet = (*PlaySetSlot_758_0)(nil)

func (p PlaySetSlot_758_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.VarInt(p.StateID)
	b.Short(p.Slot)
	p.SlotData.Encode(b)
}

func (p *PlaySetSlot_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.StateID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Slot, ok = r.Short(); !ok {
		return io.EOF
	}
	p.SlotData = new(data.Slot)
	if err = p.SlotData.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x16
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x15
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x15
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x17
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x16
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x17
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x16
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x16
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x16
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x16
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x16
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x16
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x16
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x2f
type PlaySetSlot_755_1 struct {
	/* The window which is being updated. 0 for player inventory. Note that all known window types include the player inventory. This packet will only be sent for the currently opened window while the player is performing actions, even if it affects the player inventory. After the window is closed, a number of these packets are sent to update the player's inventory window (0). */
	WindowID Byte // Byte
	/* The slot that should be updated */
	Slot Short // Short
	SlotData *data.Slot // Slot
}

var _ Packet = (*PlaySetSlot_755_1)(nil)

func (p PlaySetSlot_755_1)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.Short(p.Slot)
	p.SlotData.Encode(b)
}

func (p *PlaySetSlot_755_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Slot, ok = r.Short(); !ok {
		return io.EOF
	}
	p.SlotData = new(data.Slot)
	if err = p.SlotData.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x5d
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x5d
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x59
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x5b
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x58
type PlaySetSubtitleText_763_0 struct {
	SubtitleText Object // Chat
}

var _ Packet = (*PlaySetSubtitleText_763_0)(nil)

func (p PlaySetSubtitleText_763_0)Encode(b *PacketBuilder){
	b.JSON(p.SubtitleText)
}

func (p *PlaySetSubtitleText_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.SubtitleText); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x65
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x65
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x61
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x63
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x60
type PlaySetTabListHeaderAndFooter_763_0 struct {
	/* To remove the header, send a empty text component: {"text":""}. */
	Header Object // Chat
	/* To remove the footer, send a empty text component: {"text":""}. */
	Footer Object // Chat
}

var _ Packet = (*PlaySetTabListHeaderAndFooter_763_0)(nil)

func (p PlaySetTabListHeaderAndFooter_763_0)Encode(b *PacketBuilder){
	b.JSON(p.Header)
	b.JSON(p.Footer)
}

func (p *PlaySetTabListHeaderAndFooter_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.Header); err != nil {
		return err
	}
	if err = r.JSON(&p.Footer); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x60
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x60
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x5c
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x5e
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x5b
type PlaySetTitleAnimationTimes_763_0 struct {
	/* Ticks to spend fading in. */
	FadeIn Int // Int
	/* Ticks to keep the title displayed. */
	Stay Int // Int
	/* Ticks to spend fading out, not when to start fading out. */
	FadeOut Int // Int
}

var _ Packet = (*PlaySetTitleAnimationTimes_763_0)(nil)

func (p PlaySetTitleAnimationTimes_763_0)Encode(b *PacketBuilder){
	b.Int(p.FadeIn)
	b.Int(p.Stay)
	b.Int(p.FadeOut)
}

func (p *PlaySetTitleAnimationTimes_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.FadeIn, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.Stay, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.FadeOut, ok = r.Int(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x58
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x58
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x57
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x57
type PlaySetTitleSubTitle_758_0 struct {
	SubtitleText Object // Chat
}

var _ Packet = (*PlaySetTitleSubTitle_758_0)(nil)

func (p PlaySetTitleSubTitle_758_0)Encode(b *PacketBuilder){
	b.JSON(p.SubtitleText)
}

func (p *PlaySetTitleSubTitle_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.SubtitleText); err != nil {
		return err
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x5f
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x5f
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x5b
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x5d
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x5a
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x5a
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x5a
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x59
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x59
type PlaySetTitleText_763_0 struct {
	TitleText Object // Chat
}

var _ Packet = (*PlaySetTitleText_763_0)(nil)

func (p PlaySetTitleText_763_0)Encode(b *PacketBuilder){
	b.JSON(p.TitleText)
}

func (p *PlaySetTitleText_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.TitleText); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x5b
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x5b
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x5a
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x5a
type PlaySetTitleTimes_758_0 struct {
	/* Ticks to spend fading in. */
	FadeIn Int // Int
	/* Ticks to keep the title displayed. */
	Stay Int // Int
	/* Ticks to spend out, not when to start fading out. */
	FadeOut Int // Int
}

var _ Packet = (*PlaySetTitleTimes_758_0)(nil)

func (p PlaySetTitleTimes_758_0)Encode(b *PacketBuilder){
	b.Int(p.FadeIn)
	b.Int(p.Stay)
	b.Int(p.FadeOut)
}

func (p *PlaySetTitleTimes_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.FadeIn, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.Stay, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.FadeOut, ok = r.Int(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x62
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x62
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x5e
type PlaySoundEffect_763_0 struct {
	/* Represents the Sound ID + 1. If the value is 0, the packet contains a sound specified by Identifier. */
	SoundID VarInt // VarInt
	/* Only present if Sound ID is 0 */
	SoundName Optional[String] // Optional Identifier
	/* Only present if Sound ID is 0. */
	HasFixedRange Optional[Bool] // Optional Boolean
	/* The fixed range of the sound. Only present if previous boolean is true and Sound ID is 0. */
	Range Optional[Float] // Optional Float
	/* The category that this sound will be played from (current categories). */
	SoundCategory VarInt // VarInt Enum
	/* Effect X multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part). */
	EffectPositionX Int // Int
	/* Effect Y multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part). */
	EffectPositionY Int // Int
	/* Effect Z multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part). */
	EffectPositionZ Int // Int
	/* 1.0 is 100%, capped between 0.0 and 1.0 by Notchian clients. */
	Volume Float // Float
	/* Float between 0.5 and 2.0 by Notchian clients. */
	Pitch Float // Float
	/* Seed used to pick sound variant. */
	Seed Long // Long
}

var _ Packet = (*PlaySoundEffect_763_0)(nil)

func (p PlaySoundEffect_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.SoundID)
	if p.SoundID == 0 {
		b.String(p.SoundName.Assert())
		p.HasFixedRange.Set(p.Range.Ok)
		b.Bool(p.HasFixedRange.V)
		if p.Range.Ok {
			b.Float(p.Range.V)
		}
	}
	b.VarInt(p.SoundCategory)
	b.Int(p.EffectPositionX)
	b.Int(p.EffectPositionY)
	b.Int(p.EffectPositionZ)
	b.Float(p.Volume)
	b.Float(p.Pitch)
	b.Long(p.Seed)
}

func (p *PlaySoundEffect_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SoundID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.SoundName.Ok = p.SoundID == 0; p.SoundName.Ok {
		if p.SoundName.V, ok = r.String(); !ok {
			return io.EOF
		}
	}
	if p.HasFixedRange.Ok = p.SoundID == 0; p.HasFixedRange.Ok {
		if p.HasFixedRange.V, ok = r.Bool(); !ok {
			return io.EOF
		}
	}
	if p.Range.Ok = p.SoundID == 0 && p.HasFixedRange.V; p.Range.Ok {
		if p.Range.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.SoundCategory, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EffectPositionX, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.EffectPositionY, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.EffectPositionZ, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.Volume, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Seed, ok = r.Long(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x60
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x5d
type PlaySoundEffect_760_1 struct {
	/* ID of hardcoded sound event (events). */
	SoundID VarInt // VarInt
	/* The category that this sound will be played from (current categories). */
	SoundCategory VarInt // VarInt Enum
	/* Effect X multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part). */
	EffectPositionX Int // Int
	/* Effect Y multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part). */
	EffectPositionY Int // Int
	/* Effect Z multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part). */
	EffectPositionZ Int // Int
	/* 1.0 is 100%, capped between 0.0 and 1.0 by Notchian clients. */
	Volume Float // Float
	/* Float between 0.5 and 2.0 by Notchian clients. */
	Pitch Float // Float
	/* Seed used to pick sound variant. */
	Seed Long // long
}

var _ Packet = (*PlaySoundEffect_760_1)(nil)

func (p PlaySoundEffect_760_1)Encode(b *PacketBuilder){
	b.VarInt(p.SoundID)
	b.VarInt(p.SoundCategory)
	b.Int(p.EffectPositionX)
	b.Int(p.EffectPositionY)
	b.Int(p.EffectPositionZ)
	b.Float(p.Volume)
	b.Float(p.Pitch)
	b.Long(p.Seed)
}

func (p *PlaySoundEffect_760_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SoundID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.SoundCategory, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EffectPositionX, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.EffectPositionY, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.EffectPositionZ, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.Volume, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Seed, ok = r.Long(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x5d
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x5d
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x5c
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x5c
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x51
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x51
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x52
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x51
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x4d
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x49
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x49
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x48
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x46
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x46
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x46
type PlaySoundEffect_758_2 struct {
	/* ID of hardcoded sound event (events as of 1.12.2) */
	SoundID VarInt // VarInt
	/* The category that this sound will be played from (current categories) */
	SoundCategory VarInt // VarInt Enum
	/* Effect X multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part) */
	EffectPositionX Int // Int
	/* Effect Y multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part) */
	EffectPositionY Int // Int
	/* Effect Z multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part) */
	EffectPositionZ Int // Int
	/* 1.0 is 100%, capped between 0.0 and 1.0 by Notchian clients */
	Volume Float // Float
	/* Float between 0.5 and 2.0 by Notchian clients */
	Pitch Float // Float
}

var _ Packet = (*PlaySoundEffect_758_2)(nil)

func (p PlaySoundEffect_758_2)Encode(b *PacketBuilder){
	b.VarInt(p.SoundID)
	b.VarInt(p.SoundCategory)
	b.Int(p.EffectPositionX)
	b.Int(p.EffectPositionY)
	b.Int(p.EffectPositionZ)
	b.Float(p.Volume)
	b.Float(p.Pitch)
}

func (p *PlaySoundEffect_758_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SoundID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.SoundCategory, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EffectPositionX, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.EffectPositionY, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.EffectPositionZ, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.Volume, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x1
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x1
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x0
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x0
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x0
type PlaySpawnEntity_763_0 struct {
	/* A unique integer ID mostly used in the protocol to identify the entity. */
	EntityID VarInt // VarInt
	/* A unique identifier that is mostly used in persistence and places where the uniqueness matters more. */
	EntityUUID UUID // UUID
	/* The type of the entity (see "type" field of the list of Mob types). */
	Type VarInt // VarInt
	X Double // Double
	Y Double // Double
	Z Double // Double
	/* To get the real pitch, you must divide this by (256.0F / 360.0F) */
	Pitch Angle // Angle
	/* To get the real yaw, you must divide this by (256.0F / 360.0F) */
	Yaw Angle // Angle
	/* Only used by living entities, where the head of the entity may differ from the general body rotation. */
	HeadYaw Angle // Angle
	/* Meaning dependent on the value of the Type field, see Object Data for details. */
	Data VarInt // VarInt
	/* Same units as Set Entity Velocity. */
	VelocityX Short // Short
	VelocityY Short // Short
	VelocityZ Short // Short
}

var _ Packet = (*PlaySpawnEntity_763_0)(nil)

func (p PlaySpawnEntity_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UUID(p.EntityUUID)
	b.VarInt(p.Type)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.UByte(p.Pitch)
	b.UByte(p.Yaw)
	b.UByte(p.HeadYaw)
	b.VarInt(p.Data)
	b.Short(p.VelocityX)
	b.Short(p.VelocityY)
	b.Short(p.VelocityZ)
}

func (p *PlaySpawnEntity_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityUUID, ok = r.UUID(); !ok {
		return io.EOF
	}
	if p.Type, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.HeadYaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Data, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.VelocityX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityZ, ok = r.Short(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x0
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x0
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x0
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x0
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x0
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x0
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x0
type PlaySpawnEntity_758_1 struct {
	/* EID of the entity */
	EntityID VarInt // VarInt
	ObjectUUID UUID // UUID
	/* The type of entity (same as in Spawn Living Entity) */
	Type VarInt // VarInt
	X Double // Double
	Y Double // Double
	Z Double // Double
	Pitch Angle // Angle
	Yaw Angle // Angle
	/* Meaning dependent on the value of the Type field, see Object Data for details. */
	Data Int // Int
	/* Same units as Entity Velocity.  Always sent, but only used when Data is greater than 0 (except for some entities which always ignore it; see Object Data for details). */
	VelocityX Short // Short
	VelocityY Short // Short
	VelocityZ Short // Short
}

var _ Packet = (*PlaySpawnEntity_758_1)(nil)

func (p PlaySpawnEntity_758_1)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UUID(p.ObjectUUID)
	b.VarInt(p.Type)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.UByte(p.Pitch)
	b.UByte(p.Yaw)
	b.Int(p.Data)
	b.Short(p.VelocityX)
	b.Short(p.VelocityY)
	b.Short(p.VelocityZ)
}

func (p *PlaySpawnEntity_758_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ObjectUUID, ok = r.UUID(); !ok {
		return io.EOF
	}
	if p.Type, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Data, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.VelocityX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityZ, ok = r.Short(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x2
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x2
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x1
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x1
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x1
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x1
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x1
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x1
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x1
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x1
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x1
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x1
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x1
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x1
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x1
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x1
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x1
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x1
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x1
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x1
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x1
type PlaySpawnExperienceOrb_763_0 struct {
	EntityID VarInt // VarInt
	X Double // Double
	Y Double // Double
	Z Double // Double
	/* The amount of experience this orb will reward once collected */
	Count Short // Short
}

var _ Packet = (*PlaySpawnExperienceOrb_763_0)(nil)

func (p PlaySpawnExperienceOrb_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.Short(p.Count)
}

func (p *PlaySpawnExperienceOrb_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Count, ok = r.Short(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x2
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x2
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x2
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x2
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x2
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x2
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x2
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x2
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x2
type PlaySpawnGlobalEntity_498_0 struct {
	/* The EID of the thunderbolt */
	EntityID VarInt // VarInt
	/* The global entity type, currently always 1 for thunderbolt */
	Type Byte // Byte Enum
	X Double // Double
	Y Double // Double
	Z Double // Double
}

var _ Packet = (*PlaySpawnGlobalEntity_498_0)(nil)

func (p PlaySpawnGlobalEntity_498_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Byte(p.Type)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
}

func (p *PlaySpawnGlobalEntity_498_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Type, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x2
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x2
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x2
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x2
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x2
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x3
type PlaySpawnLivingEntity_757_1 struct {
	EntityID VarInt // VarInt
	EntityUUID UUID // UUID
	/* The type of mob. See Entities#Mobs */
	Type VarInt // VarInt
	X Double // Double
	Y Double // Double
	Z Double // Double
	Yaw Angle // Angle
	Pitch Angle // Angle
	HeadPitch Angle // Angle
	/* Same units as Entity Velocity */
	VelocityX Short // Short
	/* Same units as Entity Velocity */
	VelocityY Short // Short
	/* Same units as Entity Velocity */
	VelocityZ Short // Short
}

var _ Packet = (*PlaySpawnLivingEntity_757_1)(nil)

func (p PlaySpawnLivingEntity_757_1)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UUID(p.EntityUUID)
	b.VarInt(p.Type)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
	b.UByte(p.HeadPitch)
	b.Short(p.VelocityX)
	b.Short(p.VelocityY)
	b.Short(p.VelocityZ)
}

func (p *PlaySpawnLivingEntity_757_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityUUID, ok = r.UUID(); !ok {
		return io.EOF
	}
	if p.Type, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.HeadPitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.VelocityX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityZ, ok = r.Short(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x3
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x3
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x3
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x3
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x3
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x3
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x3
type PlaySpawnMob_498_0 struct {
	EntityID VarInt // VarInt
	EntityUUID UUID // UUID
	/* The type of mob. See Entities#Mobs */
	Type VarInt // VarInt
	X Double // Double
	Y Double // Double
	Z Double // Double
	Yaw Angle // Angle
	Pitch Angle // Angle
	HeadPitch Angle // Angle
	/* Same units as Entity Velocity */
	VelocityX Short // Short
	/* Same units as Entity Velocity */
	VelocityY Short // Short
	/* Same units as Entity Velocity */
	VelocityZ Short // Short
	Metadata *data.EntityMetadata // Entity Metadata
}

var _ Packet = (*PlaySpawnMob_498_0)(nil)

func (p PlaySpawnMob_498_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UUID(p.EntityUUID)
	b.VarInt(p.Type)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
	b.UByte(p.HeadPitch)
	b.Short(p.VelocityX)
	b.Short(p.VelocityY)
	b.Short(p.VelocityZ)
	p.Metadata.Encode(b)
}

func (p *PlaySpawnMob_498_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityUUID, ok = r.UUID(); !ok {
		return io.EOF
	}
	if p.Type, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.HeadPitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.VelocityX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityZ, ok = r.Short(); !ok {
		return io.EOF
	}
	p.Metadata = new(data.EntityMetadata)
	if err = p.Metadata.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x3
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x3
type PlaySpawnMob_210_1 struct {
	EntityID VarInt // VarInt
	EntityUUID UUID // UUID
	/* The type of mob. See Entities#Mobs */
	Type UByte // Unsigned Byte
	X Double // Double
	Y Double // Double
	Z Double // Double
	Yaw Angle // Angle
	Pitch Angle // Angle
	HeadPitch Angle // Angle
	/* Same units as Entity Velocity */
	VelocityX Short // Short
	/* Same units as Entity Velocity */
	VelocityY Short // Short
	/* Same units as Entity Velocity */
	VelocityZ Short // Short
	Metadata *data.EntityMetadata // Entity Metadata
}

var _ Packet = (*PlaySpawnMob_210_1)(nil)

func (p PlaySpawnMob_210_1)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UUID(p.EntityUUID)
	b.UByte(p.Type)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
	b.UByte(p.HeadPitch)
	b.Short(p.VelocityX)
	b.Short(p.VelocityY)
	b.Short(p.VelocityZ)
	p.Metadata.Encode(b)
}

func (p *PlaySpawnMob_210_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityUUID, ok = r.UUID(); !ok {
		return io.EOF
	}
	if p.Type, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.HeadPitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.VelocityX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityZ, ok = r.Short(); !ok {
		return io.EOF
	}
	p.Metadata = new(data.EntityMetadata)
	if err = p.Metadata.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x0
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x0
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x0
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x0
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x0
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x0
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x0
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x0
type PlaySpawnObject_404_1 struct {
	/* EID of the object */
	EntityID VarInt // VarInt
	ObjectUUID UUID // UUID
	/* The type of object (see Entities#Objects) */
	Type Byte // Byte
	X Double // Double
	Y Double // Double
	Z Double // Double
	Pitch Angle // Angle
	Yaw Angle // Angle
	/* Meaning dependent on the value of the Type field, see Object Data for details. */
	Data Int // Int
	/* Same units as Entity Velocity.  Always sent, but only used when Data is greater than 0 (except for some entities which always ignore it; see Object Data for details). */
	VelocityX Short // Short
	VelocityY Short // Short
	VelocityZ Short // Short
}

var _ Packet = (*PlaySpawnObject_404_1)(nil)

func (p PlaySpawnObject_404_1)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UUID(p.ObjectUUID)
	b.Byte(p.Type)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.UByte(p.Pitch)
	b.UByte(p.Yaw)
	b.Int(p.Data)
	b.Short(p.VelocityX)
	b.Short(p.VelocityY)
	b.Short(p.VelocityZ)
}

func (p *PlaySpawnObject_404_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ObjectUUID, ok = r.UUID(); !ok {
		return io.EOF
	}
	if p.Type, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Data, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.VelocityX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.VelocityZ, ok = r.Short(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x3
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x3
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x3
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x3
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x3
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x3
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x4
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x4
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x4
type PlaySpawnPainting_758_0 struct {
	EntityID VarInt // VarInt
	EntityUUID UUID // UUID
	/* Panting's ID, see below */
	Motive VarInt // VarInt
	/* Center coordinates (see below) */
	Location Position // Position
	/* Direction the painting faces (North = 2, South = 0, West = 1, East = 3) */
	Direction Byte // Byte Enum
}

var _ Packet = (*PlaySpawnPainting_758_0)(nil)

func (p PlaySpawnPainting_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UUID(p.EntityUUID)
	b.VarInt(p.Motive)
	p.Location.Encode(b)
	b.Byte(p.Direction)
}

func (p *PlaySpawnPainting_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityUUID, ok = r.UUID(); !ok {
		return io.EOF
	}
	if p.Motive, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Direction, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x4
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x4
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x4
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x4
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x4
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x4
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x4
type PlaySpawnPainting_340_1 struct {
	EntityID VarInt // VarInt
	EntityUUID UUID // UUID
	/* Name of the painting. Max length 13 */
	Title String // String (13)
	/* Center coordinates (see below) */
	Location Position // Position
	/* Direction the painting faces (North = 2, South = 0, West = 1, East = 3) */
	Direction Byte // Byte Enum
}

var _ Packet = (*PlaySpawnPainting_340_1)(nil)

func (p PlaySpawnPainting_340_1)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UUID(p.EntityUUID)
	b.String(p.Title)
	p.Location.Encode(b)
	b.Byte(p.Direction)
}

func (p *PlaySpawnPainting_340_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.EntityUUID, ok = r.UUID(); !ok {
		return io.EOF
	}
	if p.Title, ok = r.String(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Direction, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x3
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x3
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x2
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x2
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x2
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x4
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x4
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x4
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x4
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x4
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x4
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x5
type PlaySpawnPlayer_763_0 struct {
	/* Player's EID */
	EntityID VarInt // VarInt
	/* See below for notes on offline mode and NPCs */
	PlayerUUID UUID // UUID
	X Double // Double
	Y Double // Double
	Z Double // Double
	Yaw Angle // Angle
	Pitch Angle // Angle
}

var _ Packet = (*PlaySpawnPlayer_763_0)(nil)

func (p PlaySpawnPlayer_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UUID(p.PlayerUUID)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
}

func (p *PlaySpawnPlayer_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.PlayerUUID, ok = r.UUID(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x5
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x5
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x5
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x5
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x5
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x5
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x5
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x5
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x5
type PlaySpawnPlayer_498_1 struct {
	/* Player's EID */
	EntityID VarInt // VarInt
	/* See below for notes on offline mode and NPCs */
	PlayerUUID UUID // UUID
	X Double // Double
	Y Double // Double
	Z Double // Double
	Yaw Angle // Angle
	Pitch Angle // Angle
	Metadata *data.EntityMetadata // Entity Metadata
}

var _ Packet = (*PlaySpawnPlayer_498_1)(nil)

func (p PlaySpawnPlayer_498_1)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UUID(p.PlayerUUID)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
	p.Metadata.Encode(b)
}

func (p *PlaySpawnPlayer_498_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.PlayerUUID, ok = r.UUID(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	p.Metadata = new(data.EntityMetadata)
	if err = p.Metadata.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x4b
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x4b
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x4b
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x4b
type PlaySpawnPosition_758_0 struct {
	/* Spawn location. */
	Location Position // Position
	/* The angle at which to respawn at. */
	Angle Float // Float
}

var _ Packet = (*PlaySpawnPosition_758_0)(nil)

func (p PlaySpawnPosition_758_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.Float(p.Angle)
}

func (p *PlaySpawnPosition_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Angle, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x42
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x42
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x4e
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x4d
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x49
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x46
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x46
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x45
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x43
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x43
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x43
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x43
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x5
type PlaySpawnPosition_754_1 struct {
	/* Spawn location */
	Location Position // Position
}

var _ Packet = (*PlaySpawnPosition_754_1)(nil)

func (p PlaySpawnPosition_754_1)Encode(b *PacketBuilder){
	p.Location.Encode(b)
}

func (p *PlaySpawnPosition_754_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x2d
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x2d
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x2d
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x2d
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x2d
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x2d
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x2b
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x2b
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x28
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x1e
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x1e
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x1e
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x1b
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x1b
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x1b
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x1b
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x18
type PlaySpectate_758_0 struct {
	/* UUID of the player to teleport to (can also be an entity UUID) */
	TargetPlayer UUID // UUID
}

var _ Packet = (*PlaySpectate_758_0)(nil)

func (p PlaySpectate_758_0)Encode(b *PacketBuilder){
	b.UUID(p.TargetPlayer)
}

func (p *PlaySpectate_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TargetPlayer, ok = r.UUID(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x7
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x7
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x7
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x7
type PlayStatistics_758_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name   | Field Type | Field Type | Notes                                      |
	 * |-----------|-------|----------|------------|--------------|------------|------------|--------------------------------------------|
	 * | 0x07      | Play  | Client   | Count      | Count        | VarInt     | VarInt     | Number of elements in the following array. |
	 * | 0x07      | Play  | Client   | Statistic  | Category ID  | Array      | VarInt     | See below.                                 |
	 * | 0x07      | Play  | Client   | Statistic  | Statistic ID | Array      | VarInt     | See below.                                 |
	 * | 0x07      | Play  | Client   | Statistic  | Value        | Array      | VarInt     | The amount to set it to.                   |
	 * 
	 */
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x6
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x6
type PlayStatistics_754_1 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name   | Field Type | Field Type | Notes                                     |
	 * |-----------|-------|----------|------------|--------------|------------|------------|-------------------------------------------|
	 * | 0x06      | Play  | Client   | Count      | Count        | VarInt     | VarInt     | Number of elements in the following array |
	 * | 0x06      | Play  | Client   | Statistic  | Category ID  | Array      | VarInt     | See below                                 |
	 * | 0x06      | Play  | Client   | Statistic  | Statistic ID | Array      | VarInt     | See below                                 |
	 * | 0x06      | Play  | Client   | Statistic  | Value        | Array      | VarInt     | The amount to set it to                   |
	 * 
	 */
}

// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x7
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x7
type PlayStatistics_498_3 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name   | Field Type | Field Type | Notes                                     |
	 * |-----------|-------|----------|------------|--------------|------------|------------|-------------------------------------------|
	 * | 0x07      | Play  | Client   | Count      | Count        | VarInt     | VarInt     | Number of elements in the following array |
	 * | 0x07      | Play  | Client   | Statistic  | Category ID  | Array      | VarInt     | See below                                 |
	 * | 0x07      | Play  | Client   | Statistic  | Statistic ID | Array      | VarInt     | See below                                 |
	 * | 0x07      | Play  | Client   | Value      | Value        | VarInt     | VarInt     | The amount to set it to                   |
	 * 
	 */
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x7
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x7
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x7
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x7
type PlayStatistics_340_4 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name | Field Type | Field Type     | Notes                                                             |
	 * |-----------|-------|----------|------------|------------|------------|----------------|-------------------------------------------------------------------|
	 * | 0x07      | Play  | Client   | Count      | Count      | VarInt     | VarInt         | Number of elements in the following array                         |
	 * | 0x07      | Play  | Client   | Statistic  | Name       | Array      | String (32767) | https://gist.github.com/Alvin-LB/8d0d13db00b3c00fd0e822a562025eff |
	 * | 0x07      | Play  | Client   | Statistic  | Value      | Array      | VarInt         | The amount to set it to                                           |
	 * 
	 */
}

// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x7
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x7
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x7
type PlayStatistics_315_5 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name | Field Type | Field Type | Notes                                                    |
	 * |-----------|-------|----------|------------|------------|------------|------------|----------------------------------------------------------|
	 * | 0x07      | Play  | Client   | Count      | Count      | VarInt     | VarInt     | Number of elements in the following array                |
	 * | 0x07      | Play  | Client   | Statistic  | Name       | Array      | String     | https://gist.github.com/thinkofname/a1842c21a0cf2e1fb5e0 |
	 * | 0x07      | Play  | Client   | Statistic  | Value      | Array      | VarInt     | The amount to set it to                                  |
	 * 
	 */
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x16
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x16
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x16
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x16
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x17
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x17
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x16
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x16
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x14
type PlaySteerBoat_758_0 struct {
	LeftPaddleTurning Bool // Boolean
	RightPaddleTurning Bool // Boolean
}

var _ Packet = (*PlaySteerBoat_758_0)(nil)

func (p PlaySteerBoat_758_0)Encode(b *PacketBuilder){
	b.Bool(p.LeftPaddleTurning)
	b.Bool(p.RightPaddleTurning)
}

func (p *PlaySteerBoat_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.LeftPaddleTurning, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.RightPaddleTurning, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x11
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x11
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x12
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x11
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x11
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x11
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x11
type PlaySteerBoat_340_1 struct {
	RightPaddleTurning Bool // Boolean
	LeftPaddleTurning Bool // Boolean
}

var _ Packet = (*PlaySteerBoat_340_1)(nil)

func (p PlaySteerBoat_340_1)Encode(b *PacketBuilder){
	b.Bool(p.RightPaddleTurning)
	b.Bool(p.LeftPaddleTurning)
}

func (p *PlaySteerBoat_340_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.RightPaddleTurning, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.LeftPaddleTurning, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x1c
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x1c
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x1c
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x1c
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x1d
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x1d
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x1c
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x1c
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x1a
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x16
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x16
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x16
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x15
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x15
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x15
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x15
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0xc
type PlaySteerVehicle_758_0 struct {
	/* Positive to the left of the player */
	Sideways Float // Float
	/* Positive forward */
	Forward Float // Float
	/* Bit mask. 0x1: jump, 0x2: unmount */
	Flags UByte // Unsigned Byte
}

var _ Packet = (*PlaySteerVehicle_758_0)(nil)

func (p PlaySteerVehicle_758_0)Encode(b *PacketBuilder){
	b.Float(p.Sideways)
	b.Float(p.Forward)
	b.UByte(p.Flags)
}

func (p *PlaySteerVehicle_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Sideways, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Forward, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Flags, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x63
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x63
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x5f
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x61
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x5e
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x5e
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x5e
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x5d
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x5d
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x52
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x52
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x53
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x52
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x4c
type PlayStopSound_763_0 struct {
	/* Controls which fields are present. */
	Flags Byte // Byte
	/* Only if flags is 3 or 1 (bit mask 0x1).  See below.  If not present, then sounds from all sources are cleared. */
	Source Optional[VarInt] // Optional VarInt enum
	/* Only if flags is 2 or 3 (bit mask 0x2).  A sound effect name, see Named Sound Effect.  If not present, then all sounds are cleared. */
	Sound Optional[String] // Optional Identifier
}

var _ Packet = (*PlayStopSound_763_0)(nil)

func (p PlayStopSound_763_0)Encode(b *PacketBuilder){
	b.Byte(p.Flags)
	if p.Flags & 0x1 != 0 {
		b.VarInt(p.Source.Assert())
	}
	if p.Flags & 0x2 != 0 {
		b.String(p.Sound.Assert())
	}
}

func (p *PlayStopSound_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Source.Ok = p.Flags & 0x1 != 0; p.Source.Ok {
		if p.Source.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.Sound.Ok = p.Flags & 0x2 != 0; p.Sound.Ok {
		if p.Sound.V, ok = r.String(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x2f
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x2f
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x2f
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x2f
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x2e
type PlaySwingArm_763_0 struct {
	/* Hand used for the animation. 0: main hand, 1: off hand. */
	Hand VarInt // VarInt Enum
}

var _ Packet = (*PlaySwingArm_763_0)(nil)

func (p PlaySwingArm_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.Hand)
}

func (p *PlaySwingArm_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Hand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x3c
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x3c
type PlaySynchronizePlayerPosition_763_0 struct {
	/* Absolute or relative position, depending on Flags. */
	X Double // Double
	/* Absolute or relative position, depending on Flags. */
	Y Double // Double
	/* Absolute or relative position, depending on Flags. */
	Z Double // Double
	/* Absolute or relative rotation on the X axis, in degrees. */
	Yaw Float // Float
	/* Absolute or relative rotation on the Y axis, in degrees. */
	Pitch Float // Float
	/* Bit field, see below. */
	Flags Byte // Byte
	/* Client should confirm this packet with Confirm Teleportation containing the same Teleport ID. */
	TeleportID VarInt // VarInt
}

var _ Packet = (*PlaySynchronizePlayerPosition_763_0)(nil)

func (p PlaySynchronizePlayerPosition_763_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.Float(p.Yaw)
	b.Float(p.Pitch)
	b.Byte(p.Flags)
	b.VarInt(p.TeleportID)
}

func (p *PlaySynchronizePlayerPosition_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.TeleportID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x38
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x39
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x36
type PlaySynchronizePlayerPosition_761_1 struct {
	/* Absolute or relative position, depending on Flags. */
	X Double // Double
	/* Absolute or relative position, depending on Flags. */
	Y Double // Double
	/* Absolute or relative position, depending on Flags. */
	Z Double // Double
	/* Absolute or relative rotation on the X axis, in degrees. */
	Yaw Float // Float
	/* Absolute or relative rotation on the Y axis, in degrees. */
	Pitch Float // Float
	/* Bit field, see below. */
	Flags Byte // Byte
	/* Client should confirm this packet with Confirm Teleportation containing the same Teleport ID. */
	TeleportID VarInt // VarInt
	/* True if the player should dismount their vehicle. */
	DismountVehicle Bool // Boolean
}

var _ Packet = (*PlaySynchronizePlayerPosition_761_1)(nil)

func (p PlaySynchronizePlayerPosition_761_1)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.Float(p.Yaw)
	b.Float(p.Pitch)
	b.Byte(p.Flags)
	b.VarInt(p.TeleportID)
	b.Bool(p.DismountVehicle)
}

func (p *PlaySynchronizePlayerPosition_761_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.TeleportID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.DismountVehicle, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x64
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x64
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x60
type PlaySystemChatMessage_763_0 struct {
	/* Limited to 262144 bytes. */
	Content Object // Chat
	/* Whether the message is an actionbar or chat message. */
	Overlay Bool // Boolean
}

var _ Packet = (*PlaySystemChatMessage_763_0)(nil)

func (p PlaySystemChatMessage_763_0)Encode(b *PacketBuilder){
	b.JSON(p.Content)
	b.Bool(p.Overlay)
}

func (p *PlaySystemChatMessage_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.Content); err != nil {
		return err
	}
	if p.Overlay, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x62
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x5f
type PlaySystemChatMessage_760_1 struct {
	/* Limited to 262144 bytes. */
	JSONData Object // Chat
	/* Whether the message is an actionbar or chat message. */
	Overlay Bool // Boolean
}

var _ Packet = (*PlaySystemChatMessage_760_1)(nil)

func (p PlaySystemChatMessage_760_1)Encode(b *PacketBuilder){
	b.JSON(p.JSONData)
	b.Bool(p.Overlay)
}

func (p *PlaySystemChatMessage_760_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.JSONData); err != nil {
		return err
	}
	if p.Overlay, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x11
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x11
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x11
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x11
type PlayTabComplete_758_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name  | Field Type | Field Type     | Notes                                                                                                                                                                                                  |
	 * |-----------|-------|----------|------------|-------------|------------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x11      | Play  | Client   |            |             |            |                |                                                                                                                                                                                                        |
	 * | 0x11      | Play  | Client   | ID         | ID          | VarInt     | VarInt         | Transaction ID.                                                                                                                                                                                        |
	 * | 0x11      | Play  | Client   | Start      | Start       | VarInt     | VarInt         | Start of the text to replace.                                                                                                                                                                          |
	 * | 0x11      | Play  | Client   | Length     | Length      | VarInt     | VarInt         | Length of the text to replace.                                                                                                                                                                         |
	 * | 0x11      | Play  | Client   | Count      | Count       | VarInt     | VarInt         | Number of elements in the following array.                                                                                                                                                             |
	 * | 0x11      | Play  | Client   | Matches    | Match       | Array      | String (32767) | One eligible value to insert, note that each command is sent separately instead of in a single string, hence the need for Count.  Note that for instance this doesn't include a leading / on commands. |
	 * | 0x11      | Play  | Client   | Matches    | Has tooltip | Array      | Boolean        | True if the following is present.                                                                                                                                                                      |
	 * | 0x11      | Play  | Client   | Matches    | Tooltip     | Array      | Optional Chat  | Tooltip to display; only present if previous boolean is true.                                                                                                                                          |
	 * 
	 */
}

// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x10
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x10
type PlayTabComplete_498_4 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name  | Field Type | Field Type     | Notes                                                                                                                                                                                                  |
	 * |-----------|-------|----------|------------|-------------|------------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x10      | Play  | Client   |            |             |            |                |                                                                                                                                                                                                        |
	 * | 0x10      | Play  | Client   | ID         | ID          | VarInt     | VarInt         | Transaction ID                                                                                                                                                                                         |
	 * | 0x10      | Play  | Client   | Start      | Start       | VarInt     | VarInt         | Start of the text to replace                                                                                                                                                                           |
	 * | 0x10      | Play  | Client   | Length     | Length      | VarInt     | VarInt         | Length of the text to replace                                                                                                                                                                          |
	 * | 0x10      | Play  | Client   | Count      | Count       | VarInt     | VarInt         | Number of elements in the following array                                                                                                                                                              |
	 * | 0x10      | Play  | Client   | Matches    | Match       | Array      | String (32767) | One eligible value to insert, note that each command is sent separately instead of in a single string, hence the need for Count.  Note that for instance this doesn't include a leading / on commands. |
	 * | 0x10      | Play  | Client   | Matches    | Has tooltip | Array      | Boolean        | True if the following is present                                                                                                                                                                       |
	 * | 0x10      | Play  | Client   | Matches    | Tooltip     | Array      | Optional Chat  | Tooltip to display; only present if previous boolean is true                                                                                                                                           |
	 * 
	 */
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0xe
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0xe
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0xe
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0xe
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0xe
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0xe
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0xe
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x3a
type PlayTabComplete_340_5 struct {
	/* Number of elements in the following array */
	Count VarInt // VarInt
	/* One eligible command, note that each command is sent separately instead of in a single string, hence the need for Count */
	Matches []String // Array of String (32767)
}

var _ Packet = (*PlayTabComplete_340_5)(nil)

func (p PlayTabComplete_340_5)Encode(b *PacketBuilder){
	p.Count = (VarInt)(len(p.Matches))
	b.VarInt(p.Count)
	for _, v := range p.Matches {
		b.String(v)
	}
}

func (p *PlayTabComplete_340_5)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Count, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.Matches = make([]String, p.Count)
	for i, _ := range p.Matches {
		if p.Matches[i], ok = r.String(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x6
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x6
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x6
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x6
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x6
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x6
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x6
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x6
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x5
type PlayTabCompleteServer_758_0 struct {
	/* The id received in the tab completion request packet, must match or the client will ignore this packet.  Client generates this and increments it each time it sends another tab completion that doesn't get a response. */
	TransactionId VarInt // VarInt
	/* All text behind the cursor without the / (e.g. to the left of the cursor in left-to-right languages like English) */
	Text String // String (32500)
}

var _ Packet = (*PlayTabCompleteServer_758_0)(nil)

func (p PlayTabCompleteServer_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.TransactionId)
	b.String(p.Text)
}

func (p *PlayTabCompleteServer_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TransactionId, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Text, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x1
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x1
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x2
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x1
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x1
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x1
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x1
type PlayTabCompleteServer_340_1 struct {
	/* All text behind the cursor (e.g. to the left of the cursor in left-to-right languages like English) */
	Text String // String (32767)
	/* If true, the server will parse Text as a command even if it doesn't start with a /. Used in the command block GUI. */
	AssumeCommand Bool // Boolean
	HasPosition Bool // Boolean
	/* The position of the block being looked at. Only sent if Has Position is true. */
	LookedAtBlock Optional[Position] // Optional Position
}

var _ Packet = (*PlayTabCompleteServer_340_1)(nil)

func (p PlayTabCompleteServer_340_1)Encode(b *PacketBuilder){
	b.String(p.Text)
	b.Bool(p.AssumeCommand)
	p.HasPosition = p.LookedAtBlock.Ok
	b.Bool(p.HasPosition)
	if p.LookedAtBlock.Ok {
		p.LookedAtBlock.V.Encode(b)
	}
}

func (p *PlayTabCompleteServer_340_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Text, ok = r.String(); !ok {
		return io.EOF
	}
	if p.AssumeCommand, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.HasPosition, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.LookedAtBlock.Ok = p.HasPosition; p.LookedAtBlock.Ok {
		if err = p.LookedAtBlock.V.DecodeFrom(r); err != nil {
			return err
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x66
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x66
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x62
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x64
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x61
type PlayTagQueryResponse_763_0 struct {
	/* Can be compared to the one sent in the original query packet. */
	TransactionID VarInt // VarInt
	/* The NBT of the block or entity.  May be a TAG_END (0) in which case no NBT is present. */
	NBT nbt.NBT // NBT Tag
}

var _ Packet = (*PlayTagQueryResponse_763_0)(nil)

func (p PlayTagQueryResponse_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.TransactionID)
	nbt.WriteNBT(b, p.NBT)
}

func (p *PlayTagQueryResponse_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TransactionID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.NBT, err = nbt.ReadNBT(r); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x67
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x67
type PlayTags_758_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name          | Field Type | Field Type  | Notes                                                                                                                                        |
	 * |-----------|-------|----------|---------------------|---------------------|------------|-------------|----------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x67      | Play  | Client   | Length of the array | Length of the array | VarInt     | VarInt      |                                                                                                                                              |
	 * | 0x67      | Play  | Client   | Array of tags       | Tag type            | Array      | Identifier  | Tag identifier (Vanilla required tags are minecraft:block, minecraft:item, minecraft:fluid, minecraft:entity_type, and minecraft:game_event) |
	 * | 0x67      | Play  | Client   | Array of tags       | Array of Tag        | Array      | (See below) |                                                                                                                                              |
	 * 
	 */
}

// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x66
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x66
type PlayTags_756_1 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name          | Field Type | Field Type  | Notes                                                                                                                                        |
	 * |-----------|-------|----------|---------------------|---------------------|------------|-------------|----------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x66      | Play  | Client   | Length of the array | Length of the array | VarInt     | VarInt      |                                                                                                                                              |
	 * | 0x66      | Play  | Client   | Array of tags       | Tag type            | Array      | Identifier  | Tag identifier (Vanilla required tags are minecraft:block, minecraft:item, minecraft:fluid, minecraft:entity_type, and minecraft:game_event) |
	 * | 0x66      | Play  | Client   | Array of tags       | Array of Tag        | Array      | (See below) |                                                                                                                                              |
	 * 
	 */
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x5b
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x5b
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x5c
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x5b
type PlayTags_754_2 struct {
	/* IDs are block IDs */
	BlockTags []Tag // (See below)
	/* IDs are item IDs */
	ItemTags []Tag // (See below)
	/* IDs are fluid IDs */
	FluidTags []Tag // (See below)
	/* IDs are entity IDs */
	EntityTags []Tag // (See below)
}

var _ Packet = (*PlayTags_754_2)(nil)

func (p PlayTags_754_2)Encode(b *PacketBuilder){
	TODO_Encode_Array(p.BlockTags)
	TODO_Encode_Array(p.ItemTags)
	TODO_Encode_Array(p.FluidTags)
	TODO_Encode_Array(p.EntityTags)
}

func (p *PlayTags_754_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	TODO_Decode_Array(p.BlockTags)
	TODO_Decode_Array(p.ItemTags)
	TODO_Decode_Array(p.FluidTags)
	TODO_Decode_Array(p.EntityTags)
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x55
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x55
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x55
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x55
type PlayTeams_758_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name                   | Field Name          | Field Type           | Notes                                                                                                                  |
	 * |-----------|-------|----------|------------------------------|---------------------|----------------------|------------------------------------------------------------------------------------------------------------------------|
	 * | 0x55      | Play  | Client   | Team Name                    | Team Name           | String (16)          | A unique name for the team. (Shared with scoreboard).                                                                  |
	 * | 0x55      | Play  | Client   | Mode                         | Mode                | Byte                 | Determines the layout of the remaining packet.                                                                         |
	 * | 0x55      | Play  | Client   | 0: create team               | Team Display Name   | Chat                 |                                                                                                                        |
	 * | 0x55      | Play  | Client   | 0: create team               | Friendly Flags      | Byte                 | Bit mask. 0x01: Allow friendly fire, 0x02: can see invisible players on same team.                                     |
	 * | 0x55      | Play  | Client   | 0: create team               | Name Tag Visibility | String Enum (32)     | always, hideForOtherTeams, hideForOwnTeam, never.                                                                      |
	 * | 0x55      | Play  | Client   | 0: create team               | Collision Rule      | String Enum (32)     | always, pushOtherTeams, pushOwnTeam, never.                                                                            |
	 * | 0x55      | Play  | Client   | 0: create team               | Team Color          | VarInt enum          | Used to color the name of players on the team; see below.                                                              |
	 * | 0x55      | Play  | Client   | 0: create team               | Team Prefix         | Chat                 | Displayed before the names of players that are part of this team.                                                      |
	 * | 0x55      | Play  | Client   | 0: create team               | Team Suffix         | Chat                 | Displayed after the names of players that are part of this team.                                                       |
	 * | 0x55      | Play  | Client   | 0: create team               | Entity Count        | VarInt               | Number of elements in the following array.                                                                             |
	 * | 0x55      | Play  | Client   | 0: create team               | Entities            | Array of String (40) | Identifiers for the entities in this team.  For players, this is their username; for other entities, it is their UUID. |
	 * | 0x55      | Play  | Client   | 1: remove team               | no fields           | no fields            |                                                                                                                        |
	 * | 0x55      | Play  | Client   | 2: update team info          | Team Display Name   | Chat                 |                                                                                                                        |
	 * | 0x55      | Play  | Client   | 2: update team info          | Friendly Flags      | Byte                 | Bit mask. 0x01: Allow friendly fire, 0x02: can see invisible entities on same team.                                    |
	 * | 0x55      | Play  | Client   | 2: update team info          | Name Tag Visibility | String Enum (32)     | always, hideForOtherTeams, hideForOwnTeam, never                                                                       |
	 * | 0x55      | Play  | Client   | 2: update team info          | Collision Rule      | String Enum (32)     | always, pushOtherTeams, pushOwnTeam, never                                                                             |
	 * | 0x55      | Play  | Client   | 2: update team info          | Team Color          | VarInt enum          | Used to color the name of players on the team; see below.                                                              |
	 * | 0x55      | Play  | Client   | 2: update team info          | Team Prefix         | Chat                 | Displayed before the names of players that are part of this team.                                                      |
	 * | 0x55      | Play  | Client   | 2: update team info          | Team Suffix         | Chat                 | Displayed after the names of players that are part of this team.                                                       |
	 * | 0x55      | Play  | Client   | 3: add entities to team      | Entity Count        | VarInt               | Number of elements in the following array.                                                                             |
	 * | 0x55      | Play  | Client   | 3: add entities to team      | Entities            | Array of String (40) | Identifiers for the added entities.  For players, this is their username; for other entities, it is their UUID.        |
	 * | 0x55      | Play  | Client   | 4: remove entities from team | Entity Count        | VarInt               | Number of elements in the following array.                                                                             |
	 * | 0x55      | Play  | Client   | 4: remove entities from team | Entities            | Array of String (40) | Identifiers for the removed entities.  For players, this is their username; for other entities, it is their UUID.      |
	 * 
	 */
}

// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x4c
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x4c
type PlayTeams_753_2 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name                  | Field Name          | Field Type           | Notes                                                                                                                  |
	 * |-----------|-------|----------|-----------------------------|---------------------|----------------------|------------------------------------------------------------------------------------------------------------------------|
	 * | 0x4C      | Play  | Client   | Team Name                   | Team Name           | String (16)          | A unique name for the team. (Shared with scoreboard).                                                                  |
	 * | 0x4C      | Play  | Client   | Mode                        | Mode                | Byte                 | Determines the layout of the remaining packet                                                                          |
	 * | 0x4C      | Play  | Client   | 0: create team              | Team Display Name   | Chat                 |                                                                                                                        |
	 * | 0x4C      | Play  | Client   | 0: create team              | Friendly Flags      | Byte                 | Bit mask. 0x01: Allow friendly fire, 0x02: can see invisible players on same team                                      |
	 * | 0x4C      | Play  | Client   | 0: create team              | Name Tag Visibility | String Enum (32)     | always, hideForOtherTeams, hideForOwnTeam, never                                                                       |
	 * | 0x4C      | Play  | Client   | 0: create team              | Collision Rule      | String Enum (32)     | always, pushOtherTeams, pushOwnTeam, never                                                                             |
	 * | 0x4C      | Play  | Client   | 0: create team              | Team Color          | VarInt enum          | Used to color the name of players on the team; see below                                                               |
	 * | 0x4C      | Play  | Client   | 0: create team              | Team Prefix         | Chat                 | Displayed before the names of players that are part of this team                                                       |
	 * | 0x4C      | Play  | Client   | 0: create team              | Team Suffix         | Chat                 | Displayed after the names of players that are part of this team                                                        |
	 * | 0x4C      | Play  | Client   | 0: create team              | Entity Count        | VarInt               | Number of elements in the following array                                                                              |
	 * | 0x4C      | Play  | Client   | 0: create team              | Entities            | Array of String (40) | Identifiers for the entities in this team.  For players, this is their username; for other entities, it is their UUID. |
	 * | 0x4C      | Play  | Client   | 1: remove team              | no fields           | no fields            |                                                                                                                        |
	 * | 0x4C      | Play  | Client   | 2: update team info         | Team Display Name   | Chat                 |                                                                                                                        |
	 * | 0x4C      | Play  | Client   | 2: update team info         | Friendly Flags      | Byte                 | Bit mask. 0x01: Allow friendly fire, 0x02: can see invisible entities on same team                                     |
	 * | 0x4C      | Play  | Client   | 2: update team info         | Name Tag Visibility | String Enum (32)     | always, hideForOtherTeams, hideForOwnTeam, never                                                                       |
	 * | 0x4C      | Play  | Client   | 2: update team info         | Collision Rule      | String Enum (32)     | always, pushOtherTeams, pushOwnTeam, never                                                                             |
	 * | 0x4C      | Play  | Client   | 2: update team info         | Team Color          | VarInt enum          | Used to color the name of players on the team; see below                                                               |
	 * | 0x4C      | Play  | Client   | 2: update team info         | Team Prefix         | Chat                 | Displayed before the names of players that are part of this team                                                       |
	 * | 0x4C      | Play  | Client   | 2: update team info         | Team Suffix         | Chat                 | Displayed after the names of players that are part of this team                                                        |
	 * | 0x4C      | Play  | Client   | 3: add players to team      | Entity Count        | VarInt               | Number of elements in the following array                                                                              |
	 * | 0x4C      | Play  | Client   | 3: add players to team      | Entities            | Array of String (40) | Identifiers for the entities added.  For players, this is their username; for other entities, it is their UUID.        |
	 * | 0x4C      | Play  | Client   | 4: remove players from team | Entity Count        | VarInt               | Number of elements in the following array                                                                              |
	 * | 0x4C      | Play  | Client   | 4: remove players from team | Entities            | Array of String (40) | Identifiers for the entities removed.  For players, this is their username; for other entities, it is their UUID.      |
	 * 
	 */
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x44
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x44
type PlayTeams_340_5 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name                  | Field Name          | Field Type           | Notes                                                                                                                  |
	 * |-----------|-------|----------|-----------------------------|---------------------|----------------------|------------------------------------------------------------------------------------------------------------------------|
	 * | 0x44      | Play  | Client   | Team Name                   | Team Name           | String (16)          | A unique name for the team. (Shared with scoreboard).                                                                  |
	 * | 0x44      | Play  | Client   | Mode                        | Mode                | Byte                 | Determines the layout of the remaining packet                                                                          |
	 * | 0x44      | Play  | Client   | 0: create team              | Team Display Name   | String (32)          |                                                                                                                        |
	 * | 0x44      | Play  | Client   | 0: create team              | Team Prefix         | String (16)          | Displayed before the names of players that are part of this team                                                       |
	 * | 0x44      | Play  | Client   | 0: create team              | Team Suffix         | String (16)          | Displayed after the names of players that are part of this team                                                        |
	 * | 0x44      | Play  | Client   | 0: create team              | Friendly Flags      | Byte                 | Bit mask. 0x01: Allow friendly fire, 0x02: can see invisible players on same team                                      |
	 * | 0x44      | Play  | Client   | 0: create team              | Name Tag Visibility | String Enum (32)     | always, hideForOtherTeams, hideForOwnTeam, never                                                                       |
	 * | 0x44      | Play  | Client   | 0: create team              | Collision Rule      | String Enum (32)     | always, pushOtherTeams, pushOwnTeam, never                                                                             |
	 * | 0x44      | Play  | Client   | 0: create team              | Color               | Byte                 | For colors, the same Chat colors (0-15).  -1 indicates RESET/no color.                                                 |
	 * | 0x44      | Play  | Client   | 0: create team              | Entity Count        | VarInt               | Number of elements in the following array                                                                              |
	 * | 0x44      | Play  | Client   | 0: create team              | Entities            | Array of String (40) | Identifiers for the entities in this team.  For players, this is their username; for other entities, it is their UUID. |
	 * | 0x44      | Play  | Client   | 1: remove team              | no fields           | no fields            |                                                                                                                        |
	 * | 0x44      | Play  | Client   | 2: update team info         | Team Display Name   | String (32)          |                                                                                                                        |
	 * | 0x44      | Play  | Client   | 2: update team info         | Team Prefix         | String (16)          | Displayed before the names of entities that are part of this team                                                      |
	 * | 0x44      | Play  | Client   | 2: update team info         | Team Suffix         | String (16)          | Displayed after the names of entities that are part of this team                                                       |
	 * | 0x44      | Play  | Client   | 2: update team info         | Friendly Flags      | Byte                 | Bit mask. 0x01: Allow friendly fire, 0x02: can see invisible entities on same team                                     |
	 * | 0x44      | Play  | Client   | 2: update team info         | Name Tag Visibility | String Enum (32)     | always, hideForOtherTeams, hideForOwnTeam, never                                                                       |
	 * | 0x44      | Play  | Client   | 2: update team info         | Collision Rule      | String Enum (32)     | always, pushOtherTeams, pushOwnTeam, never                                                                             |
	 * | 0x44      | Play  | Client   | 2: update team info         | Color               | Byte                 | For colors, the same Chat colors (0-15).  -1 indicates RESET/no color.                                                 |
	 * | 0x44      | Play  | Client   | 3: add players to team      | Entity Count        | VarInt               | Number of elements in the following array                                                                              |
	 * | 0x44      | Play  | Client   | 3: add players to team      | Entities            | Array of String (40) | Identifiers for the entities added.  For players, this is their username; for other entities, it is their UUID.        |
	 * | 0x44      | Play  | Client   | 4: remove players from team | Entity Count        | VarInt               | Number of elements in the following array                                                                              |
	 * | 0x44      | Play  | Client   | 4: remove players from team | Entities            | Array of String (40) | Identifiers for the entities removed.  For players, this is their username; for other entities, it is their UUID.      |
	 * 
	 */
}

// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x41
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x41
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x41
type PlayTeams_315_8 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name                  | Field Name          | Field Type      | Notes                                                                             |
	 * |-----------|-------|----------|-----------------------------|---------------------|-----------------|-----------------------------------------------------------------------------------|
	 * | 0x41      | Play  | Client   | Team Name                   | Team Name           | String          | A unique name for the team. (Shared with scoreboard).                             |
	 * | 0x41      | Play  | Client   | Mode                        | Mode                | Byte            | Determines the layout of the remaining packet                                     |
	 * | 0x41      | Play  | Client   | 0: create team              | Team Display Name   | String          |                                                                                   |
	 * | 0x41      | Play  | Client   | 0: create team              | Team Prefix         | String          | Displayed before the names of players that are part of this team                  |
	 * | 0x41      | Play  | Client   | 0: create team              | Team Suffix         | String          | Displayed after the names of players that are part of this team                   |
	 * | 0x41      | Play  | Client   | 0: create team              | Friendly Flags      | Byte            | Bit mask. 0x01: Allow friendly fire, 0x02: can see invisible players on same team |
	 * | 0x41      | Play  | Client   | 0: create team              | Name Tag Visibility | String Enum     | always, hideForOtherTeams, hideForOwnTeam, never                                  |
	 * | 0x41      | Play  | Client   | 0: create team              | Collision Rule      | String Enum     | always, pushOtherTeams, pushOwnTeam, never                                        |
	 * | 0x41      | Play  | Client   | 0: create team              | Color               | Byte            | Same as Chat colors                                                               |
	 * | 0x41      | Play  | Client   | 0: create team              | Player Count        | VarInt          | Number of elements in the following array                                         |
	 * | 0x41      | Play  | Client   | 0: create team              | Players             | Array of String | Usernames of the players in this team. Maximum 40 characters per entry.           |
	 * | 0x41      | Play  | Client   | 1: remove team              | no fields           | no fields       |                                                                                   |
	 * | 0x41      | Play  | Client   | 2: update team info         | Team Display Name   | String          |                                                                                   |
	 * | 0x41      | Play  | Client   | 2: update team info         | Team Prefix         | String          | Displayed before the names of players that are part of this team                  |
	 * | 0x41      | Play  | Client   | 2: update team info         | Team Suffix         | String          | Displayed after the names of players that are part of this team                   |
	 * | 0x41      | Play  | Client   | 2: update team info         | Friendly Flags      | Byte            | Bit mask. 0x01: Allow friendly fire, 0x02: can see invisible players on same team |
	 * | 0x41      | Play  | Client   | 2: update team info         | Name Tag Visibility | String Enum     | always, hideForOtherTeams, hideForOwnTeam, never                                  |
	 * | 0x41      | Play  | Client   | 2: update team info         | Collision Rule      | String Enum     | always, pushOtherTeams, pushOwnTeam, never                                        |
	 * | 0x41      | Play  | Client   | 2: update team info         | Color               | Byte            | Same as Chat colors                                                               |
	 * | 0x41      | Play  | Client   | 3: add players to team      | Player Count        | VarInt          | Number of elements in the following array                                         |
	 * | 0x41      | Play  | Client   | 3: add players to team      | Players             | Array of String | Usernames of the added players. Maximum 40 characters per entry.                  |
	 * | 0x41      | Play  | Client   | 4: remove players from team | Player Count        | VarInt          | Number of elements in the following array                                         |
	 * | 0x41      | Play  | Client   | 4: remove players from team | Players             | Array of String | Usernames of the removed players. Maximum 40 characters per entry.                |
	 * 
	 */
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x0
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x0
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x0
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x0
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x0
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x0
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x0
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x0
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x0
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x0
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x0
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x0
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x0
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x0
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x0
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x0
type PlayTeleportConfirm_758_0 struct {
	/* The ID given by the Player Position And Look packet */
	TeleportID VarInt // VarInt
}

var _ Packet = (*PlayTeleportConfirm_758_0)(nil)

func (p PlayTeleportConfirm_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.TeleportID)
}

func (p *PlayTeleportConfirm_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TeleportID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x68
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x68
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x64
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x66
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x63
type PlayTeleportEntity_763_0 struct {
	EntityID VarInt // VarInt
	X Double // Double
	Y Double // Double
	Z Double // Double
	/* (Y Rot)New angle, not a delta. */
	Yaw Angle // Angle
	/* (X Rot)New angle, not a delta. */
	Pitch Angle // Angle
	OnGround Bool // Boolean
}

var _ Packet = (*PlayTeleportEntity_763_0)(nil)

func (p PlayTeleportEntity_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlayTeleportEntity_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x30
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x30
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x30
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x30
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x2f
type PlayTeleportToEntity_763_0 struct {
	/* UUID of the player to teleport to (can also be an entity UUID). */
	TargetPlayer UUID // UUID
}

var _ Packet = (*PlayTeleportToEntity_763_0)(nil)

func (p PlayTeleportToEntity_763_0)Encode(b *PacketBuilder){
	b.UUID(p.TargetPlayer)
}

func (p *PlayTeleportToEntity_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.TargetPlayer, ok = r.UUID(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x59
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x59
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x58
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x58
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x4e
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x4e
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x4f
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x4e
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x4a
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x47
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x47
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x46
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x44
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x44
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x44
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x44
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x3
type PlayTimeUpdate_758_0 struct {
	/* In ticks; not changed by server commands */
	WorldAge Long // Long
	/* The world (or region) time, in ticks. If negative the sun will stop moving at the Math.abs of the time */
	TimeOfDay Long // Long
}

var _ Packet = (*PlayTimeUpdate_758_0)(nil)

func (p PlayTimeUpdate_758_0)Encode(b *PacketBuilder){
	b.Long(p.WorldAge)
	b.Long(p.TimeOfDay)
}

func (p *PlayTimeUpdate_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WorldAge, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.TimeOfDay, ok = r.Long(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x4f
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x4f
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x4f
type PlayTitle_754_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name               | Field Name      | Field Type  | Notes                                                                                                                                                                            |
	 * |-----------|-------|----------|--------------------------|-----------------|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x4F      | Play  | Client   | Action                   | Action          | VarInt Enum |                                                                                                                                                                                  |
	 * | 0x4F      | Play  | Client   | Action                   | Field Name      |             |                                                                                                                                                                                  |
	 * | 0x4F      | Play  | Client   | 0: set title             | Title Text      | Chat        |                                                                                                                                                                                  |
	 * | 0x4F      | Play  | Client   | 1: set subtitle          | Subtitle Text   | Chat        |                                                                                                                                                                                  |
	 * | 0x4F      | Play  | Client   | 2: set action bar        | Action bar text | Chat        | Displays a message above the hotbar (the same as position 2 in Chat Message (clientbound), except that it correctly renders formatted chat. See MC-119145 for more information.) |
	 * | 0x4F      | Play  | Client   | 3: set times and display | Fade In         | Int         | Ticks to spend fading in                                                                                                                                                         |
	 * | 0x4F      | Play  | Client   | 3: set times and display | Stay            | Int         | Ticks to keep the title displayed                                                                                                                                                |
	 * | 0x4F      | Play  | Client   | 3: set times and display | Fade Out        | Int         | Ticks to spend out, not when to start fading out                                                                                                                                 |
	 * | 0x4F      | Play  | Client   | 4: hide                  | no fields       | no fields   |                                                                                                                                                                                  |
	 * | 0x4F      | Play  | Client   | 5: reset                 | no fields       | no fields   |                                                                                                                                                                                  |
	 * 
	 */
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x48
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x48
type PlayTitle_340_3 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name               | Field Name      | Field Type  | Notes                                                                                                                                                                            |
	 * |-----------|-------|----------|--------------------------|-----------------|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x48      | Play  | Client   | Action                   | Action          | VarInt Enum |                                                                                                                                                                                  |
	 * | 0x48      | Play  | Client   | Action                   | Field Name      |             |                                                                                                                                                                                  |
	 * | 0x48      | Play  | Client   | 0: set title             | Title Text      | Chat        |                                                                                                                                                                                  |
	 * | 0x48      | Play  | Client   | 1: set subtitle          | Subtitle Text   | Chat        |                                                                                                                                                                                  |
	 * | 0x48      | Play  | Client   | 2: set action bar        | Action bar text | Chat        | Displays a message above the hotbar (the same as position 2 in Chat Message (clientbound), except that it correctly renders formatted chat. See MC-119145 for more information.) |
	 * | 0x48      | Play  | Client   | 3: set times and display | Fade In         | Int         | Ticks to spend fading in                                                                                                                                                         |
	 * | 0x48      | Play  | Client   | 3: set times and display | Stay            | Int         | Ticks to keep the title displayed                                                                                                                                                |
	 * | 0x48      | Play  | Client   | 3: set times and display | Fade Out        | Int         | Ticks to spend out, not when to start fading out                                                                                                                                 |
	 * | 0x48      | Play  | Client   | 4: hide                  | no fields       | no fields   |                                                                                                                                                                                  |
	 * | 0x48      | Play  | Client   | 5: reset                 | no fields       | no fields   |                                                                                                                                                                                  |
	 * 
	 */
}

// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x45
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x45
type PlayTitle_316_5 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name               | Field Name      | Field Type  | Notes                                                             |
	 * |-----------|-------|----------|--------------------------|-----------------|-------------|-------------------------------------------------------------------|
	 * | 0x45      | Play  | Client   | Action                   | Action          | VarInt Enum |                                                                   |
	 * | 0x45      | Play  | Client   | Action                   | Field Name      |             |                                                                   |
	 * | 0x45      | Play  | Client   | 0: set title             | Title Text      | Chat        |                                                                   |
	 * | 0x45      | Play  | Client   | 1: set subtitle          | Subtitle Text   | Chat        |                                                                   |
	 * | 0x45      | Play  | Client   | 2: set action bar        | Action bar text | Chat        | Behaves the same as with position 2 in Chat Message (clientbound) |
	 * | 0x45      | Play  | Client   | 3: set times and display | Fade In         | Int         | Ticks to spend fading in                                          |
	 * | 0x45      | Play  | Client   | 3: set times and display | Stay            | Int         | Ticks to keep the title displayed                                 |
	 * | 0x45      | Play  | Client   | 3: set times and display | Fade Out        | Int         | Ticks to spend out, not when to start fading out                  |
	 * | 0x45      | Play  | Client   | 4: hide                  | no fields       | no fields   |                                                                   |
	 * | 0x45      | Play  | Client   | 5: reset                 | no fields       | no fields   |                                                                   |
	 * 
	 */
}

// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x45
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x45
type PlayTitle_210_6 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name               | Field Name    | Field Type  | Notes                                            |
	 * |-----------|-------|----------|--------------------------|---------------|-------------|--------------------------------------------------|
	 * | 0x45      | Play  | Client   | Action                   | Action        | VarInt Enum |                                                  |
	 * | 0x45      | Play  | Client   | Action                   | Field Name    |             |                                                  |
	 * | 0x45      | Play  | Client   | 0: set title             | Title Text    | Chat        |                                                  |
	 * | 0x45      | Play  | Client   | 1: set subtitle          | Subtitle Text | Chat        |                                                  |
	 * | 0x45      | Play  | Client   | 2: set times and display | Fade In       | Int         | Ticks to spend fading in                         |
	 * | 0x45      | Play  | Client   | 2: set times and display | Stay          | Int         | Ticks to keep the title displayed                |
	 * | 0x45      | Play  | Client   | 2: set times and display | Fade Out      | Int         | Ticks to spend out, not when to start fading out |
	 * | 0x45      | Play  | Client   | 3: hide                  | no fields     | no fields   |                                                  |
	 * | 0x45      | Play  | Client   | 4: reset                 | no fields     | no fields   |                                                  |
	 * 
	 */
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x28
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x28
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x28
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x28
type PlayTradeList_758_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name                   | Field Type | Field Type    | Notes                                                                                                                                                                             |
	 * |-----------|-------|----------|---------------------|------------------------------|------------|---------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x28      | Play  | Client   |                     |                              |            |               |                                                                                                                                                                                   |
	 * | 0x28      | Play  | Client   | Window ID           | Window ID                    | VarInt     | VarInt        | The ID of the window that is open; this is an int rather than a byte.                                                                                                             |
	 * | 0x28      | Play  | Client   | Size                | Size                         | Byte       | Byte          | The number of trades in the following array.                                                                                                                                      |
	 * | 0x28      | Play  | Client   | Trades              | Input item 1                 | Array      | Slot          | The first item the player has to supply for this villager trade. The count of the item stack is the default "price" of this trade.                                                |
	 * | 0x28      | Play  | Client   | Trades              | Output item                  | Array      | Slot          | The item the player will receive from this villager trade.                                                                                                                        |
	 * | 0x28      | Play  | Client   | Trades              | Has second item              | Array      | Boolean       | Whether there is a second item.                                                                                                                                                   |
	 * | 0x28      | Play  | Client   | Trades              | Input item 2                 | Array      | Optional Slot | The second item the player has to supply for this villager trade; only present if has a second item is true.                                                                      |
	 * | 0x28      | Play  | Client   | Trades              | Trade disabled               | Array      | Boolean       | True if the trade is disabled; false if the trade is enabled.                                                                                                                     |
	 * | 0x28      | Play  | Client   | Trades              | Number of trade uses         | Array      | Integer       | Number of times the trade has been used so far. If equal to the maximum number of trades, the client will display a red X.                                                        |
	 * | 0x28      | Play  | Client   | Trades              | Maximum number of trade uses | Array      | Integer       | Number of times this trade can be used before it's exhausted.                                                                                                                     |
	 * | 0x28      | Play  | Client   | Trades              | XP                           | Array      | Integer       | Amount of XP both the player and the villager will earn each time the trade is used.                                                                                              |
	 * | 0x28      | Play  | Client   | Trades              | Special Price                | Array      | Integer       | Can be zero or negative. The number is added to the price when an item is discounted due to player reputation or other effects.                                                   |
	 * | 0x28      | Play  | Client   | Trades              | Price Multiplier             | Array      | Float         | Can be low (0.05) or high (0.2). Determines how much demand, player reputation, and temporary effects will adjust the price.                                                      |
	 * | 0x28      | Play  | Client   | Trades              | Demand                       | Array      | Integer       | Can be zero or a positive number. Causes the price to increase when a trade is used repeatedly.                                                                                   |
	 * | 0x28      | Play  | Client   | Villager level      | Villager level               | VarInt     | VarInt        | Appears on the trade GUI; meaning comes from the translation key merchant.level. + level.
	 * 1: Novice, 2: Apprentice, 3: Journeyman, 4: Expert, 5: Master.                          |
	 * | 0x28      | Play  | Client   | Experience          | Experience                   | VarInt     | VarInt        | Total experience for this villager (always 0 for the wandering trader).                                                                                                           |
	 * | 0x28      | Play  | Client   | Is regular villager | Is regular villager          | Boolean    | Boolean       | True if this is a regular villager; false for the wandering trader.  When false, hides the villager level and some other GUI elements.                                            |
	 * | 0x28      | Play  | Client   | Can restock         | Can restock                  | Boolean    | Boolean       | True for regular villagers and false for the wandering trader. If true, the "Villagers restock up to two times per day." message is displayed when hovering over disabled trades. |
	 * 
	 */
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x26
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x26
type PlayTradeList_754_1 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name                   | Field Type | Field Type    | Notes                                                                                                                                                                              |
	 * |-----------|-------|----------|---------------------|------------------------------|------------|---------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x26      | Play  | Client   |                     |                              |            |               |                                                                                                                                                                                    |
	 * | 0x26      | Play  | Client   | Window ID           | Window ID                    | VarInt     | VarInt        | The ID of the window that is open; this is an int rather than a byte.                                                                                                              |
	 * | 0x26      | Play  | Client   | Size                | Size                         | Byte       | Byte          | The number of trades in the following array                                                                                                                                        |
	 * | 0x26      | Play  | Client   | Trades              | Input item 1                 | Array      | Slot          | The first item the villager is buying                                                                                                                                              |
	 * | 0x26      | Play  | Client   | Trades              | Output item                  | Array      | Slot          | The item the villager is selling                                                                                                                                                   |
	 * | 0x26      | Play  | Client   | Trades              | Has second item              | Array      | Boolean       | Whether there is a second item                                                                                                                                                     |
	 * | 0x26      | Play  | Client   | Trades              | Input item 2                 | Array      | Optional Slot | The second item the villager is buying; only present if they have a second item.                                                                                                   |
	 * | 0x26      | Play  | Client   | Trades              | Trade disabled               | Array      | Boolean       | True if the trade is disabled; false if the trade is enabled.                                                                                                                      |
	 * | 0x26      | Play  | Client   | Trades              | Number of trade uses         | Array      | Integer       | Number of times the trade has been used so far                                                                                                                                     |
	 * | 0x26      | Play  | Client   | Trades              | Maximum number of trade uses | Array      | Integer       | Number of times this trade can be used                                                                                                                                             |
	 * | 0x26      | Play  | Client   | Trades              | XP                           | Array      | Integer       |                                                                                                                                                                                    |
	 * | 0x26      | Play  | Client   | Trades              | Special Price                | Array      | Integer       |                                                                                                                                                                                    |
	 * | 0x26      | Play  | Client   | Trades              | Price Multiplier             | Array      | Float         |                                                                                                                                                                                    |
	 * | 0x26      | Play  | Client   | Trades              | Demand                       | Array      | Integer       |                                                                                                                                                                                    |
	 * | 0x26      | Play  | Client   | Villager level      | Villager level               | VarInt     | VarInt        | Appears on the trade GUI; meaning comes from the translation key merchant.level. + level.
	 * 1: Novice, 2: Apprentice, 3: Journeyman, 4: Expert, 5: Master                            |
	 * | 0x26      | Play  | Client   | Experience          | Experience                   | VarInt     | VarInt        | Total experience for this villager (always 0 for the wandering trader)                                                                                                             |
	 * | 0x26      | Play  | Client   | Is regular villager | Is regular villager          | Boolean    | Boolean       | True if this is a regular villager; false for the wandering trader.  When false, hides the villager level and some other GUI elements.                                             |
	 * | 0x26      | Play  | Client   | Can restock         | Can restock                  | Boolean    | Boolean       | True for regular villagers and false for the wandering trader.  If true, the "Villagers restock up to two times per day." message is displayed when hovering over disabled trades. |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x1e
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x1e
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x1b
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x1c
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x1a
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x1d
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x1d
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x1d
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x1d
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x1c
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x1c
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x1e
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x1d
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x1f
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x1d
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x1d
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x1d
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x1d
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x1d
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x1d
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x1d
type PlayUnloadChunk_763_0 struct {
	/* Block coordinate divided by 16, rounded down */
	ChunkX Int // Int
	/* Block coordinate divided by 16, rounded down */
	ChunkZ Int // Int
}

var _ Packet = (*PlayUnloadChunk_763_0)(nil)

func (p PlayUnloadChunk_763_0)Encode(b *PacketBuilder){
	b.Int(p.ChunkX)
	b.Int(p.ChunkZ)
}

func (p *PlayUnloadChunk_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ChunkX, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.ChunkZ, ok = r.Int(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x39
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x39
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x39
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x39
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x35
type PlayUnlockRecipes_758_0 struct {
	/* 0: init, 1: add, 2: remove. */
	Action VarInt // VarInt
	/* If true, then the crafting recipe book will be open when the player opens its inventory. */
	CraftingRecipeBookOpen Bool // Boolean
	/* If true, then the filtering option is active when the players opens its inventory. */
	CraftingRecipeBookFilterActive Bool // Boolean
	/* If true, then the smelting recipe book will be open when the player opens its inventory. */
	SmeltingRecipeBookOpen Bool // Boolean
	/* If true, then the filtering option is active when the players opens its inventory. */
	SmeltingRecipeBookFilterActive Bool // Boolean
	/* If true, then the blast furnace recipe book will be open when the player opens its inventory. */
	BlastFurnaceRecipeBookOpen Bool // Boolean
	/* If true, then the filtering option is active when the players opens its inventory. */
	BlastFurnaceRecipeBookFilterActive Bool // Boolean
	/* If true, then the smoker recipe book will be open when the player opens its inventory. */
	SmokerRecipeBookOpen Bool // Boolean
	/* If true, then the filtering option is active when the players opens its inventory. */
	SmokerRecipeBookFilterActive Bool // Boolean
	/* Number of elements in the following array. */
	ArraySize1 VarInt // VarInt
	RecipeIDs []String // Array of Identifier
	/* Number of elements in the following array, only present if mode is 0 (init). */
	ArraySize2 Optional[VarInt] // Optional VarInt
	/* Only present if mode is 0 (init) */
	RecipeIDs2 Optional[[]String] // Optional Array of Identifier
}

var _ Packet = (*PlayUnlockRecipes_758_0)(nil)

func (p PlayUnlockRecipes_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.Action)
	b.Bool(p.CraftingRecipeBookOpen)
	b.Bool(p.CraftingRecipeBookFilterActive)
	b.Bool(p.SmeltingRecipeBookOpen)
	b.Bool(p.SmeltingRecipeBookFilterActive)
	b.Bool(p.BlastFurnaceRecipeBookOpen)
	b.Bool(p.BlastFurnaceRecipeBookFilterActive)
	b.Bool(p.SmokerRecipeBookOpen)
	b.Bool(p.SmokerRecipeBookFilterActive)
	p.ArraySize1 = len(p.RecipeIDs)
	b.VarInt(p.ArraySize1)
	for _, v := range p.RecipeIDs {
		b.VarInt(v)
	}
	if p.Action == 0 {
		p.ArraySize2.Set((VarInt)(len(p.RecipeIDs2)))
		for _, v := range p.RecipeIDs2.Assert() {
			b.VarInt(v)
		}
	}
}

func (p *PlayUnlockRecipes_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Action, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.CraftingRecipeBookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.CraftingRecipeBookFilterActive, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.SmeltingRecipeBookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.SmeltingRecipeBookFilterActive, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.BlastFurnaceRecipeBookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.BlastFurnaceRecipeBookFilterActive, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.SmokerRecipeBookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.SmokerRecipeBookFilterActive, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.ArraySize1, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.RecipeIDs = make([]VarInt, p.ArraySize1)
	for i, _ := range p.RecipeIDs {
		if p.RecipeIDs[i], ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.ArraySize2.Ok = p.Action == 0; p.ArraySize2.Ok {
		if p.ArraySize2.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.RecipeIDs2.Ok = p.Action == 0; p.RecipeIDs2.Ok {
		p.RecipeIDs2 = make([]VarInt, p.ArraySize2.V)
		for i, _ := range p.RecipeIDs2 {
			if p.RecipeIDs2[i], ok = r.VarInt(); !ok {
				return io.EOF
			}
		}
	}
	return nil
}

// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x37
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x36
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x34
type PlayUnlockRecipes_578_2 struct {
	/* 0: init, 1: add, 2: remove */
	Action VarInt // VarInt
	/* If true, then the crafting recipe book will be open when the player opens its inventory. */
	CraftingRecipeBookOpen Bool // Boolean
	/* If true, then the filtering option is active when the players opens its inventory. */
	CraftingRecipeBookFilterActive Bool // Boolean
	/* If true, then the smelting recipe book will be open when the player opens its inventory. */
	SmeltingRecipeBookOpen Bool // Boolean
	/* If true, then the filtering option is active when the players opens its inventory. */
	SmeltingRecipeBookFilterActive Bool // Boolean
	/* Number of elements in the following array */
	ArraySize1 VarInt // VarInt
	RecipeIDs []String // Array of Identifier
	/* Number of elements in the following array, only present if mode is 0 (init) */
	ArraySize2 Optional[VarInt] // Optional VarInt
	RecipeIDs2 Optional[[]String] // Optional Array of Identifier, only present if mode is 0 (init)
}

var _ Packet = (*PlayUnlockRecipes_578_2)(nil)

func (p PlayUnlockRecipes_578_2)Encode(b *PacketBuilder){
	b.VarInt(p.Action)
	b.Bool(p.CraftingRecipeBookOpen)
	b.Bool(p.CraftingRecipeBookFilterActive)
	b.Bool(p.SmeltingRecipeBookOpen)
	b.Bool(p.SmeltingRecipeBookFilterActive)
	p.ArraySize1 = len(p.RecipeIDs)
	b.VarInt(p.ArraySize1)
	for _, v := range p.RecipeIDs {
		b.VarInt(v)
	}
	if p.Action == 0 {
		p.ArraySize2.Set((VarInt)(len(p.RecipeIDs2)))
		for _, v := range p.RecipeIDs2.Assert() {
			b.VarInt(v)
		}
	}
}

func (p *PlayUnlockRecipes_578_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Action, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.CraftingRecipeBookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.CraftingRecipeBookFilterActive, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.SmeltingRecipeBookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.SmeltingRecipeBookFilterActive, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.ArraySize1, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.RecipeIDs = make([]VarInt, p.ArraySize1)
	for i, _ := range p.RecipeIDs {
		if p.RecipeIDs[i], ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.ArraySize2.Ok = p.Action == 0; p.ArraySize2.Ok {
		if p.ArraySize2.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.RecipeIDs2.Ok = p.Action == 0; p.RecipeIDs2.Ok {
		p.RecipeIDs2 = make([]VarInt, p.ArraySize2.V)
		for i, _ := range p.RecipeIDs2 {
			if p.RecipeIDs2[i], ok = r.VarInt(); !ok {
				return io.EOF
			}
		}
	}
	return nil
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x31
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x31
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x30
type PlayUnlockRecipes_340_3 struct {
	/* 0: init, 1: add, 2: remove */
	Action VarInt // VarInt
	/* If true, then the crafting book will be open when the player opens its inventory. */
	CraftingBookOpen Bool // Boolean
	/* If true, then the filtering option is active when the players opens its inventory. */
	FilteringCraftable Bool // Boolean
	/* Number of elements in the following array */
	ArraySize1 VarInt // VarInt
	RecipeIDs []VarInt // Array of VarInt
	/* Number of elements in the following array, only present if mode is 0 (init) */
	ArraySize2 Optional[VarInt] // Optional VarInt
	RecipeIDs2 Optional[[]VarInt] // Optional Array of VarInt, only present if mode is 0 (init)
}

var _ Packet = (*PlayUnlockRecipes_340_3)(nil)

func (p PlayUnlockRecipes_340_3)Encode(b *PacketBuilder){
	b.VarInt(p.Action)
	b.Bool(p.CraftingBookOpen)
	b.Bool(p.FilteringCraftable)
	p.ArraySize1 = len(p.RecipeIDs)
	b.VarInt(p.ArraySize1)
	for _, v := range p.RecipeIDs {
		b.VarInt(v)
	}
	if p.Action == 0 {
		p.ArraySize2.Set((VarInt)(len(p.RecipeIDs2)))
		for _, v := range p.RecipeIDs2.Assert() {
			b.VarInt(v)
		}
	}
}

func (p *PlayUnlockRecipes_340_3)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Action, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.CraftingBookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.FilteringCraftable, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.ArraySize1, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.RecipeIDs = make([]VarInt, p.ArraySize1)
	for i, _ := range p.RecipeIDs {
		if p.RecipeIDs[i], ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.ArraySize2.Ok = p.Action == 0; p.ArraySize2.Ok {
		if p.ArraySize2.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.RecipeIDs2.Ok = p.Action == 0; p.RecipeIDs2.Ok {
		p.RecipeIDs2 = make([]VarInt, p.ArraySize2.V)
		for i, _ := range p.RecipeIDs2 {
			if p.RecipeIDs2[i], ok = r.VarInt(); !ok {
				return io.EOF
			}
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x69
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x69
type PlayUpdateAdvancements_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name    | Field Type          | Field Type           | Notes                                                       |
	 * |-----------|-------|----------|---------------------|---------------|---------------------|----------------------|-------------------------------------------------------------|
	 * | 0x69      | Play  | Client   | Reset/Clear         | Reset/Clear   | Boolean             | Boolean              | Whether to reset/clear the current advancements.            |
	 * | 0x69      | Play  | Client   | Mapping size        | Mapping size  | VarInt              | VarInt               | Size of the following array.                                |
	 * | 0x69      | Play  | Client   | Advancement mapping | Key           | Array               | Identifier           | The identifier of the advancement.                          |
	 * | 0x69      | Play  | Client   | Advancement mapping | Value         | Array               | Advancement          | See below                                                   |
	 * | 0x69      | Play  | Client   | List size           | List size     | VarInt              | VarInt               | Size of the following array.                                |
	 * | 0x69      | Play  | Client   | Identifiers         | Identifiers   | Array of Identifier | Array of Identifier  | The identifiers of the advancements that should be removed. |
	 * | 0x69      | Play  | Client   | Progress size       | Progress size | VarInt              | VarInt               | Size of the following array.                                |
	 * | 0x69      | Play  | Client   | Progress mapping    | Key           | Array               | Identifier           | The identifier of the advancement.                          |
	 * | 0x69      | Play  | Client   | Progress mapping    | Value         | Array               | Advancement progress | See below.                                                  |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x6a
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x6a
type PlayUpdateAttributes_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name           | Field Name           | Field Type | Field Type             | Notes                                                 |
	 * |-----------|-------|----------|----------------------|----------------------|------------|------------------------|-------------------------------------------------------|
	 * | 0x6A      | Play  | Client   | Entity ID            | Entity ID            | VarInt     | VarInt                 |                                                       |
	 * | 0x6A      | Play  | Client   | Number Of Properties | Number Of Properties | VarInt     | VarInt                 | Number of elements in the following array.            |
	 * | 0x6A      | Play  | Client   | Property             | Key                  | Array      | Identifier             | See below.                                            |
	 * | 0x6A      | Play  | Client   | Property             | Value                | Array      | Double                 | See below.                                            |
	 * | 0x6A      | Play  | Client   | Property             | Number Of Modifiers  | Array      | VarInt                 | Number of elements in the following array.            |
	 * | 0x6A      | Play  | Client   | Property             | Modifiers            | Array      | Array of Modifier Data | See Attribute#Modifiers. Modifier Data defined below. |
	 * 
	 */
}

// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x9
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x9
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x9
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x9
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x9
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x9
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x9
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x9
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x9
type PlayUpdateBlockEntity_498_0 struct {
	Location Position // Position
	/* The type of update to perform, see below */
	Action UByte // Unsigned Byte
	/* Data to set.  May be a TAG_END (0), in which case the block entity at the given location is removed (though this is not required since the client will remove the block entity automatically on chunk unload or block removal) */
	NBTData nbt.NBT // NBT Tag
}

var _ Packet = (*PlayUpdateBlockEntity_498_0)(nil)

func (p PlayUpdateBlockEntity_498_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.UByte(p.Action)
	nbt.WriteNBT(b, p.NBTData)
}

func (p *PlayUpdateBlockEntity_498_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Action, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.NBTData, err = nbt.ReadNBT(r); err != nil {
		return err
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x26
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x26
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x26
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x26
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x26
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x26
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x24
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x24
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x22
type PlayUpdateCommandBlock_758_0 struct {
	Location Position // Position
	Command String // String (32767)
	/* One of SEQUENCE (0), AUTO (1), or REDSTONE (2) */
	Mode VarInt // VarInt enum
	/* 0x01: Track Output (if false, the output of the previous command will not be stored within the command block); 0x02: Is conditional; 0x04: Automatic */
	Flags Byte // Byte
}

var _ Packet = (*PlayUpdateCommandBlock_758_0)(nil)

func (p PlayUpdateCommandBlock_758_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.String(p.Command)
	b.VarInt(p.Mode)
	b.Byte(p.Flags)
}

func (p *PlayUpdateCommandBlock_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Command, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Mode, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x27
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x27
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x27
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x27
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x27
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x27
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x25
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x25
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x23
type PlayUpdateCommandBlockMinecart_758_0 struct {
	EntityID VarInt // VarInt
	Command String // String
	/* If false, the output of the previous command will not be stored within the command block. */
	TrackOutput Bool // Boolean
}

var _ Packet = (*PlayUpdateCommandBlockMinecart_758_0)(nil)

func (p PlayUpdateCommandBlockMinecart_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.String(p.Command)
	b.Bool(p.TrackOutput)
}

func (p *PlayUpdateCommandBlockMinecart_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Command, ok = r.String(); !ok {
		return io.EOF
	}
	if p.TrackOutput, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x2b
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x2b
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x27
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x28
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x26
type PlayUpdateEntityPosition_763_0 struct {
	EntityID VarInt // VarInt
	/* Change in X position as (currentX * 32 - prevX * 32) * 128. */
	DeltaX Short // Short
	/* Change in Y position as (currentY * 32 - prevY * 32) * 128. */
	DeltaY Short // Short
	/* Change in Z position as (currentZ * 32 - prevZ * 32) * 128. */
	DeltaZ Short // Short
	OnGround Bool // Boolean
}

var _ Packet = (*PlayUpdateEntityPosition_763_0)(nil)

func (p PlayUpdateEntityPosition_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Short(p.DeltaX)
	b.Short(p.DeltaY)
	b.Short(p.DeltaZ)
	b.Bool(p.OnGround)
}

func (p *PlayUpdateEntityPosition_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.DeltaX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.DeltaY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.DeltaZ, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x2c
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x2c
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x28
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x29
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x27
type PlayUpdateEntityPositionAndRotation_763_0 struct {
	EntityID VarInt // VarInt
	/* Change in X position as (currentX * 32 - prevX * 32) * 128. */
	DeltaX Short // Short
	/* Change in Y position as (currentY * 32 - prevY * 32) * 128. */
	DeltaY Short // Short
	/* Change in Z position as (currentZ * 32 - prevZ * 32) * 128. */
	DeltaZ Short // Short
	/* New angle, not a delta. */
	Yaw Angle // Angle
	/* New angle, not a delta. */
	Pitch Angle // Angle
	OnGround Bool // Boolean
}

var _ Packet = (*PlayUpdateEntityPositionAndRotation_763_0)(nil)

func (p PlayUpdateEntityPositionAndRotation_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.Short(p.DeltaX)
	b.Short(p.DeltaY)
	b.Short(p.DeltaZ)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlayUpdateEntityPositionAndRotation_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.DeltaX, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.DeltaY, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.DeltaZ, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x2d
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x2d
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x29
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x2a
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x28
type PlayUpdateEntityRotation_763_0 struct {
	EntityID VarInt // VarInt
	/* New angle, not a delta. */
	Yaw Angle // Angle
	/* New angle, not a delta. */
	Pitch Angle // Angle
	OnGround Bool // Boolean
}

var _ Packet = (*PlayUpdateEntityRotation_763_0)(nil)

func (p PlayUpdateEntityRotation_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.UByte(p.Yaw)
	b.UByte(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlayUpdateEntityRotation_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x52
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x52
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x52
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x52
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x49
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x49
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x49
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x48
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x44
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x41
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x41
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x40
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x3e
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x3e
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x3e
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x3e
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x6
type PlayUpdateHealth_758_0 struct {
	/* 0 or less = dead, 20 = full HP */
	Health Float // Float
	/* 0–20 */
	Food VarInt // VarInt
	/* Seems to vary from 0.0 to 5.0 in integer increments */
	FoodSaturation Float // Float
}

var _ Packet = (*PlayUpdateHealth_758_0)(nil)

func (p PlayUpdateHealth_758_0)Encode(b *PacketBuilder){
	b.Float(p.Health)
	b.VarInt(p.Food)
	b.Float(p.FoodSaturation)
}

func (p *PlayUpdateHealth_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Health, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Food, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.FoodSaturation, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x29
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x29
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x29
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x29
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x29
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x28
type PlayUpdateJigsawBlock_758_0 struct {
	/* Block entity location */
	Location Position // Position
	Name String // Identifier
	Target String // Identifier
	Pool String // Identifier
	/* "Turns into" on the GUI, final_state in NBT */
	FinalState String // String
	/* rollable if the attached piece can be rotated, else aligned */
	JointType String // String
}

var _ Packet = (*PlayUpdateJigsawBlock_758_0)(nil)

func (p PlayUpdateJigsawBlock_758_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.String(p.Name)
	b.String(p.Target)
	b.String(p.Pool)
	b.String(p.FinalState)
	b.String(p.JointType)
}

func (p *PlayUpdateJigsawBlock_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Name, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Target, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Pool, ok = r.String(); !ok {
		return io.EOF
	}
	if p.FinalState, ok = r.String(); !ok {
		return io.EOF
	}
	if p.JointType, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x27
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x27
type PlayUpdateJigsawBlock_578_1 struct {
	/* Block entity location */
	Location Position // Position
	AttachmentType String // Identifier
	TargetPool String // Identifier
	/* "Turns into" on the GUI, final_state in NBT */
	FinalState String // String
}

var _ Packet = (*PlayUpdateJigsawBlock_578_1)(nil)

func (p PlayUpdateJigsawBlock_578_1)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.String(p.AttachmentType)
	b.String(p.TargetPool)
	b.String(p.FinalState)
}

func (p *PlayUpdateJigsawBlock_578_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.AttachmentType, ok = r.String(); !ok {
		return io.EOF
	}
	if p.TargetPool, ok = r.String(); !ok {
		return io.EOF
	}
	if p.FinalState, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x25
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x25
type PlayUpdateLight_758_5 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name              | Field Name              | Field Type | Field Type          | Notes                                                                                                                                                                                                                                                                                                                                                                                                                  |
	 * |-----------|-------|----------|-------------------------|-------------------------|------------|---------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x25      | Play  | Client   | Chunk X                 | Chunk X                 | VarInt     | VarInt              | Chunk coordinate (block coordinate divided by 16, rounded down)                                                                                                                                                                                                                                                                                                                                                        |
	 * | 0x25      | Play  | Client   | Chunk Z                 | Chunk Z                 | VarInt     | VarInt              | Chunk coordinate (block coordinate divided by 16, rounded down)                                                                                                                                                                                                                                                                                                                                                        |
	 * | 0x25      | Play  | Client   | Trust Edges             | Trust Edges             | Boolean    | Boolean             | If edges should be trusted for light updates.                                                                                                                                                                                                                                                                                                                                                                          |
	 * | 0x25      | Play  | Client   | Sky Light Mask          | Sky Light Mask          | BitSet     | BitSet              | BitSet containing bits for each section in the world + 2.  Each set bit indicates that the corresponding 16×16×16 chunk section has data in the Sky Light array below.  The least significant bit is for blocks 16 blocks to 1 block below the min world height (one section below the world), while the most significant bit covers blocks 1 to 16 blocks above the max world height (one section above the world). |
	 * | 0x25      | Play  | Client   | Block Light Mask        | Block Light Mask        | BitSet     | BitSet              | BitSet containing bits for each section in the world + 2.  Each set bit indicates that the corresponding 16×16×16 chunk section has data in the Block Light array below.  The order of bits is the same as in Sky Light Mask.                                                                                                                                                                                        |
	 * | 0x25      | Play  | Client   | Empty Sky Light Mask    | Empty Sky Light Mask    | BitSet     | BitSet              | BitSet containing bits for each section in the world + 2.  Each set bit indicates that the corresponding 16×16×16 chunk section has all zeros for its Sky Light data.  The order of bits is the same as in Sky Light Mask.                                                                                                                                                                                           |
	 * | 0x25      | Play  | Client   | Empty Block Light Mask  | Empty Block Light Mask  | BitSet     | BitSet              | BitSet containing bits for each section in the world + 2.  Each set bit indicates that the corresponding 16×16×16 chunk section has all zeros for its Block Light data.  The order of bits is the same as in Sky Light Mask.                                                                                                                                                                                         |
	 * | 0x25      | Play  | Client   | Sky Light array count   | Sky Light array count   | VarInt     | VarInt              | Number of entries in the following array; should match the number of bits set in Sky Light Mask                                                                                                                                                                                                                                                                                                                        |
	 * | 0x25      | Play  | Client   | Sky Light arrays        | Length                  | Array      | VarInt              | Length of the following array in bytes (always 2048)                                                                                                                                                                                                                                                                                                                                                                   |
	 * | 0x25      | Play  | Client   | Sky Light arrays        | Sky Light array         | Array      | Array of 2048 bytes | There is 1 array for each bit set to true in the sky light mask, starting with the lowest value.  Half a byte per light value.                                                                                                                                                                                                                                                                                         |
	 * | 0x25      | Play  | Client   | Block Light array count | Block Light array count | VarInt     | VarInt              | Number of entries in the following array; should match the number of bits set in Block Light Mask                                                                                                                                                                                                                                                                                                                      |
	 * | 0x25      | Play  | Client   | Block Light arrays      | Length                  | Array      | VarInt              | Length of the following array in bytes (always 2048)                                                                                                                                                                                                                                                                                                                                                                   |
	 * | 0x25      | Play  | Client   | Block Light arrays      | Block Light array       | Array      | Array of 2048 bytes | There is 1 array for each bit set to true in the block light mask, starting with the lowest value.  Half a byte per light value.                                                                                                                                                                                                                                                                                       |
	 * 
	 */
}

// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x25
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x25
type PlayUpdateLight_756_6 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name              | Field Name              | Field Type    | Field Type          | Notes                                                                                                                                          |
	 * |-----------|-------|----------|-------------------------|-------------------------|---------------|---------------------|------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x25      | Play  | Client   | Chunk X                 | Chunk X                 | VarInt        | VarInt              | Chunk coordinate (block coordinate divided by 16, rounded down)                                                                                |
	 * | 0x25      | Play  | Client   | Chunk Z                 | Chunk Z                 | VarInt        | VarInt              | Chunk coordinate (block coordinate divided by 16, rounded down)                                                                                |
	 * | 0x25      | Play  | Client   | Trust Edges             | Trust Edges             | Boolean       | Boolean             | If edges should be trusted for light updates.                                                                                                  |
	 * | 0x25      | Play  | Client   | Length 1                | Length 1                | VarInt        | VarInt              | Length of the following array                                                                                                                  |
	 * | 0x25      | Play  | Client   | Sky Light Mask          | Sky Light Mask          | Array of Long | Array of Long       | BitSet containing bits for each sections in the world + 2 (lowest bit 16-1 blocks below min world height, highest 1-16 above max world height) |
	 * | 0x25      | Play  | Client   | Length 2                | Length 2                | VarInt        | VarInt              | Length of the following array                                                                                                                  |
	 * | 0x25      | Play  | Client   | Block Light Mask        | Block Light Mask        | Array of Long | Array of Long       | BitSet containing bits for each sections in the world + 2, same order as sky light                                                             |
	 * | 0x25      | Play  | Client   | Length 3                | Length 3                | VarInt        | VarInt              | Length of the following array                                                                                                                  |
	 * | 0x25      | Play  | Client   | Empty Sky Light Mask    | Empty Sky Light Mask    | Array of Long | Array of Long       | BitSet containing a variable amount of bits (see sky/block light) which indicates sections that have 0 for all their sky light values          |
	 * | 0x25      | Play  | Client   | Length 4                | Length 4                | VarInt        | VarInt              | Length of the following array                                                                                                                  |
	 * | 0x25      | Play  | Client   | Empty Block Light Mask  | Empty Block Light Mask  | Array of Long | Array of Long       | BitSet containing a variable amount of bits (see sky/block light) which indicates sections that have 0 for all their block light values        |
	 * | 0x25      | Play  | Client   | Sky Light array count   | Sky Light array count   | VarInt        | VarInt              | Number of entries in the following array                                                                                                       |
	 * | 0x25      | Play  | Client   | Sky Light arrays        | Length                  | Array         | VarInt              | Length of the following array in bytes (always 2048)                                                                                           |
	 * | 0x25      | Play  | Client   | Sky Light arrays        | Sky Light array         | Array         | Array of 2048 bytes | There is 1 array for each bit set to true in the sky light mask, starting with the lowest value.  Half a byte per light value.                 |
	 * | 0x25      | Play  | Client   | Block Light array count | Block Light array count | VarInt        | VarInt              | Number of entries in the following array                                                                                                       |
	 * | 0x25      | Play  | Client   | Block Light arrays      | Length                  | Array         | VarInt              | Length of the following array in bytes (always 2048)                                                                                           |
	 * | 0x25      | Play  | Client   | Block Light arrays      | Block Light array       | Array         | Array of 2048 bytes | There is 1 array for each bit set to true in the block light mask, starting with the lowest value.  Half a byte per light value.               |
	 * 
	 */
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x23
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x23
type PlayUpdateLight_754_7 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name             | Field Name             | Field Type | Field Type          | Notes                                                                                                                                                                                                                                                                                                                                                                           |
	 * |-----------|-------|----------|------------------------|------------------------|------------|---------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x23      | Play  | Client   | Chunk X                | Chunk X                | VarInt     | VarInt              | Chunk coordinate (block coordinate divided by 16, rounded down)                                                                                                                                                                                                                                                                                                                 |
	 * | 0x23      | Play  | Client   | Chunk Z                | Chunk Z                | VarInt     | VarInt              | Chunk coordinate (block coordinate divided by 16, rounded down)                                                                                                                                                                                                                                                                                                                 |
	 * | 0x23      | Play  | Client   | Trust Edges            | Trust Edges            | Boolean    | Boolean             | If edges should be trusted for light updates.                                                                                                                                                                                                                                                                                                                                   |
	 * | 0x23      | Play  | Client   | Sky Light Mask         | Sky Light Mask         | VarInt     | VarInt              | Mask containing 18 bits, with the lowest bit corresponding to chunk section -1 (in the void, y=-16 to y=-1) and the highest bit for chunk section 16 (above the world, y=256 to y=271)                                                                                                                                                                                          |
	 * | 0x23      | Play  | Client   | Block Light Mask       | Block Light Mask       | VarInt     | VarInt              | Mask containing 18 bits, with the same order as sky light                                                                                                                                                                                                                                                                                                                       |
	 * | 0x23      | Play  | Client   | Empty Sky Light Mask   | Empty Sky Light Mask   | VarInt     | VarInt              | Mask containing 18 bits, which indicates sections that have 0 for all their sky light values.  If a section is set in both this mask and the main sky light mask, it is ignored for this mask and it is included in the sky light arrays (the notchian server does not create such masks).  If it is only set in this mask, it is not included in the sky light arrays.         |
	 * | 0x23      | Play  | Client   | Empty Block Light Mask | Empty Block Light Mask | VarInt     | VarInt              | Mask containing 18 bits, which indicates sections that have 0 for all their block light values.  If a section is set in both this mask and the main block light mask, it is ignored for this mask and it is included in the block light arrays (the notchian server does not create such masks).  If it is only set in this mask, it is not included in the block light arrays. |
	 * | 0x23      | Play  | Client   | Sky Light arrays       | Length                 | Array      | VarInt              | Length of the following array in bytes (always 2048)                                                                                                                                                                                                                                                                                                                            |
	 * | 0x23      | Play  | Client   | Sky Light arrays       | Sky Light array        | Array      | Array of 2048 bytes | There is 1 array for each bit set to true in the sky light mask, starting with the lowest value.  Half a byte per light value.                                                                                                                                                                                                                                                  |
	 * | 0x23      | Play  | Client   | Block Light arrays     | Length                 | Array      | VarInt              | Length of the following array in bytes (always 2048)                                                                                                                                                                                                                                                                                                                            |
	 * | 0x23      | Play  | Client   | Block Light arrays     | Block Light array      | Array      | Array of 2048 bytes | There is 1 array for each bit set to true in the block light mask, starting with the lowest value.  Half a byte per light value.                                                                                                                                                                                                                                                |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x58
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x58
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x54
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x56
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x53
type PlayUpdateObjectives_763_0 struct {
	/* A unique name for the objective. */
	ObjectiveName String // String (16)
	/* 0 to create the scoreboard. 1 to remove the scoreboard. 2 to update the display text. */
	Mode Byte // Byte
	/* Only if mode is 0 or 2. The text to be displayed for the score. */
	ObjectiveValue Optional[Object] // Optional Chat
	/* Only if mode is 0 or 2. 0 = "integer", 1 = "hearts". */
	Type Optional[VarInt] // Optional VarInt Enum
}

var _ Packet = (*PlayUpdateObjectives_763_0)(nil)

func (p PlayUpdateObjectives_763_0)Encode(b *PacketBuilder){
	b.String(p.ObjectiveName)
	b.Byte(p.Mode)
	if p.Mode == 0 || p.Mode == 2 {
		b.JSON(p.ObjectiveValue.Assert())
		b.VarInt(p.Type.Assert())
	}
}

func (p *PlayUpdateObjectives_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ObjectiveName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Mode, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ObjectiveValue.Ok = p.Mode == 0 || p.Mode == 2; p.ObjectiveValue.Ok {
		if err = r.JSON(&p.ObjectiveValue.V); err != nil {
			return err
		}
	}
	if p.Type.Ok = p.Mode == 0 || p.Mode == 2; p.Type.Ok {
		if p.Type.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x3d
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x3d
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x39
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x3a
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x37
type PlayUpdateRecipeBook_763_0 struct {
	/* 0: init, 1: add, 2: remove. */
	Action VarInt // VarInt
	/* If true, then the crafting recipe book will be open when the player opens its inventory. */
	CraftingRecipeBookOpen Bool // Boolean
	/* If true, then the filtering option is active when the players opens its inventory. */
	CraftingRecipeBookFilterActive Bool // Boolean
	/* If true, then the smelting recipe book will be open when the player opens its inventory. */
	SmeltingRecipeBookOpen Bool // Boolean
	/* If true, then the filtering option is active when the players opens its inventory. */
	SmeltingRecipeBookFilterActive Bool // Boolean
	/* If true, then the blast furnace recipe book will be open when the player opens its inventory. */
	BlastFurnaceRecipeBookOpen Bool // Boolean
	/* If true, then the filtering option is active when the players opens its inventory. */
	BlastFurnaceRecipeBookFilterActive Bool // Boolean
	/* If true, then the smoker recipe book will be open when the player opens its inventory. */
	SmokerRecipeBookOpen Bool // Boolean
	/* If true, then the filtering option is active when the players opens its inventory. */
	SmokerRecipeBookFilterActive Bool // Boolean
	/* Number of elements in the following array. */
	ArraySize1 VarInt // VarInt
	RecipeIDs []String // Array of Identifier
	/* Number of elements in the following array, only present if mode is 0 (init). */
	ArraySize2 Optional[VarInt] // Optional VarInt
	/* Only present if mode is 0 (init) */
	RecipeIDs2 Optional[[]String] // Optional Array of Identifier
}

var _ Packet = (*PlayUpdateRecipeBook_763_0)(nil)

func (p PlayUpdateRecipeBook_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.Action)
	b.Bool(p.CraftingRecipeBookOpen)
	b.Bool(p.CraftingRecipeBookFilterActive)
	b.Bool(p.SmeltingRecipeBookOpen)
	b.Bool(p.SmeltingRecipeBookFilterActive)
	b.Bool(p.BlastFurnaceRecipeBookOpen)
	b.Bool(p.BlastFurnaceRecipeBookFilterActive)
	b.Bool(p.SmokerRecipeBookOpen)
	b.Bool(p.SmokerRecipeBookFilterActive)
	p.ArraySize1 = len(p.RecipeIDs)
	b.VarInt(p.ArraySize1)
	for _, v := range p.RecipeIDs {
		b.VarInt(v)
	}
	if p.Action == 0 {
		p.ArraySize2.Set((VarInt)(len(p.RecipeIDs2)))
		for _, v := range p.RecipeIDs2.Assert() {
			b.VarInt(v)
		}
	}
}

func (p *PlayUpdateRecipeBook_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Action, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.CraftingRecipeBookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.CraftingRecipeBookFilterActive, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.SmeltingRecipeBookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.SmeltingRecipeBookFilterActive, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.BlastFurnaceRecipeBookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.BlastFurnaceRecipeBookFilterActive, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.SmokerRecipeBookOpen, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.SmokerRecipeBookFilterActive, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.ArraySize1, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.RecipeIDs = make([]VarInt, p.ArraySize1)
	for i, _ := range p.RecipeIDs {
		if p.RecipeIDs[i], ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.ArraySize2.Ok = p.Action == 0; p.ArraySize2.Ok {
		if p.ArraySize2.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	if p.RecipeIDs2.Ok = p.Action == 0; p.RecipeIDs2.Ok {
		p.RecipeIDs2 = make([]VarInt, p.ArraySize2.V)
		for i, _ := range p.RecipeIDs2 {
			if p.RecipeIDs2[i], ok = r.VarInt(); !ok {
				return io.EOF
			}
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x6d
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x6d
type PlayUpdateRecipes_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name  | Field Name  | Field Type | Field Type | Notes                                      |
	 * |-----------|-------|----------|-------------|-------------|------------|------------|--------------------------------------------|
	 * | 0x6D      | Play  | Client   | Num Recipes | Num Recipes | VarInt     | VarInt     | Number of elements in the following array. |
	 * | 0x6D      | Play  | Client   | Recipe      | Type        | Array      | Identifier | The recipe type, see below.                |
	 * | 0x6D      | Play  | Client   | Recipe      | Recipe ID   | Array      | Identifier |                                            |
	 * | 0x6D      | Play  | Client   | Recipe      | Data        | Array      | Varies     | Additional data for the recipe.            |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x5b
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x5b
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x57
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x59
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x56
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x56
type PlayUpdateScore_763_0 struct {
	/* The entity whose score this is.  For players, this is their username; for other entities, it is their UUID. */
	EntityName String // String (40)
	/* 0 to create/update an item. 1 to remove an item. */
	Action VarInt // VarInt Enum
	/* The name of the objective the score belongs to. */
	ObjectiveName String // String (16)
	/* The score to be displayed next to the entry. Only sent when Action does not equal 1. */
	Value Optional[VarInt] // Optional VarInt
}

var _ Packet = (*PlayUpdateScore_763_0)(nil)

func (p PlayUpdateScore_763_0)Encode(b *PacketBuilder){
	b.String(p.EntityName)
	b.VarInt(p.Action)
	b.String(p.ObjectiveName)
	if p.Action != 1 {
		b.VarInt(p.Value.Assert())
	}
}

func (p *PlayUpdateScore_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Action, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ObjectiveName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Value.Ok = p.Action != 1; p.Value.Ok {
		if p.Value.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x56
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x56
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x56
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x4d
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x4d
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x4d
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x4c
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x48
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x45
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x45
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x44
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x42
type PlayUpdateScore_757_1 struct {
	/* The entity whose score this is.  For players, this is their username; for other entities, it is their UUID. */
	EntityName String // String (40)
	/* 0 to create/update an item. 1 to remove an item. */
	Action Byte // Byte
	/* The name of the objective the score belongs to */
	ObjectiveName String // String (16)
	/* The score to be displayed next to the entry. Only sent when Action does not equal 1. */
	Value Optional[VarInt] // Optional VarInt
}

var _ Packet = (*PlayUpdateScore_757_1)(nil)

func (p PlayUpdateScore_757_1)Encode(b *PacketBuilder){
	b.String(p.EntityName)
	b.Byte(p.Action)
	b.String(p.ObjectiveName)
	if p.Action != 1 {
		b.VarInt(p.Value.Assert())
	}
}

func (p *PlayUpdateScore_757_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Action, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ObjectiveName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Value.Ok = p.Action != 1; p.Value.Ok {
		if p.Value.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x42
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x42
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x42
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x3c
type PlayUpdateScore_315_2 struct {
	/* The name of the score to be updated or removed */
	ScoreName String // String
	/* 0 to create/update an item. 1 to remove an item. */
	Action Byte // Byte
	/* The name of the objective the score belongs to */
	ObjectiveName String // String
	/* The score to be displayed next to the entry. Only sent when Action does not equal 1. */
	Value Optional[VarInt] // Optional VarInt
}

var _ Packet = (*PlayUpdateScore_315_2)(nil)

func (p PlayUpdateScore_315_2)Encode(b *PacketBuilder){
	b.String(p.ScoreName)
	b.Byte(p.Action)
	b.String(p.ObjectiveName)
	if p.Action != 1 {
		b.VarInt(p.Value.Assert())
	}
}

func (p *PlayUpdateScore_315_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ScoreName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Action, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ObjectiveName, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Value.Ok = p.Action != 1; p.Value.Ok {
		if p.Value.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x43
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x3f
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x40
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x3d
type PlayUpdateSectionBlocks_762_1 struct {
	/* Chunk section coordinate (encoded chunk x and z with each 22 bits, and section y with 20 bits, from left to right). */
	ChunkSectionPosition Long // Long
	/* Whether to ignore light updates caused by the contained changes. Always inverse the preceding Update Light packet's "Trust Edges" bool */
	SuppressLightUpdates Bool // Boolean
	/* Number of elements in the following array. */
	BlocksArraySize VarInt // VarInt
	/* Each entry is composed of the block state id, shifted left by 12, and the relative block position in the chunk section (4 bits for x, z, and y, from left to right). */
	Blocks []VarLong // Array of VarLong
}

var _ Packet = (*PlayUpdateSectionBlocks_762_1)(nil)

func (p PlayUpdateSectionBlocks_762_1)Encode(b *PacketBuilder){
	b.Long(p.ChunkSectionPosition)
	b.Bool(p.SuppressLightUpdates)
	b.VarInt(p.BlocksArraySize)
	TODO_Encode_Array(p.Blocks)
}

func (p *PlayUpdateSectionBlocks_762_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ChunkSectionPosition, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.SuppressLightUpdates, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.BlocksArraySize, ok = r.VarInt(); !ok {
		return io.EOF
	}
	TODO_Decode_Array(p.Blocks)
	return nil
}

// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x2e
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x2e
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x2e
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x2d
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x2b
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x2b
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x2b
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x2b
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x2b
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x2b
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x29
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x29
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x26
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x1c
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x1c
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x1c
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x19
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x19
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x19
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x19
type PlayUpdateSign_762_1 struct {
	/* Block Coordinates */
	Location Position // Position
	/* First line of text in the sign */
	Line1 String // String (384)
	/* Second line of text in the sign */
	Line2 String // String (384)
	/* Third line of text in the sign */
	Line3 String // String (384)
	/* Fourth line of text in the sign */
	Line4 String // String (384)
}

var _ Packet = (*PlayUpdateSign_762_1)(nil)

func (p PlayUpdateSign_762_1)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.String(p.Line1)
	b.String(p.Line2)
	b.String(p.Line3)
	b.String(p.Line4)
}

func (p *PlayUpdateSign_762_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Line1, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Line2, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Line3, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Line4, ok = r.String(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x57
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x57
type PlayUpdateSimulationDistance_758_0 struct {
	/* The distance that the client will process specific things, such as entities. */
	SimulationDistance VarInt // VarInt
}

var _ Packet = (*PlayUpdateSimulationDistance_758_0)(nil)

func (p PlayUpdateSimulationDistance_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.SimulationDistance)
}

func (p *PlayUpdateSimulationDistance_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.SimulationDistance, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x2a
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x2a
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x2a
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x2a
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x2a
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x2a
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x28
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x28
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x25
type PlayUpdateStructureBlock_758_0 struct {
	/* Block entity location */
	Location Position // Position
	/* An additional action to perform beyond simply saving the given data; see below */
	Action VarInt // VarInt enum
	/* One of SAVE (0), LOAD (1), CORNER (2), DATA (3). */
	Mode VarInt // VarInt enum
	Name String // String
	/* Between -32 and 32 */
	OffsetX Byte // Byte
	/* Between -32 and 32 */
	OffsetY Byte // Byte
	/* Between -32 and 32 */
	OffsetZ Byte // Byte
	/* Between 0 and 32 */
	SizeX Byte // Byte
	/* Between 0 and 32 */
	SizeY Byte // Byte
	/* Between 0 and 32 */
	SizeZ Byte // Byte
	/* One of NONE (0), LEFT_RIGHT (1), FRONT_BACK (2). */
	Mirror VarInt // VarInt enum
	/* One of NONE (0), CLOCKWISE_90 (1), CLOCKWISE_180 (2), COUNTERCLOCKWISE_90 (3). */
	Rotation VarInt // VarInt enum
	Metadata String // String
	/* Between 0 and 1 */
	Integrity Float // Float
	Seed VarLong // VarLong
	/* 0x01: Ignore entities; 0x02: Show air; 0x04: Show bounding box */
	Flags Byte // Byte
}

var _ Packet = (*PlayUpdateStructureBlock_758_0)(nil)

func (p PlayUpdateStructureBlock_758_0)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.VarInt(p.Action)
	b.VarInt(p.Mode)
	b.String(p.Name)
	b.Byte(p.OffsetX)
	b.Byte(p.OffsetY)
	b.Byte(p.OffsetZ)
	b.Byte(p.SizeX)
	b.Byte(p.SizeY)
	b.Byte(p.SizeZ)
	b.VarInt(p.Mirror)
	b.VarInt(p.Rotation)
	b.String(p.Metadata)
	b.Float(p.Integrity)
	b.VarLong(p.Seed)
	b.Byte(p.Flags)
}

func (p *PlayUpdateStructureBlock_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Action, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Mode, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Name, ok = r.String(); !ok {
		return io.EOF
	}
	if p.OffsetX, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.OffsetY, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.OffsetZ, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.SizeX, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.SizeY, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.SizeZ, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Mirror, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Rotation, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Metadata, ok = r.String(); !ok {
		return io.EOF
	}
	if p.Integrity, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Seed, ok = r.VarLong(); !ok {
		return io.EOF
	}
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x6e
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x6e
type PlayUpdateTags_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name          | Field Name          | Field Type | Field Type  | Notes                                                                                                                                        |
	 * |-----------|-------|----------|---------------------|---------------------|------------|-------------|----------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x6E      | Play  | Client   | Length of the array | Length of the array | VarInt     | VarInt      |                                                                                                                                              |
	 * | 0x6E      | Play  | Client   | Array of tags       | Tag type            | Array      | Identifier  | Tag identifier (Vanilla required tags are minecraft:block, minecraft:item, minecraft:fluid, minecraft:entity_type, and minecraft:game_event) |
	 * | 0x6E      | Play  | Client   | Array of tags       | Array of Tag        | Array      | (See below) |                                                                                                                                              |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x5a
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x5a
type PlayUpdateTeams_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name                   | Field Name          | Field Type           | Notes                                                                                                                  |
	 * |-----------|-------|----------|------------------------------|---------------------|----------------------|------------------------------------------------------------------------------------------------------------------------|
	 * | 0x5A      | Play  | Client   | Team Name                    | Team Name           | String (16)          | A unique name for the team. (Shared with scoreboard).                                                                  |
	 * | 0x5A      | Play  | Client   | Mode                         | Mode                | Byte                 | Determines the layout of the remaining packet.                                                                         |
	 * | 0x5A      | Play  | Client   | 0: create team               | Team Display Name   | Chat                 |                                                                                                                        |
	 * | 0x5A      | Play  | Client   | 0: create team               | Friendly Flags      | Byte                 | Bit mask. 0x01: Allow friendly fire, 0x02: can see invisible players on same team.                                     |
	 * | 0x5A      | Play  | Client   | 0: create team               | Name Tag Visibility | String Enum (32)     | always, hideForOtherTeams, hideForOwnTeam, never.                                                                      |
	 * | 0x5A      | Play  | Client   | 0: create team               | Collision Rule      | String Enum (32)     | always, pushOtherTeams, pushOwnTeam, never.                                                                            |
	 * | 0x5A      | Play  | Client   | 0: create team               | Team Color          | VarInt Enum          | Used to color the name of players on the team; see below.                                                              |
	 * | 0x5A      | Play  | Client   | 0: create team               | Team Prefix         | Chat                 | Displayed before the names of players that are part of this team.                                                      |
	 * | 0x5A      | Play  | Client   | 0: create team               | Team Suffix         | Chat                 | Displayed after the names of players that are part of this team.                                                       |
	 * | 0x5A      | Play  | Client   | 0: create team               | Entity Count        | VarInt               | Number of elements in the following array.                                                                             |
	 * | 0x5A      | Play  | Client   | 0: create team               | Entities            | Array of String (40) | Identifiers for the entities in this team.  For players, this is their username; for other entities, it is their UUID. |
	 * | 0x5A      | Play  | Client   | 1: remove team               | no fields           | no fields            |                                                                                                                        |
	 * | 0x5A      | Play  | Client   | 2: update team info          | Team Display Name   | Chat                 |                                                                                                                        |
	 * | 0x5A      | Play  | Client   | 2: update team info          | Friendly Flags      | Byte                 | Bit mask. 0x01: Allow friendly fire, 0x02: can see invisible entities on same team.                                    |
	 * | 0x5A      | Play  | Client   | 2: update team info          | Name Tag Visibility | String Enum (32)     | always, hideForOtherTeams, hideForOwnTeam, never                                                                       |
	 * | 0x5A      | Play  | Client   | 2: update team info          | Collision Rule      | String Enum (32)     | always, pushOtherTeams, pushOwnTeam, never                                                                             |
	 * | 0x5A      | Play  | Client   | 2: update team info          | Team Color          | VarInt Enum          | Used to color the name of players on the team; see below.                                                              |
	 * | 0x5A      | Play  | Client   | 2: update team info          | Team Prefix         | Chat                 | Displayed before the names of players that are part of this team.                                                      |
	 * | 0x5A      | Play  | Client   | 2: update team info          | Team Suffix         | Chat                 | Displayed after the names of players that are part of this team.                                                       |
	 * | 0x5A      | Play  | Client   | 3: add entities to team      | Entity Count        | VarInt               | Number of elements in the following array.                                                                             |
	 * | 0x5A      | Play  | Client   | 3: add entities to team      | Entities            | Array of String (40) | Identifiers for the added entities.  For players, this is their username; for other entities, it is their UUID.        |
	 * | 0x5A      | Play  | Client   | 4: remove entities from team | Entity Count        | VarInt               | Number of elements in the following array.                                                                             |
	 * | 0x5A      | Play  | Client   | 4: remove entities from team | Entities            | Array of String (40) | Identifiers for the removed entities.  For players, this is their username; for other entities, it is their UUID.      |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x5e
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x5e
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x5a
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x5c
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x59
type PlayUpdateTime_763_0 struct {
	/* In ticks; not changed by server commands. */
	WorldAge Long // Long
	/* The world (or region) time, in ticks. If negative the sun will stop moving at the Math.abs of the time. */
	TimeOfDay Long // Long
}

var _ Packet = (*PlayUpdateTime_763_0)(nil)

func (p PlayUpdateTime_763_0)Encode(b *PacketBuilder){
	b.Long(p.WorldAge)
	b.Long(p.TimeOfDay)
}

func (p *PlayUpdateTime_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WorldAge, ok = r.Long(); !ok {
		return io.EOF
	}
	if p.TimeOfDay, ok = r.Long(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x4a
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x4a
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x4a
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x4a
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x41
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x41
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x42
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x41
type PlayUpdateViewDistance_758_0 struct {
	/* Render distance (2-32) */
	ViewDistance VarInt // VarInt
}

var _ Packet = (*PlayUpdateViewDistance_758_0)(nil)

func (p PlayUpdateViewDistance_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.ViewDistance)
}

func (p *PlayUpdateViewDistance_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ViewDistance, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x49
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x49
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x49
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x49
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x40
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x40
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x41
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x40
type PlayUpdateViewPosition_758_0 struct {
	/* Chunk X coordinate of the player's position */
	ChunkX VarInt // VarInt
	/* Chunk Z coordinate of the player's position */
	ChunkZ VarInt // VarInt
}

var _ Packet = (*PlayUpdateViewPosition_758_0)(nil)

func (p PlayUpdateViewPosition_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.ChunkX)
	b.VarInt(p.ChunkZ)
}

func (p *PlayUpdateViewPosition_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.ChunkX, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ChunkZ, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x33
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x30
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x30
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x2f
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x2f
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x2f
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x2f
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x2f
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0xa
type PlayUseBed_404_0 struct {
	/* Sleeping player's EID */
	EntityID VarInt // VarInt
	/* Block location of the head part of the bed */
	Location Position // Position
}

var _ Packet = (*PlayUseBed_404_0)(nil)

func (p PlayUseBed_404_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	p.Location.Encode(b)
}

func (p *PlayUseBed_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0xd
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0xa
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0xa
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0xb
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0xa
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0xa
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0xa
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0xa
type PlayUseEntity_404_0 struct {
	Target VarInt // VarInt
	/* 0: interact, 1: attack, 2: interact at */
	Type VarInt // VarInt Enum
	/* Only if Type is interact at */
	TargetX Optional[Float] // Optional Float
	/* Only if Type is interact at */
	TargetY Optional[Float] // Optional Float
	/* Only if Type is interact at */
	TargetZ Optional[Float] // Optional Float
	/* Only if Type is interact or interact at; 0: main hand, 1: off hand */
	Hand Optional[VarInt] // Optional VarInt Enum
}

var _ Packet = (*PlayUseEntity_404_0)(nil)

func (p PlayUseEntity_404_0)Encode(b *PacketBuilder){
	b.VarInt(p.Target)
	b.VarInt(p.Type)
	if p.Type == 2 {
		b.Float(p.TargetX.Assert())
		b.Float(p.TargetY.Assert())
		b.Float(p.TargetZ.Assert())
	}
	if p.Type == 0 || p.Type == 2 {
		b.VarInt(p.Hand.Assert())
	}
}

func (p *PlayUseEntity_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Target, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Type, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.TargetX.Ok = p.Type == 2; p.TargetX.Ok {
		if p.TargetX.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.TargetY.Ok = p.Type == 2; p.TargetY.Ok {
		if p.TargetY.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.TargetZ.Ok = p.Type == 2; p.TargetZ.Ok {
		if p.TargetZ.V, ok = r.Float(); !ok {
			return io.EOF
		}
	}
	if p.Hand.Ok = p.Type == 0 || p.Type == 2; p.Hand.Ok {
		if p.Hand.V, ok = r.VarInt(); !ok {
			return io.EOF
		}
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x32
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x32
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x32
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x32
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x31
type PlayUseItem_763_0 struct {
	/* Hand used for the animation. 0: main hand, 1: off hand. */
	Hand VarInt // VarInt Enum
	Sequence VarInt // VarInt
}

var _ Packet = (*PlayUseItem_763_0)(nil)

func (p PlayUseItem_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.Hand)
	b.VarInt(p.Sequence)
}

func (p *PlayUseItem_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Hand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Sequence, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x2f
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x2f
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x2f
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x2f
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x2f
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x2f
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x2d
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x2d
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x2a
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x20
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x20
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x20
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x1d
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x1d
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x1d
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x1d
type PlayUseItem_758_1 struct {
	/* Hand used for the animation. 0: main hand, 1: off hand. */
	Hand VarInt // VarInt Enum
}

var _ Packet = (*PlayUseItem_758_1)(nil)

func (p PlayUseItem_758_1)Encode(b *PacketBuilder){
	b.VarInt(p.Hand)
}

func (p *PlayUseItem_758_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Hand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x31
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x31
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x31
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x31
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x30
type PlayUseItemOn_763_0 struct {
	/* The hand from which the block is placed; 0: main hand, 1: off hand. */
	Hand VarInt // VarInt Enum
	/* Block position. */
	Location Position // Position
	/* The face on which the block is placed (as documented at Player Action). */
	Face VarInt // VarInt Enum
	/* The position of the crosshair on the block, from 0 to 1 increasing from west to east. */
	CursorPositionX Float // Float
	/* The position of the crosshair on the block, from 0 to 1 increasing from bottom to top. */
	CursorPositionY Float // Float
	/* The position of the crosshair on the block, from 0 to 1 increasing from north to south. */
	CursorPositionZ Float // Float
	/* True when the player's head is inside of a block. */
	InsideBlock Bool // Boolean
	Sequence VarInt // VarInt
}

var _ Packet = (*PlayUseItemOn_763_0)(nil)

func (p PlayUseItemOn_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.Hand)
	p.Location.Encode(b)
	b.VarInt(p.Face)
	b.Float(p.CursorPositionX)
	b.Float(p.CursorPositionY)
	b.Float(p.CursorPositionZ)
	b.Bool(p.InsideBlock)
	b.VarInt(p.Sequence)
}

func (p *PlayUseItemOn_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Hand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Face, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.CursorPositionX, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.CursorPositionY, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.CursorPositionZ, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.InsideBlock, ok = r.Bool(); !ok {
		return io.EOF
	}
	if p.Sequence, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x2c
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x2c
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x2c
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x2c
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x2b
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x2b
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x2d
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x2c
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x2b
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x29
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x29
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x29
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x29
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x29
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x29
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x29
type PlayVehicleMove_758_0 struct {
	/* Absolute position (X coordinate) */
	X Double // Double
	/* Absolute position (Y coordinate) */
	Y Double // Double
	/* Absolute position (Z coordinate) */
	Z Double // Double
	/* Absolute rotation on the vertical axis, in degrees */
	Yaw Float // Float
	/* Absolute rotation on the horizontal axis, in degrees */
	Pitch Float // Float
}

var _ Packet = (*PlayVehicleMove_758_0)(nil)

func (p PlayVehicleMove_758_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.Float(p.Yaw)
	b.Float(p.Pitch)
}

func (p *PlayVehicleMove_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x15
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x15
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x15
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x15
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x16
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x16
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x15
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x15
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x13
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x10
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x10
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x11
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x10
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x10
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x10
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x10
type PlayVehicleMoveServer_758_0 struct {
	/* Absolute position (X coordinate) */
	X Double // Double
	/* Absolute position (Y coordinate) */
	Y Double // Double
	/* Absolute position (Z coordinate) */
	Z Double // Double
	/* Absolute rotation on the vertical axis, in degrees */
	Yaw Float // Float
	/* Absolute rotation on the horizontal axis, in degrees */
	Pitch Float // Float
}

var _ Packet = (*PlayVehicleMoveServer_758_0)(nil)

func (p PlayVehicleMoveServer_758_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.Float(p.Yaw)
	b.Float(p.Pitch)
}

func (p *PlayVehicleMoveServer_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x11
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x11
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x13
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x12
type PlayWindowConfirmation_754_0 struct {
	/* The ID of the window that the action occurred in */
	WindowID Byte // Byte
	/* Every action that is to be accepted has a unique number. This number is an incrementing integer (starting at 0) with separate counts for each window ID. */
	ActionNumber Short // Short
	/* Whether the action was accepted */
	Accepted Bool // Boolean
}

var _ Packet = (*PlayWindowConfirmation_754_0)(nil)

func (p PlayWindowConfirmation_754_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.Short(p.ActionNumber)
	b.Bool(p.Accepted)
}

func (p *PlayWindowConfirmation_754_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ActionNumber, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.Accepted, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x7
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x7
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x7
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x7
type PlayWindowConfirmationServer_754_0 struct {
	/* The ID of the window that the action occurred in */
	WindowID Byte // Byte
	/* Every action that is to be accepted has a unique number. This number is an incrementing integer (starting at 1) with separate counts for each window ID. */
	ActionNumber Short // Short
	/* Whether the action was accepted */
	Accepted Bool // Boolean
}

var _ Packet = (*PlayWindowConfirmationServer_754_0)(nil)

func (p PlayWindowConfirmationServer_754_0)Encode(b *PacketBuilder){
	b.Byte(p.WindowID)
	b.Short(p.ActionNumber)
	b.Bool(p.Accepted)
}

func (p *PlayWindowConfirmationServer_754_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.ActionNumber, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.Accepted, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x14
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x14
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x14
type PlayWindowItems_758_0 struct {
	/* The ID of window which items are being sent for. 0 for player inventory. */
	WindowID UByte // Unsigned Byte
	/* See State ID */
	StateID VarInt // VarInt
	/* Number of elements in the following array. */
	Count VarInt // VarInt
	SlotData []*data.Slot // Array of Slot
	/* Item held by player. */
	CarriedItem *data.Slot // Slot
}

var _ Packet = (*PlayWindowItems_758_0)(nil)

func (p PlayWindowItems_758_0)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
	b.VarInt(p.StateID)
	p.Count = (VarInt)(len(p.SlotData))
	b.VarInt(p.Count)
	for _, v := range p.SlotData {
		v.Encode(b)
	}
	p.CarriedItem.Encode(b)
}

func (p *PlayWindowItems_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.StateID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Count, ok = r.VarInt(); !ok {
		return io.EOF
	}
	p.SlotData = make([]*data.Slot, p.Count)
	for i, _ := range p.SlotData {
		p.SlotData[i] = new(data.Slot)
		if err = p.SlotData[i].DecodeFrom(r); err != nil {
			return err
		}
	}
	p.CarriedItem = new(data.Slot)
	if err = p.CarriedItem.DecodeFrom(r); err != nil {
		return err
	}
	return nil
}

// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x14
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x13
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x13
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x15
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x14
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x15
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x14
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x14
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x14
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x14
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x14
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x14
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x14
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x30
type PlayWindowItems_755_1 struct {
	/* The ID of window which items are being sent for. 0 for player inventory. */
	WindowID UByte // Unsigned Byte
	/* Number of elements in the following array */
	Count Short // Short
	SlotData []*data.Slot // Array of Slot
}

var _ Packet = (*PlayWindowItems_755_1)(nil)

func (p PlayWindowItems_755_1)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
	p.Count = (Short)(len(p.SlotData))
	b.Short(p.Count)
	for _, v := range p.SlotData {
		v.Encode(b)
	}
}

func (p *PlayWindowItems_755_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Count, ok = r.Short(); !ok {
		return io.EOF
	}
	p.SlotData = make([]*data.Slot, p.Count)
	for i, _ := range p.SlotData {
		p.SlotData[i] = new(data.Slot)
		if err = p.SlotData[i].DecodeFrom(r); err != nil {
			return err
		}
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x15
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x15
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x15
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x15
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x14
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x14
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x16
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x15
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x16
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x15
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x15
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x15
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x15
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x15
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x15
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x15
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x31
type PlayWindowProperty_758_0 struct {
	WindowID UByte // Unsigned Byte
	/* The property to be updated, see below */
	Property Short // Short
	/* The new value for the property, see below */
	Value Short // Short
}

var _ Packet = (*PlayWindowProperty_758_0)(nil)

func (p PlayWindowProperty_758_0)Encode(b *PacketBuilder){
	b.UByte(p.WindowID)
	b.Short(p.Property)
	b.Short(p.Value)
}

func (p *PlayWindowProperty_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WindowID, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.Property, ok = r.Short(); !ok {
		return io.EOF
	}
	if p.Value, ok = r.Short(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x3d
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x3d
type PlayWorldBorder_753_1 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name            | Field Name               | Field Type  | Notes                                                                                                                                                                                                                                        |
	 * |-----------|-------|----------|-----------------------|--------------------------|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x3D      | Play  | Client   | Action                | Action                   | VarInt Enum | Determines the format of the rest of the packet                                                                                                                                                                                              |
	 * | 0x3D      | Play  | Client   | Action                | Field Name               |             |                                                                                                                                                                                                                                              |
	 * | 0x3D      | Play  | Client   | 0: set size           | Diameter                 | Double      | Length of a single side of the world border, in meters                                                                                                                                                                                       |
	 * | 0x3D      | Play  | Client   | 1: lerp size          | Old Diameter             | Double      | Current length of a single side of the world border, in meters                                                                                                                                                                               |
	 * | 0x3D      | Play  | Client   | 1: lerp size          | New Diameter             | Double      | Target length of a single side of the world border, in meters                                                                                                                                                                                |
	 * | 0x3D      | Play  | Client   | 1: lerp size          | Speed                    | VarLong     | Number of real-time milliseconds until New Diameter is reached. It appears that Notchian server does not sync world border speed to game ticks, so it gets out of sync with server lag. If the world border is not moving, this is set to 0. |
	 * | 0x3D      | Play  | Client   | 2: set center         | X                        | Double      |                                                                                                                                                                                                                                              |
	 * | 0x3D      | Play  | Client   | 2: set center         | Z                        | Double      |                                                                                                                                                                                                                                              |
	 * | 0x3D      | Play  | Client   | 3: initialize         | X                        | Double      |                                                                                                                                                                                                                                              |
	 * | 0x3D      | Play  | Client   | 3: initialize         | Z                        | Double      |                                                                                                                                                                                                                                              |
	 * | 0x3D      | Play  | Client   | 3: initialize         | Old Diameter             | Double      | Current length of a single side of the world border, in meters                                                                                                                                                                               |
	 * | 0x3D      | Play  | Client   | 3: initialize         | New Diameter             | Double      | Target length of a single side of the world border, in meters                                                                                                                                                                                |
	 * | 0x3D      | Play  | Client   | 3: initialize         | Speed                    | VarLong     | Number of real-time milliseconds until New Diameter is reached. It appears that Notchian server does not sync world border speed to game ticks, so it gets out of sync with server lag. If the world border is not moving, this is set to 0. |
	 * | 0x3D      | Play  | Client   | 3: initialize         | Portal Teleport Boundary | VarInt      | Resulting coordinates from a portal teleport are limited to ±value. Usually 29999984.                                                                                                                                                       |
	 * | 0x3D      | Play  | Client   | 3: initialize         | Warning Time             | VarInt      | In seconds as set by /worldborder warning time                                                                                                                                                                                               |
	 * | 0x3D      | Play  | Client   | 3: initialize         | Warning Blocks           | VarInt      | In meters                                                                                                                                                                                                                                    |
	 * | 0x3D      | Play  | Client   | 4: set warning time   | Warning Time             | VarInt      | In seconds as set by /worldborder warning time                                                                                                                                                                                               |
	 * | 0x3D      | Play  | Client   | 5: set warning blocks | Warning Blocks           | VarInt      | In meters                                                                                                                                                                                                                                    |
	 * 
	 */
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x38
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x38
type PlayWorldBorder_340_4 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name            | Field Name               | Field Type  | Notes                                                                                                                                                                                                                                        |
	 * |-----------|-------|----------|-----------------------|--------------------------|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x38      | Play  | Client   | Action                | Action                   | VarInt Enum | Determines the format of the rest of the packet                                                                                                                                                                                              |
	 * | 0x38      | Play  | Client   | Action                | Field Name               |             |                                                                                                                                                                                                                                              |
	 * | 0x38      | Play  | Client   | 0: set size           | Diameter                 | Double      | Length of a single side of the world border, in meters                                                                                                                                                                                       |
	 * | 0x38      | Play  | Client   | 1: lerp size          | Old Diameter             | Double      | Current length of a single side of the world border, in meters                                                                                                                                                                               |
	 * | 0x38      | Play  | Client   | 1: lerp size          | New Diameter             | Double      | Target length of a single side of the world border, in meters                                                                                                                                                                                |
	 * | 0x38      | Play  | Client   | 1: lerp size          | Speed                    | VarLong     | Number of real-time milliseconds until New Diameter is reached. It appears that Notchian server does not sync world border speed to game ticks, so it gets out of sync with server lag. If the world border is not moving, this is set to 0. |
	 * | 0x38      | Play  | Client   | 2: set center         | X                        | Double      |                                                                                                                                                                                                                                              |
	 * | 0x38      | Play  | Client   | 2: set center         | Z                        | Double      |                                                                                                                                                                                                                                              |
	 * | 0x38      | Play  | Client   | 3: initialize         | X                        | Double      |                                                                                                                                                                                                                                              |
	 * | 0x38      | Play  | Client   | 3: initialize         | Z                        | Double      |                                                                                                                                                                                                                                              |
	 * | 0x38      | Play  | Client   | 3: initialize         | Old Diameter             | Double      | Current length of a single side of the world border, in meters                                                                                                                                                                               |
	 * | 0x38      | Play  | Client   | 3: initialize         | New Diameter             | Double      | Target length of a single side of the world border, in meters                                                                                                                                                                                |
	 * | 0x38      | Play  | Client   | 3: initialize         | Speed                    | VarLong     | Number of real-time milliseconds until New Diameter is reached. It appears that Notchian server does not sync world border speed to game ticks, so it gets out of sync with server lag. If the world border is not moving, this is set to 0. |
	 * | 0x38      | Play  | Client   | 3: initialize         | Portal Teleport Boundary | VarInt      | Resulting coordinates from a portal teleport are limited to ±value. Usually 29999984.                                                                                                                                                       |
	 * | 0x38      | Play  | Client   | 3: initialize         | Warning Time             | VarInt      | In seconds as set by /worldborder warning time                                                                                                                                                                                               |
	 * | 0x38      | Play  | Client   | 3: initialize         | Warning Blocks           | VarInt      | In meters                                                                                                                                                                                                                                    |
	 * | 0x38      | Play  | Client   | 4: set warning time   | Warning Time             | VarInt      | In seconds as set by /worldborder warning time                                                                                                                                                                                               |
	 * | 0x38      | Play  | Client   | 5: set warning blocks | Warning Blocks           | VarInt      | In meters                                                                                                                                                                                                                                    |
	 * 
	 */
}

// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x35
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x35
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x35
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x35
type PlayWorldBorder_316_6 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name            | Field Name               | Field Type  | Notes                                                                                                                                                                                                                                        |
	 * |-----------|-------|----------|-----------------------|--------------------------|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x35      | Play  | Client   | Action                | Action                   | VarInt Enum | Determines the format of the rest of the packet                                                                                                                                                                                              |
	 * | 0x35      | Play  | Client   | Action                | Field Name               |             |                                                                                                                                                                                                                                              |
	 * | 0x35      | Play  | Client   | 0: set size           | Diameter                 | Double      | Length of a single side of the world border, in meters                                                                                                                                                                                       |
	 * | 0x35      | Play  | Client   | 1: lerp size          | Old Diameter             | Double      | Current length of a single side of the world border, in meters                                                                                                                                                                               |
	 * | 0x35      | Play  | Client   | 1: lerp size          | New Diameter             | Double      | Target length of a single side of the world border, in meters                                                                                                                                                                                |
	 * | 0x35      | Play  | Client   | 1: lerp size          | Speed                    | VarLong     | Number of real-time milliseconds until New Diameter is reached. It appears that Notchian server does not sync world border speed to game ticks, so it gets out of sync with server lag. If the world border is not moving, this is set to 0. |
	 * | 0x35      | Play  | Client   | 2: set center         | X                        | Double      |                                                                                                                                                                                                                                              |
	 * | 0x35      | Play  | Client   | 2: set center         | Z                        | Double      |                                                                                                                                                                                                                                              |
	 * | 0x35      | Play  | Client   | 3: initialize         | X                        | Double      |                                                                                                                                                                                                                                              |
	 * | 0x35      | Play  | Client   | 3: initialize         | Z                        | Double      |                                                                                                                                                                                                                                              |
	 * | 0x35      | Play  | Client   | 3: initialize         | Old Diameter             | Double      | Current length of a single side of the world border, in meters                                                                                                                                                                               |
	 * | 0x35      | Play  | Client   | 3: initialize         | New Diameter             | Double      | Target length of a single side of the world border, in meters                                                                                                                                                                                |
	 * | 0x35      | Play  | Client   | 3: initialize         | Speed                    | VarLong     | Number of real-time milliseconds until New Diameter is reached. It appears that Notchian server does not sync world border speed to game ticks, so it gets out of sync with server lag. If the world border is not moving, this is set to 0. |
	 * | 0x35      | Play  | Client   | 3: initialize         | Portal Teleport Boundary | VarInt      | Resulting coordinates from a portal teleport are limited to ±value. Usually 29999984.                                                                                                                                                       |
	 * | 0x35      | Play  | Client   | 3: initialize         | Warning Time             | VarInt      | In seconds as set by /worldborder warning time                                                                                                                                                                                               |
	 * | 0x35      | Play  | Client   | 3: initialize         | Warning Blocks           | VarInt      | In meters                                                                                                                                                                                                                                    |
	 * | 0x35      | Play  | Client   | 4: set warning time   | Warning Time             | VarInt      | In seconds as set by /worldborder warning time                                                                                                                                                                                               |
	 * | 0x35      | Play  | Client   | 5: set warning blocks | Warning Blocks           | VarInt      | In meters                                                                                                                                                                                                                                    |
	 * 
	 */
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x42
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x42
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x42
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x42
type PlayWorldBorderCenter_758_0 struct {
	X Double // Double
	Z Double // Double
}

var _ Packet = (*PlayWorldBorderCenter_758_0)(nil)

func (p PlayWorldBorderCenter_758_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.Z)
}

func (p *PlayWorldBorderCenter_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x43
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x43
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x43
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x43
type PlayWorldBorderLerpSize_758_0 struct {
	/* Current length of a single side of the world border, in meters. */
	OldDiameter Double // Double
	/* Target length of a single side of the world border, in meters. */
	NewDiameter Double // Double
	/* Number of real-time milliseconds until New Diameter is reached. It appears that Notchian server does not sync world border speed to game ticks, so it gets out of sync with server lag. If the world border is not moving, this is set to 0. */
	Speed VarLong // VarLong
}

var _ Packet = (*PlayWorldBorderLerpSize_758_0)(nil)

func (p PlayWorldBorderLerpSize_758_0)Encode(b *PacketBuilder){
	b.Double(p.OldDiameter)
	b.Double(p.NewDiameter)
	b.VarLong(p.Speed)
}

func (p *PlayWorldBorderLerpSize_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.OldDiameter, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.NewDiameter, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Speed, ok = r.VarLong(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x44
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x44
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x44
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x44
type PlayWorldBorderSize_758_0 struct {
	/* Length of a single side of the world border, in meters. */
	Diameter Double // Double
}

var _ Packet = (*PlayWorldBorderSize_758_0)(nil)

func (p PlayWorldBorderSize_758_0)Encode(b *PacketBuilder){
	b.Double(p.Diameter)
}

func (p *PlayWorldBorderSize_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Diameter, ok = r.Double(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x45
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x45
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x45
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x45
type PlayWorldBorderWarningDelay_758_0 struct {
	/* In seconds as set by /worldborder warning time. */
	WarningTime VarInt // VarInt
}

var _ Packet = (*PlayWorldBorderWarningDelay_758_0)(nil)

func (p PlayWorldBorderWarningDelay_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.WarningTime)
}

func (p *PlayWorldBorderWarningDelay_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WarningTime, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x46
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x46
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x46
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x46
type PlayWorldBorderWarningReach_758_0 struct {
	/* In meters. */
	WarningBlocks VarInt // VarInt
}

var _ Packet = (*PlayWorldBorderWarningReach_758_0)(nil)

func (p PlayWorldBorderWarningReach_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.WarningBlocks)
}

func (p *PlayWorldBorderWarningReach_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.WarningBlocks, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x25
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x25
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x21
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x22
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x20
type PlayWorldEvent_763_0 struct {
	/* The event, see below. */
	Event Int // Int
	/* The location of the event. */
	Location Position // Position
	/* Extra data for certain events, see below. */
	Data Int // Int
	/* See above. */
	DisableRelativeVolume Bool // Boolean
}

var _ Packet = (*PlayWorldEvent_763_0)(nil)

func (p PlayWorldEvent_763_0)Encode(b *PacketBuilder){
	b.Int(p.Event)
	p.Location.Encode(b)
	b.Int(p.Data)
	b.Bool(p.DisableRelativeVolume)
}

func (p *PlayWorldEvent_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Event, ok = r.Int(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Data, ok = r.Int(); !ok {
		return io.EOF
	}
	if p.DisableRelativeVolume, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0xf
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0xc
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0xc
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0xd
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0xf
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0xf
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0xf
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0xf
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x3
type Player_404_0 struct {
	/* True if the client is on the ground, false otherwise */
	OnGround Bool // Boolean
}

var _ Packet = (*Player_404_0)(nil)

func (p Player_404_0)Encode(b *PacketBuilder){
	b.Bool(p.OnGround)
}

func (p *Player_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x34
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x34
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=client; ID=0x30
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=client; ID=0x31
// Protocol=759; ProtocolName=1.19; State=play; Bound=client; ID=0x2f
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x32
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x32
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x32
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x32
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x30
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x30
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x32
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x31
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x2e
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x2c
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x2c
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x2b
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x2b
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x2b
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x2b
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x2b
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x39
type PlayerAbilities_763_0 struct {
	/* Bit field, see below */
	Flags Byte // Byte
	FlyingSpeed Float // Float
	/* Modifies the field of view, like a speed potion. A Notchian server will use the same value as the movement speed (send in the Entity Properties packet). */
	FieldOfViewModifier Float // Float
}

var _ Packet = (*PlayerAbilities_763_0)(nil)

func (p PlayerAbilities_763_0)Encode(b *PacketBuilder){
	b.Byte(p.Flags)
	b.Float(p.FlyingSpeed)
	b.Float(p.FieldOfViewModifier)
}

func (p *PlayerAbilities_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.FlyingSpeed, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.FieldOfViewModifier, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x1c
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x1c
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x1b
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x1c
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x1b
// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x19
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x19
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x19
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x19
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x1a
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x1a
type PlayerAbilitiesServer_763_0 struct {
	/* Bit mask. 0x02: is flying */
	Flags Byte // Byte
}

var _ Packet = (*PlayerAbilitiesServer_763_0)(nil)

func (p PlayerAbilitiesServer_763_0)Encode(b *PacketBuilder){
	b.Byte(p.Flags)
}

func (p *PlayerAbilitiesServer_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x19
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x19
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x17
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x13
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x13
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x13
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x12
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x12
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x12
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x12
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x13
type PlayerAbilitiesServer_578_1 struct {
	/* Bit mask. 0x08: damage disabled (god mode), 0x04: can fly, 0x02: is flying, 0x01: is Creative */
	Flags Byte // Byte
	FlyingSpeed Float // Float
	WalkingSpeed Float // Float
}

var _ Packet = (*PlayerAbilitiesServer_578_1)(nil)

func (p PlayerAbilitiesServer_578_1)Encode(b *PacketBuilder){
	b.Byte(p.Flags)
	b.Float(p.FlyingSpeed)
	b.Float(p.WalkingSpeed)
}

func (p *PlayerAbilitiesServer_578_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.FlyingSpeed, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.WalkingSpeed, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x1d
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x1d
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x1c
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x1d
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x1c
type PlayerAction_763_0 struct {
	/* The action the player is taking against the block (see below). */
	Status VarInt // VarInt Enum
	/* Block position. */
	Location Position // Position
	/* The face being hit (see below). */
	Face Byte // Byte Enum
	Sequence VarInt // VarInt
}

var _ Packet = (*PlayerAction_763_0)(nil)

func (p PlayerAction_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.Status)
	p.Location.Encode(b)
	b.Byte(p.Face)
	b.VarInt(p.Sequence)
}

func (p *PlayerAction_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Status, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Face, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.Sequence, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x2e
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x2e
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x2e
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x2e
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x2e
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x2e
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x2c
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x2c
type PlayerBlockPlacement_758_0 struct {
	/* The hand from which the block is placed; 0: main hand, 1: off hand */
	Hand VarInt // VarInt Enum
	/* Block position */
	Location Position // Position
	/* The face on which the block is placed (as documented at Player Digging) */
	Face VarInt // VarInt Enum
	/* The position of the crosshair on the block, from 0 to 1 increasing from west to east */
	CursorPositionX Float // Float
	/* The position of the crosshair on the block, from 0 to 1 increasing from bottom to top */
	CursorPositionY Float // Float
	/* The position of the crosshair on the block, from 0 to 1 increasing from north to south */
	CursorPositionZ Float // Float
	/* True when the player's head is inside of a block. */
	InsideBlock Bool // Boolean
}

var _ Packet = (*PlayerBlockPlacement_758_0)(nil)

func (p PlayerBlockPlacement_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.Hand)
	p.Location.Encode(b)
	b.VarInt(p.Face)
	b.Float(p.CursorPositionX)
	b.Float(p.CursorPositionY)
	b.Float(p.CursorPositionZ)
	b.Bool(p.InsideBlock)
}

func (p *PlayerBlockPlacement_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Hand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Face, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.CursorPositionX, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.CursorPositionY, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.CursorPositionZ, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.InsideBlock, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x29
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x1f
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x1f
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x1f
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x1c
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x1c
type PlayerBlockPlacement_404_1 struct {
	/* Block position */
	Location Position // Position
	/* The face on which the block is placed (as documented at Player Digging) */
	Face VarInt // VarInt Enum
	/* The hand from which the block is placed; 0: main hand, 1: off hand */
	Hand VarInt // VarInt Enum
	/* The position of the crosshair on the block, from 0 to 1 increasing from west to east */
	CursorPositionX Float // Float
	/* The position of the crosshair on the block, from 0 to 1 increasing from bottom to top */
	CursorPositionY Float // Float
	/* The position of the crosshair on the block, from 0 to 1 increasing from north to south */
	CursorPositionZ Float // Float
}

var _ Packet = (*PlayerBlockPlacement_404_1)(nil)

func (p PlayerBlockPlacement_404_1)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.VarInt(p.Face)
	b.VarInt(p.Hand)
	b.Float(p.CursorPositionX)
	b.Float(p.CursorPositionY)
	b.Float(p.CursorPositionZ)
}

func (p *PlayerBlockPlacement_404_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Face, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Hand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.CursorPositionX, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.CursorPositionY, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.CursorPositionZ, ok = r.Float(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x1c
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x1c
type PlayerBlockPlacement_210_2 struct {
	/* Block position */
	Location Position // Position
	/* The face on which the block is placed (as documented at Player Digging) */
	Face VarInt // VarInt Enum
	/* The hand from which the block is placed; 0: main hand, 1: off hand */
	Hand VarInt // VarInt Enum
	/* The position of the crosshair on the block, from 0 to 15 increasing from west to east */
	CursorPositionX UByte // Unsigned Byte
	/* The position of the crosshair on the block, from 0 to 15 increasing from bottom to top */
	CursorPositionY UByte // Unsigned Byte
	/* The position of the crosshair on the block, from 0 to 15 increasing from north to south */
	CursorPositionZ UByte // Unsigned Byte
}

var _ Packet = (*PlayerBlockPlacement_210_2)(nil)

func (p PlayerBlockPlacement_210_2)Encode(b *PacketBuilder){
	p.Location.Encode(b)
	b.VarInt(p.Face)
	b.VarInt(p.Hand)
	b.UByte(p.CursorPositionX)
	b.UByte(p.CursorPositionY)
	b.UByte(p.CursorPositionZ)
}

func (p *PlayerBlockPlacement_210_2)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Face, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.Hand, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.CursorPositionX, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.CursorPositionY, ok = r.UByte(); !ok {
		return io.EOF
	}
	if p.CursorPositionZ, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x35
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x35
type PlayerChatMessage_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Sector            | Field Name                  | Field Name                  | Field Type          | Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
	 * |-----------|-------|----------|-------------------|-----------------------------|-----------------------------|---------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x35      | Play  | Client   | Header            | Sender                      | Sender                      | UUID                | Used by the Notchian client for the disableChat launch option. Setting both longs to 0 will always display the message regardless of the setting.                                                                                                                                                                                                                                                                                                                                                                                                     |
	 * | 0x35      | Play  | Client   | Header            | Index                       | Index                       | VarInt              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
	 * | 0x35      | Play  | Client   | Header            | Message Signature Present   | Message Signature Present   | Boolean             | States if a message signature is present                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
	 * | 0x35      | Play  | Client   | Header            | Message Signature bytes     | Message Signature bytes     | Optional Byte Array | Only present if Message Signature Present is true. Cryptography, the signature consists of the Sender UUID, Session UUID from the Player Session packet, Index, Salt, Timestamp in epoch seconds, the length of the original chat content, the original content itself, the length of Previous Messages, and all of the Previous message signatures. These values are hashed with SHA-256 and signed using the RSA cryptosystem. Modifying any of these values in the packet will cause this signature to fail. This buffer is always 256 bytes long. |
	 * | 0x35      | Play  | Client   | Body              | Message                     | Message                     | String              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
	 * | 0x35      | Play  | Client   | Body              | Timestamp                   | Timestamp                   | Long                | Represents the time the message was signed as milliseconds since the epoch, used to check if the message was received within 2 minutes of it being sent.                                                                                                                                                                                                                                                                                                                                                                                              |
	 * | 0x35      | Play  | Client   | Body              | Salt                        | Salt                        | Long                | Cryptography, used for validating the message signature.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
	 * | 0x35      | Play  | Client   | Previous Messages | Total Previous Messages     | Total Previous Messages     | VarInt              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
	 * | 0x35      | Play  | Client   | Previous Messages | Array                       | Message ID                  | VarInt              | The message Id, used for validating message signature.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
	 * | 0x35      | Play  | Client   | Previous Messages | Array                       | Signature                   | Optional Byte Array | The previous message's signature. Contains the same type of data as Message Signature bytes above.                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
	 * | 0x35      | Play  | Client   | Other             | Unsigned Content Present    | Unsigned Content Present    | Boolean             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
	 * | 0x35      | Play  | Client   | Other             | Unsigned Content            | Unsigned Content            | Optional Chat       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
	 * | 0x35      | Play  | Client   | Other             | Filter Type                 | Filter Type                 | Enum VarInt         | If the message has been filtered                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
	 * | 0x35      | Play  | Client   | Other             | Filter Type Bits            | Filter Type Bits            | Optional BitSet     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
	 * | 0x35      | Play  | Client   | Network target    | Chat Type                   | Chat Type                   | VarInt              | The chat type from the Login (play) packet used for this message                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
	 * | 0x35      | Play  | Client   | Network target    | Network name                | Network name                | Chat                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
	 * | 0x35      | Play  | Client   | Network target    | Network target name present | Network target name present | Boolean             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
	 * | 0x35      | Play  | Client   | Network target    | Network target name         | Network target name         | Optional Chat       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x1e
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x1e
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x1d
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x1e
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x1d
type PlayerCommand_763_0 struct {
	/* Player ID */
	EntityID VarInt // VarInt
	/* The ID of the action, see below. */
	ActionID VarInt // VarInt Enum
	/* Only used by the “start jump with horse” action, in which case it ranges from 0 to 100. In all other cases it is 0. */
	JumpBoost VarInt // VarInt
}

var _ Packet = (*PlayerCommand_763_0)(nil)

func (p PlayerCommand_763_0)Encode(b *PacketBuilder){
	b.VarInt(p.EntityID)
	b.VarInt(p.ActionID)
	b.VarInt(p.JumpBoost)
}

func (p *PlayerCommand_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.EntityID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.ActionID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.JumpBoost, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x1a
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x1a
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x1a
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x1a
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x1b
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x1b
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x1a
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x1a
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x18
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0x14
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0x14
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x14
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0x13
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0x13
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0x13
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0x13
type PlayerDigging_758_0 struct {
	/* The action the player is taking against the block (see below) */
	Status VarInt // VarInt Enum
	/* Block position */
	Location Position // Position
	/* The face being hit (see below) */
	Face Byte // Byte Enum
}

var _ Packet = (*PlayerDigging_758_0)(nil)

func (p PlayerDigging_758_0)Encode(b *PacketBuilder){
	b.VarInt(p.Status)
	p.Location.Encode(b)
	b.Byte(p.Face)
}

func (p *PlayerDigging_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Status, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if err = p.Location.DecodeFrom(r); err != nil {
		return err
	}
	if p.Face, ok = r.Byte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x36
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x36
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x36
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x36
type PlayerInfo_758_2 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name        | Field Name             | Field Name           | Field Name           | Field Type | Field Type    | Field Type              | Notes                                                    |
	 * |-----------|-------|----------|-------------------|------------------------|----------------------|----------------------|------------|---------------|-------------------------|----------------------------------------------------------|
	 * | 0x36      | Play  | Client   | Action            | Action                 | Action               | Action               | VarInt     | VarInt        | VarInt                  | Determines the rest of the Player format after the UUID. |
	 * | 0x36      | Play  | Client   | Number Of Players | Number Of Players      | Number Of Players    | Number Of Players    | VarInt     | VarInt        | VarInt                  | Number of elements in the following array.               |
	 * | 0x36      | Play  | Client   | Player            | UUID                   | UUID                 | UUID                 | Array      | UUID          | UUID                    |                                                          |
	 * | 0x36      | Play  | Client   | Player            | Action                 | Field Name           | Field Name           | Array      |               |                         |                                                          |
	 * | 0x36      | Play  | Client   | Player            | 0: add player          | Name                 | Name                 | Array      | String (16)   | String (16)             |                                                          |
	 * | 0x36      | Play  | Client   | Player            | 0: add player          | Number Of Properties | Number Of Properties | Array      | VarInt        | VarInt                  | Number of elements in the following array.               |
	 * | 0x36      | Play  | Client   | Player            | 0: add player          | Property             | Name                 | Array      | Array         | String (32767)          |                                                          |
	 * | 0x36      | Play  | Client   | Player            | 0: add player          | Property             | Value                | Array      | Array         | String (32767)          |                                                          |
	 * | 0x36      | Play  | Client   | Player            | 0: add player          | Property             | Is Signed            | Array      | Array         | Boolean                 |                                                          |
	 * | 0x36      | Play  | Client   | Player            | 0: add player          | Property             | Signature            | Array      | Array         | Optional String (32767) | Only if Is Signed is true.                               |
	 * | 0x36      | Play  | Client   | Player            | 0: add player          | Gamemode             | Gamemode             | Array      | VarInt        | VarInt                  |                                                          |
	 * | 0x36      | Play  | Client   | Player            | 0: add player          | Ping                 | Ping                 | Array      | VarInt        | VarInt                  | Measured in milliseconds.                                |
	 * | 0x36      | Play  | Client   | Player            | 0: add player          | Has Display Name     | Has Display Name     | Array      | Boolean       | Boolean                 |                                                          |
	 * | 0x36      | Play  | Client   | Player            | 0: add player          | Display Name         | Display Name         | Array      | Optional Chat | Optional Chat           | Only if Has Display Name is true.                        |
	 * | 0x36      | Play  | Client   | Player            | 1: update gamemode     | Gamemode             | Gamemode             | Array      | VarInt        | VarInt                  |                                                          |
	 * | 0x36      | Play  | Client   | Player            | 2: update latency      | Ping                 | Ping                 | Array      | VarInt        | VarInt                  | Measured in milliseconds.                                |
	 * | 0x36      | Play  | Client   | Player            | 3: update display name | Has Display Name     | Has Display Name     | Array      | Boolean       | Boolean                 |                                                          |
	 * | 0x36      | Play  | Client   | Player            | 3: update display name | Display Name         | Display Name         | Array      | Optional Chat | Optional Chat           | Only send if Has Display Name is true.                   |
	 * | 0x36      | Play  | Client   | Player            | 4: remove player       | no fields            | no fields            | Array      | no fields     | no fields               |                                                          |
	 * 
	 */
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x32
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x32
type PlayerInfo_754_3 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name        | Field Name             | Field Name           | Field Name           | Field Type | Field Type    | Field Type              | Notes                                                   |
	 * |-----------|-------|----------|-------------------|------------------------|----------------------|----------------------|------------|---------------|-------------------------|---------------------------------------------------------|
	 * | 0x32      | Play  | Client   | Action            | Action                 | Action               | Action               | VarInt     | VarInt        | VarInt                  | Determines the rest of the Player format after the UUID |
	 * | 0x32      | Play  | Client   | Number Of Players | Number Of Players      | Number Of Players    | Number Of Players    | VarInt     | VarInt        | VarInt                  | Number of elements in the following array               |
	 * | 0x32      | Play  | Client   | Player            | UUID                   | UUID                 | UUID                 | Array      | UUID          | UUID                    |                                                         |
	 * | 0x32      | Play  | Client   | Player            | Action                 | Field Name           | Field Name           | Array      |               |                         |                                                         |
	 * | 0x32      | Play  | Client   | Player            | 0: add player          | Name                 | Name                 | Array      | String (16)   | String (16)             |                                                         |
	 * | 0x32      | Play  | Client   | Player            | 0: add player          | Number Of Properties | Number Of Properties | Array      | VarInt        | VarInt                  | Number of elements in the following array               |
	 * | 0x32      | Play  | Client   | Player            | 0: add player          | Property             | Name                 | Array      | Array         | String (32767)          |                                                         |
	 * | 0x32      | Play  | Client   | Player            | 0: add player          | Property             | Value                | Array      | Array         | String (32767)          |                                                         |
	 * | 0x32      | Play  | Client   | Player            | 0: add player          | Property             | Is Signed            | Array      | Array         | Boolean                 |                                                         |
	 * | 0x32      | Play  | Client   | Player            | 0: add player          | Property             | Signature            | Array      | Array         | Optional String (32767) | Only if Is Signed is true                               |
	 * | 0x32      | Play  | Client   | Player            | 0: add player          | Gamemode             | Gamemode             | Array      | VarInt        | VarInt                  |                                                         |
	 * | 0x32      | Play  | Client   | Player            | 0: add player          | Ping                 | Ping                 | Array      | VarInt        | VarInt                  | Measured in milliseconds                                |
	 * | 0x32      | Play  | Client   | Player            | 0: add player          | Has Display Name     | Has Display Name     | Array      | Boolean       | Boolean                 |                                                         |
	 * | 0x32      | Play  | Client   | Player            | 0: add player          | Display Name         | Display Name         | Array      | Optional Chat | Optional Chat           | Only if Has Display Name is true                        |
	 * | 0x32      | Play  | Client   | Player            | 1: update gamemode     | Gamemode             | Gamemode             | Array      | VarInt        | VarInt                  |                                                         |
	 * | 0x32      | Play  | Client   | Player            | 2: update latency      | Ping                 | Ping                 | Array      | VarInt        | VarInt                  | Measured in milliseconds                                |
	 * | 0x32      | Play  | Client   | Player            | 3: update display name | Has Display Name     | Has Display Name     | Array      | Boolean       | Boolean                 |                                                         |
	 * | 0x32      | Play  | Client   | Player            | 3: update display name | Display Name         | Display Name         | Array      | Optional Chat | Optional Chat           | Only send if Has Display Name is true                   |
	 * | 0x32      | Play  | Client   | Player            | 4: remove player       | no fields            | no fields            | Array      | no fields     | no fields               |                                                         |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x39
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x39
type PlayerInfoRemove_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name        | Field Name        | Field Type    | Notes                                      |
	 * |-----------|-------|----------|-------------------|-------------------|---------------|--------------------------------------------|
	 * | 0x39      | Play  | Client   | Number of Players | Number of Players | VarInt        | Number of elements in the following array. |
	 * | 0x39      | Play  | Client   | Player            | Player Id         | Array of UUID | UUIDs of players to remove.                |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=client; ID=0x3a
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=client; ID=0x3a
type PlayerInfoUpdate_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name        | Field Name                         | Field Name                | Field Name                | Field Type | Field Type    | Field Type              | Notes                                                                                                          |
	 * |-----------|-------|----------|-------------------|------------------------------------|---------------------------|---------------------------|------------|---------------|-------------------------|----------------------------------------------------------------------------------------------------------------|
	 * | 0x3A      | Play  | Client   |                   |                                    |                           |                           |            |               |                         |                                                                                                                |
	 * | 0x3A      | Play  | Client   | Actions           | Actions                            | Actions                   | Actions                   | Byte       | Byte          | Byte                    | Bit Mask. The actions to process. This must have a bit set for every action below, whether it's true or false. |
	 * | 0x3A      | Play  | Client   | Number Of Actions | Number Of Actions                  | Number Of Actions         | Number Of Actions         | VarInt     | VarInt        | VarInt                  | Number of elements in the following array.                                                                     |
	 * | 0x3A      | Play  | Client   | Action            | UUID                               | UUID                      | UUID                      | Array      | UUID          | UUID                    | The player UUID                                                                                                |
	 * | 0x3A      | Play  | Client   | Action            | Action                             | Field Name                | Field Name                | Array      |               |                         |                                                                                                                |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 0: add player          | Name                      | Name                      | Array      | String (16)   | String (16)             |                                                                                                                |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 0: add player          | Number Of Properties      | Number Of Properties      | Array      | VarInt        | VarInt                  | Number of elements in the following array.                                                                     |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 0: add player          | Property                  | Name                      | Array      | Array         | String (32767)          |                                                                                                                |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 0: add player          | Property                  | Value                     | Array      | Array         | String (32767)          |                                                                                                                |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 0: add player          | Property                  | Is Signed                 | Array      | Array         | Boolean                 |                                                                                                                |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 0: add player          | Property                  | Signature                 | Array      | Array         | Optional String (32767) | Only if Is Signed is true.                                                                                     |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 1: initialize chat     | Has Signature Data        | Has Signature Data        | Array      | Boolean       | Boolean                 |                                                                                                                |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 1: initialize chat     | Chat session ID           | Chat session ID           | Array      | UUID          | UUID                    | Only send if Has Signature Data is true.                                                                       |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 1: initialize chat     | Public key expiry time    | Public key expiry time    | Array      | Long          | Long                    | Key expiry time, as a UNIX timestamp in milliseconds. Only send if Has Signature Data is true.                 |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 1: initialize chat     | Encoded public key size   | Encoded public key size   | Array      | VarInt        | VarInt                  | Size of the following array. Only send if Has Signature Data is true.                                          |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 1: initialize chat     | Encoded public key        | Encoded public key        | Array      | Byte Array    | Byte Array              | The player's public key, in bytes. Only send if Has Signature Data is true.                                    |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 1: initialize chat     | Public key signature size | Public key signature size | Array      | VarInt        | VarInt                  | Size of the following array. Only send if Has Signature Data is true.                                          |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 1: initialize chat     | Public key signature      | Public key signature      | Array      | Byte Array    | Byte Array              | The public key's digital signature. Only send if Has Signature Data is true.                                   |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 2: update game mode    | Game mode                 | Game mode                 | Array      | VarInt        | VarInt                  |                                                                                                                |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 3: update listed       | Listed                    | Listed                    | Array      | Boolean       | Boolean                 | Whether the player should be listed on the player list.                                                        |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 4: update latency      | Ping                      | Ping                      | Array      | VarInt        | VarInt                  | Measured in milliseconds.                                                                                      |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 5: update display name | Has Display Name          | Has Display Name          | Array      | Boolean       | Boolean                 |                                                                                                                |
	 * | 0x3A      | Play  | Client   | Action            | Actions bit 5: update display name | Display Name              | Display Name              | Array      | Optional Chat | Optional Chat           | Only send if Has Display Name is true.                                                                         |
	 * 
	 */
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x1f
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x1f
// Protocol=761; ProtocolName=1.19.3; State=play; Bound=server; ID=0x1e
// Protocol=760; ProtocolName=1.19.2; State=play; Bound=server; ID=0x1f
// Protocol=759; ProtocolName=1.19; State=play; Bound=server; ID=0x1e
type PlayerInput_763_0 struct {
	/* Positive to the left of the player. */
	Sideways Float // Float
	/* Positive forward. */
	Forward Float // Float
	/* Bit mask. 0x1: jump, 0x2: unmount. */
	Flags UByte // Unsigned Byte
}

var _ Packet = (*PlayerInput_763_0)(nil)

func (p PlayerInput_763_0)Encode(b *PacketBuilder){
	b.Float(p.Sideways)
	b.Float(p.Forward)
	b.UByte(p.Flags)
}

func (p *PlayerInput_763_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Sideways, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Forward, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Flags, ok = r.UByte(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x5f
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x5f
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x5e
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x5e
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x53
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x53
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x54
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x53
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x4e
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x4a
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x4a
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x49
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x47
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x47
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x47
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x47
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=client; ID=0x47
type PlayerListHeaderAndFooter_758_0 struct {
	/* To remove the header, send a empty translatable component: {"translate":""} */
	Header Object // Chat
	/* To remove the footer, send a empty translatable component: {"translate":""} */
	Footer Object // Chat
}

var _ Packet = (*PlayerListHeaderAndFooter_758_0)(nil)

func (p PlayerListHeaderAndFooter_758_0)Encode(b *PacketBuilder){
	b.JSON(p.Header)
	b.JSON(p.Footer)
}

func (p *PlayerListHeaderAndFooter_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if err = r.JSON(&p.Header); err != nil {
		return err
	}
	if err = r.JSON(&p.Footer); err != nil {
		return err
	}
	return nil
}

// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x2e
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x2e
type PlayerListItem_340_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name        | Field Name             | Field Name           | Field Name           | Field Type | Field Type    | Field Type              | Notes                                                   |
	 * |-----------|-------|----------|-------------------|------------------------|----------------------|----------------------|------------|---------------|-------------------------|---------------------------------------------------------|
	 * | 0x2E      | Play  | Client   | Action            | Action                 | Action               | Action               | VarInt     | VarInt        | VarInt                  | Determines the rest of the Player format after the UUID |
	 * | 0x2E      | Play  | Client   | Number Of Players | Number Of Players      | Number Of Players    | Number Of Players    | VarInt     | VarInt        | VarInt                  | Number of elements in the following array               |
	 * | 0x2E      | Play  | Client   | Player            | UUID                   | UUID                 | UUID                 | Array      | UUID          | UUID                    |                                                         |
	 * | 0x2E      | Play  | Client   | Player            | Action                 | Field Name           | Field Name           | Array      |               |                         |                                                         |
	 * | 0x2E      | Play  | Client   | Player            | 0: add player          | Name                 | Name                 | Array      | String (16)   | String (16)             |                                                         |
	 * | 0x2E      | Play  | Client   | Player            | 0: add player          | Number Of Properties | Number Of Properties | Array      | VarInt        | VarInt                  | Number of elements in the following array               |
	 * | 0x2E      | Play  | Client   | Player            | 0: add player          | Property             | Name                 | Array      | Array         | String (32767)          |                                                         |
	 * | 0x2E      | Play  | Client   | Player            | 0: add player          | Property             | Value                | Array      | Array         | String (32767)          |                                                         |
	 * | 0x2E      | Play  | Client   | Player            | 0: add player          | Property             | Is Signed            | Array      | Array         | Boolean                 |                                                         |
	 * | 0x2E      | Play  | Client   | Player            | 0: add player          | Property             | Signature            | Array      | Array         | Optional String (32767) | Only if Is Signed is true                               |
	 * | 0x2E      | Play  | Client   | Player            | 0: add player          | Gamemode             | Gamemode             | Array      | VarInt        | VarInt                  |                                                         |
	 * | 0x2E      | Play  | Client   | Player            | 0: add player          | Ping                 | Ping                 | Array      | VarInt        | VarInt                  | Measured in milliseconds                                |
	 * | 0x2E      | Play  | Client   | Player            | 0: add player          | Has Display Name     | Has Display Name     | Array      | Boolean       | Boolean                 |                                                         |
	 * | 0x2E      | Play  | Client   | Player            | 0: add player          | Display Name         | Display Name         | Array      | Optional Chat | Optional Chat           | Only if Has Display Name is true                        |
	 * | 0x2E      | Play  | Client   | Player            | 1: update gamemode     | Gamemode             | Gamemode             | Array      | VarInt        | VarInt                  |                                                         |
	 * | 0x2E      | Play  | Client   | Player            | 2: update latency      | Ping                 | Ping                 | Array      | VarInt        | VarInt                  | Measured in milliseconds                                |
	 * | 0x2E      | Play  | Client   | Player            | 3: update display name | Has Display Name     | Has Display Name     | Array      | Boolean       | Boolean                 |                                                         |
	 * | 0x2E      | Play  | Client   | Player            | 3: update display name | Display Name         | Display Name         | Array      | Optional Chat | Optional Chat           | Only send if Has Display Name is true                   |
	 * | 0x2E      | Play  | Client   | Player            | 4: remove player       | no fields            | no fields            | Array      | no fields     | no fields               |                                                         |
	 * 
	 */
}

// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x2d
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x2d
type PlayerListItem_335_1 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name        | Field Name             | Field Name           | Field Name           | Field Type | Field Type    | Field Type              | Notes                                                   |
	 * |-----------|-------|----------|-------------------|------------------------|----------------------|----------------------|------------|---------------|-------------------------|---------------------------------------------------------|
	 * | 0x2D      | Play  | Client   | Action            | Action                 | Action               | Action               | VarInt     | VarInt        | VarInt                  | Determines the rest of the Player format after the UUID |
	 * | 0x2D      | Play  | Client   | Number Of Players | Number Of Players      | Number Of Players    | Number Of Players    | VarInt     | VarInt        | VarInt                  | Number of elements in the following array               |
	 * | 0x2D      | Play  | Client   | Player            | UUID                   | UUID                 | UUID                 | Array      | UUID          | UUID                    |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | Action                 | Field Name           | Field Name           | Array      |               |                         |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Name                 | Name                 | Array      | String (16)   | String (16)             |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Number Of Properties | Number Of Properties | Array      | VarInt        | VarInt                  | Number of elements in the following array               |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Property             | Name                 | Array      | Array         | String (32767)          |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Property             | Value                | Array      | Array         | String (32767)          |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Property             | Is Signed            | Array      | Array         | Boolean                 |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Property             | Signature            | Array      | Array         | Optional String (32767) | Only if Is Signed is true                               |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Gamemode             | Gamemode             | Array      | VarInt        | VarInt                  |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Ping                 | Ping                 | Array      | VarInt        | VarInt                  |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Has Display Name     | Has Display Name     | Array      | Boolean       | Boolean                 |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Display Name         | Display Name         | Array      | Optional Chat | Optional Chat           | Only if Has Display Name is true                        |
	 * | 0x2D      | Play  | Client   | Player            | 1: update gamemode     | Gamemode             | Gamemode             | Array      | VarInt        | VarInt                  |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 2: update latency      | Ping                 | Ping                 | Array      | VarInt        | VarInt                  |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 3: update display name | Has Display Name     | Has Display Name     | Array      | Boolean       | Boolean                 |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 3: update display name | Display Name         | Display Name         | Array      | Optional Chat | Optional Chat           | Only send if Has Display Name is true                   |
	 * | 0x2D      | Play  | Client   | Player            | 4: remove player       | no fields            | no fields            | Array      | no fields     | no fields               |                                                         |
	 * 
	 */
}

// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x2d
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x2d
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x2d
type PlayerListItem_315_2 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name        | Field Name             | Field Name           | Field Name           | Field Type | Field Type    | Field Type      | Notes                                                   |
	 * |-----------|-------|----------|-------------------|------------------------|----------------------|----------------------|------------|---------------|-----------------|---------------------------------------------------------|
	 * | 0x2D      | Play  | Client   | Action            | Action                 | Action               | Action               | VarInt     | VarInt        | VarInt          | Determines the rest of the Player format after the UUID |
	 * | 0x2D      | Play  | Client   | Number Of Players | Number Of Players      | Number Of Players    | Number Of Players    | VarInt     | VarInt        | VarInt          | Number of elements in the following array               |
	 * | 0x2D      | Play  | Client   | Player            | UUID                   | UUID                 | UUID                 | Array      | UUID          | UUID            |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | Action                 | Field Name           | Field Name           | Array      |               |                 |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Name                 | Name                 | Array      | String        | String          |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Number Of Properties | Number Of Properties | Array      | VarInt        | VarInt          | Number of elements in the following array               |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Property             | Name                 | Array      | Array         | String          |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Property             | Value                | Array      | Array         | String          |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Property             | Is Signed            | Array      | Array         | Boolean         |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Property             | Signature            | Array      | Array         | Optional String | Only if Is Signed is true                               |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Gamemode             | Gamemode             | Array      | VarInt        | VarInt          |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Ping                 | Ping                 | Array      | VarInt        | VarInt          |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Has Display Name     | Has Display Name     | Array      | Boolean       | Boolean         |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 0: add player          | Display Name         | Display Name         | Array      | Optional Chat | Optional Chat   | Only if Has Display Name is true                        |
	 * | 0x2D      | Play  | Client   | Player            | 1: update gamemode     | Gamemode             | Gamemode             | Array      | VarInt        | VarInt          |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 2: update latency      | Ping                 | Ping                 | Array      | VarInt        | VarInt          |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 3: update display name | Has Display Name     | Has Display Name     | Array      | Boolean       | Boolean         |                                                         |
	 * | 0x2D      | Play  | Client   | Player            | 3: update display name | Display Name         | Display Name         | Array      | Optional Chat | Optional Chat   | Only send if Has Display Name is true                   |
	 * | 0x2D      | Play  | Client   | Player            | 4: remove player       | no fields            | no fields            | Array      | no fields     | no fields       |                                                         |
	 * 
	 */
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x12
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0xf
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0xf
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0x10
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0xe
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0xe
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0xe
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0xe
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x5
type PlayerLook_404_0 struct {
	/* Absolute rotation on the X Axis, in degrees */
	Yaw Float // Float
	/* Absolute rotation on the Y Axis, in degrees */
	Pitch Float // Float
	/* True if the client is on the ground, False otherwise */
	OnGround Bool // Boolean
}

var _ Packet = (*PlayerLook_404_0)(nil)

func (p PlayerLook_404_0)Encode(b *PacketBuilder){
	b.Float(p.Yaw)
	b.Float(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlayerLook_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x14
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x14
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x14
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x14
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x15
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x15
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x14
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x14
type PlayerMovement_758_0 struct {
	/* True if the client is on the ground, false otherwise */
	OnGround Bool // Boolean
}

var _ Packet = (*PlayerMovement_758_0)(nil)

func (p PlayerMovement_758_0)Encode(b *PacketBuilder){
	b.Bool(p.OnGround)
}

func (p *PlayerMovement_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x11
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x11
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x11
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x11
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x12
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x12
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x11
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x11
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x10
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0xd
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0xd
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0xe
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0xc
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0xc
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0xc
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0xc
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x4
type PlayerPosition_758_0 struct {
	/* Absolute position */
	X Double // Double
	/* Absolute feet position, normally Head Y - 1.62 */
	FeetY Double // Double
	/* Absolute position */
	Z Double // Double
	/* True if the client is on the ground, false otherwise */
	OnGround Bool // Boolean
}

var _ Packet = (*PlayerPosition_758_0)(nil)

func (p PlayerPosition_758_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.FeetY)
	b.Double(p.Z)
	b.Bool(p.OnGround)
}

func (p *PlayerPosition_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.FeetY, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=client; ID=0x38
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=client; ID=0x38
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=client; ID=0x38
// Protocol=755; ProtocolName=1.17; State=play; Bound=client; ID=0x38
type PlayerPositionAndLook_758_0 struct {
	/* Absolute or relative position, depending on Flags. */
	X Double // Double
	/* Absolute or relative position, depending on Flags. */
	Y Double // Double
	/* Absolute or relative position, depending on Flags. */
	Z Double // Double
	/* Absolute or relative rotation on the X axis, in degrees. */
	Yaw Float // Float
	/* Absolute or relative rotation on the Y axis, in degrees. */
	Pitch Float // Float
	/* Bit field, see below. */
	Flags Byte // Byte
	/* Client should confirm this packet with Teleport Confirm containing the same Teleport ID. */
	TeleportID VarInt // VarInt
	/* True if the player should dismount their vehicle. */
	DismountVehicle Bool // Boolean
}

var _ Packet = (*PlayerPositionAndLook_758_0)(nil)

func (p PlayerPositionAndLook_758_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.Float(p.Yaw)
	b.Float(p.Pitch)
	b.Byte(p.Flags)
	b.VarInt(p.TeleportID)
	b.Bool(p.DismountVehicle)
}

func (p *PlayerPositionAndLook_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.TeleportID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	if p.DismountVehicle, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=754; ProtocolName=1.16.5; State=play; Bound=client; ID=0x34
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=client; ID=0x34
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=client; ID=0x36
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=client; ID=0x35
// Protocol=404; ProtocolName=1.13.2; State=play; Bound=client; ID=0x32
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=client; ID=0x2f
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=client; ID=0x2f
// Protocol=335; ProtocolName=1.12; State=play; Bound=client; ID=0x2e
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=client; ID=0x2e
// Protocol=315; ProtocolName=1.11; State=play; Bound=client; ID=0x2e
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=client; ID=0x2e
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=client; ID=0x2e
type PlayerPositionAndLook_754_1 struct {
	/* Absolute or relative position, depending on Flags */
	X Double // Double
	/* Absolute or relative position, depending on Flags */
	Y Double // Double
	/* Absolute or relative position, depending on Flags */
	Z Double // Double
	/* Absolute or relative rotation on the X axis, in degrees */
	Yaw Float // Float
	/* Absolute or relative rotation on the Y axis, in degrees */
	Pitch Float // Float
	/* Bit field, see below */
	Flags Byte // Byte
	/* Client should confirm this packet with Teleport Confirm containing the same Teleport ID */
	TeleportID VarInt // VarInt
}

var _ Packet = (*PlayerPositionAndLook_754_1)(nil)

func (p PlayerPositionAndLook_754_1)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.Y)
	b.Double(p.Z)
	b.Float(p.Yaw)
	b.Float(p.Pitch)
	b.Byte(p.Flags)
	b.VarInt(p.TeleportID)
}

func (p *PlayerPositionAndLook_754_1)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Y, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Flags, ok = r.Byte(); !ok {
		return io.EOF
	}
	if p.TeleportID, ok = r.VarInt(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=404; ProtocolName=1.13.2; State=play; Bound=server; ID=0x11
// Protocol=340; ProtocolName=1.12.2; State=play; Bound=server; ID=0xe
// Protocol=338; ProtocolName=1.12.1; State=play; Bound=server; ID=0xe
// Protocol=335; ProtocolName=1.12; State=play; Bound=server; ID=0xf
// Protocol=316; ProtocolName=1.11.2; State=play; Bound=server; ID=0xd
// Protocol=315; ProtocolName=1.11; State=play; Bound=server; ID=0xd
// Protocol=210; ProtocolName=1.10.2; State=play; Bound=server; ID=0xd
// Protocol=110; ProtocolName=1.9.4; State=play; Bound=server; ID=0xd
// Protocol=47; ProtocolName=1.8.9; State=play; Bound=server; ID=0x6
type PlayerPositionAndLookServer_404_0 struct {
	/* Absolute position */
	X Double // Double
	/* Absolute feet position, normally Head Y - 1.62 */
	FeetY Double // Double
	/* Absolute position */
	Z Double // Double
	/* Absolute rotation on the X Axis, in degrees */
	Yaw Float // Float
	/* Absolute rotation on the Y Axis, in degrees */
	Pitch Float // Float
	/* True if the client is on the ground, false otherwise */
	OnGround Bool // Boolean
}

var _ Packet = (*PlayerPositionAndLookServer_404_0)(nil)

func (p PlayerPositionAndLookServer_404_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.FeetY)
	b.Double(p.Z)
	b.Float(p.Yaw)
	b.Float(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlayerPositionAndLookServer_404_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.FeetY, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x12
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x12
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x12
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x12
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x13
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x13
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x12
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x12
type PlayerPositionAndRotation_758_0 struct {
	/* Absolute position */
	X Double // Double
	/* Absolute feet position, normally Head Y - 1.62 */
	FeetY Double // Double
	/* Absolute position */
	Z Double // Double
	/* Absolute rotation on the X Axis, in degrees */
	Yaw Float // Float
	/* Absolute rotation on the Y Axis, in degrees */
	Pitch Float // Float
	/* True if the client is on the ground, false otherwise */
	OnGround Bool // Boolean
}

var _ Packet = (*PlayerPositionAndRotation_758_0)(nil)

func (p PlayerPositionAndRotation_758_0)Encode(b *PacketBuilder){
	b.Double(p.X)
	b.Double(p.FeetY)
	b.Double(p.Z)
	b.Float(p.Yaw)
	b.Float(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlayerPositionAndRotation_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.X, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.FeetY, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Z, ok = r.Double(); !ok {
		return io.EOF
	}
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=758; ProtocolName=1.18.2; State=play; Bound=server; ID=0x13
// Protocol=757; ProtocolName=1.18.1; State=play; Bound=server; ID=0x13
// Protocol=756; ProtocolName=1.17.1; State=play; Bound=server; ID=0x13
// Protocol=755; ProtocolName=1.17; State=play; Bound=server; ID=0x13
// Protocol=754; ProtocolName=1.16.5; State=play; Bound=server; ID=0x14
// Protocol=753; ProtocolName=1.16.3; State=play; Bound=server; ID=0x14
// Protocol=578; ProtocolName=1.15.2; State=play; Bound=server; ID=0x13
// Protocol=498; ProtocolName=1.14.4; State=play; Bound=server; ID=0x13
type PlayerRotation_758_0 struct {
	/* Absolute rotation on the X Axis, in degrees */
	Yaw Float // Float
	/* Absolute rotation on the Y Axis, in degrees */
	Pitch Float // Float
	/* True if the client is on the ground, False otherwise */
	OnGround Bool // Boolean
}

var _ Packet = (*PlayerRotation_758_0)(nil)

func (p PlayerRotation_758_0)Encode(b *PacketBuilder){
	b.Float(p.Yaw)
	b.Float(p.Pitch)
	b.Bool(p.OnGround)
}

func (p *PlayerRotation_758_0)DecodeFrom(r *PacketReader)(error){
	var ok bool
	_ = ok
	var err error
	_ = err
	if p.Yaw, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.Pitch, ok = r.Float(); !ok {
		return io.EOF
	}
	if p.OnGround, ok = r.Bool(); !ok {
		return io.EOF
	}
	return nil
}

// Protocol=763; ProtocolName=1.20; State=play; Bound=server; ID=0x6
// Protocol=762; ProtocolName=1.19.4; State=play; Bound=server; ID=0x6
type PlayerSession_763_0 struct {
	/*
	 * | Packet ID | State | Bound To | Field Name | Field Name           | Field Type | Notes                                                                                                                                                                            |
	 * |-----------|-------|----------|------------|----------------------|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | 0x06      | Play  | Server   | Session Id | Session Id           | UUID       |                                                                                                                                                                                  |
	 * | 0x06      | Play  | Server   | Public Key | Expires At           | Long       | The time the play session key expires in epoch milliseconds.                                                                                                                     |
	 * | 0x06      | Play  | Server   | Public Key | Public Key Length    | VarInt     | Length of the proceeding public key.                                                                                                                                             |
	 * | 0x06      | Play  | Server   | Public Key | Public Key           | Byte Array | A byte array of an X.509-encoded public key.                                                                                                                                     |
	 * | 0x06      | Play  | Server   | Public Key | Key Signature Length | VarInt     | Length of the proceeding key signature array.                                                                                                                                    |
	 * | 0x06      | Play  | Server   | Public Key | Key Signature        | Byte Array | The signature consists of the player UUID, the key expiration timestamp, and the public key data. These values are hashed using SHA-1 and signed using Mojang's private RSA key. |
	 * 
	 */
}
